<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mac折腾]]></title>
    <url>%2F2019%2F10%2F18%2FMac%2FMac%E6%8A%98%E8%85%BE%2F</url>
    <content type="text"><![CDATA[一些好用的功能触控板用力点按 Froce torch 系统相关修改账户名称在账户相关设置中，有账户名称和全名两个设置。如果想要修改账户名称，需要新建一个管理员账户，然后退出当前账户，在另一个管理员账户中修改账户名称。如果想修改账户全名，需要重置用户文件夹。 环境变量Mac在bash和zsh配置环境变量的几种方法 这里需要注意的是在配置用户环境变量时，~/.bashrc对应bash的用户环境变量。如果已经把bash改成了zsh，需要在~/.zshrc中设置。 bash-&gt;iterms2iTerm2 + Oh My Zsh 打造舒适终端体验 我的一些配置： iterms Theme：Dracula font: 18pt Roboto Mono for Powerline Hotkey: Double click Command 替换Command和Ctrl系统偏好设置-&gt;键盘-&gt;修饰键 Finder标题显示文件夹全称defaults write com.apple.finder _FXShowPosixPathInTitle -bool YES 常用软件MAC软件网站xxmac xclient MacBL 软件卸载工具好用的软件卸载工具 Pycharm安装Pycharm及破解 AnacondaAnaconda官网 将Anaconda加入环境变量：在~/.bashrc或~./zshrc中加入export PATH=&quot;/Users/binbin/anaconda3/bin:$PATH&quot; 多电脑共享键鼠Synergy 度娘网盘 提取码：sk6h 需要注意的： 在第一次使用时需要去掉编辑-&gt;设置-&gt;Use SSL Encryption的勾，然后删除~/Library/Synergy/SSL文件夹 要写清楚主机和从机在局域网中的名称 如果从机是Mac，可以把Super和Ctrl键进行替换 如果出现不能复制粘贴的情况，可以重启Synergy 如果出现已连接但不能移动鼠标的情况，可以在主机端把从机清除再添加一次 MactexMacTex Dash安装破解DocSet下载。下载后存放到/Users/name/Library/Application Support/Dash/中对应位置 网速显示MenuMesters 在目录下打开shellgo2Shell 视频播放器IINA brew &amp; git 安装Homebrew https://brew.sh/ 安装git brew install git brew link git --overwriteAlfred一个很好用的搜索工具。 ForkLift一个很好用的文件管理工具，支持FTP、SMB等多种协议。]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Pytorch常用tensor操作]]></title>
    <url>%2F2019%2F10%2F18%2FPytorch%2FPytorch%E4%B8%AD%E5%B8%B8%E7%94%A8tensor%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1 torch.catcat指的是对多个Tensor在原有某一维度进行拼接，拼接的结果是Tensor的总维数不变，其中用于拼接的那一维等于各分量维数之和。示例： x = torch.rand(2, 3) y = torch.rand(4, 3) z = torch.cat((x, y), 0) 即x和y沿着axis=0的维度进行拼接，得到的结果是一个(6*3)的Tensor此外，还有如下用法： torch.cat((x, x), 0) torch.cat([torch.rand(3, 4), torch.rand(5, 4)], dim=0) 2 torch.chunktorch.chunk(tensor, chunks, dim=0)chunk可以看成cat的逆操作，即将一个矩阵沿着某一维分割开。chunks为分割的份数， dim为分割的维度。例子： x = torch.zeros(2, 3, 4) y = torch.chunk(x, 3, 1) 得到的y是一个tuple，每一个的维度为(2, 1, 4)还可使用Tensor.chunks(chunks, dim=0)效果与上相同。 3 torch.stackstack指的是在新的维度上进行拼接，这个操作会增加维度。示例： x = torch.ones(1, 3) y = torch.ones(1, 3) z1 = torch.stack((x, y), 0) z2 = torch.stack((x, y), 1) z3 = torch.stack((x, y), 2) 输出维数规律：除拼接的维数外别的维数保持不变，拼接的维数等于输入个数之和。则上述三个输出的维数分别为：z1:(2, 1, 3), z2:(1, 2, 3), z3:(1, 3, 2)。注意： torch.stack的输入tensor的维数必须一致，这样才能保证在能够在新的维度进行拼接操作。 4 torch.transposetranspose指的是将Tensor的某两个维度进行交换。示例： x = torch.zeros(2, 3) y = torch.transpose(x, 0, 1) 5 permute &amp; reshapepermute是适合于多维度的维数交换。使用方法：输入希望产生的维度即可。例子： x = torch.zeros(2, 3, 4) y = x.permute(2, 1, 0) 输出y的维度为:(4, 3, 2) reshape和permute功能类似，不过reshape一般用于连续维度的改变，如 x = torch.zeros(2, 3, 4) y = x.reshape(2, 6, 2) 如果用于reshape的维度不是连续的，会出现数据改变的情况。 6 squeezesqueeze是将某一个维度为1的维去除。使用方法：x.squeeze()。例子： x = torch.zeros(3, 1, 2) y = x.squeeze(1) 得到的y的维度为(3, 2)。如果选择的维数不为1，那么得到的结果的维数与原Tensor的维数一致 7 unsqueezeunsqueeze是增加一个维度，维度位置为dim。使用方法：a.unsqueeze(dim)。例子： x = torch.zeros(3, 2) y = x.unsqueeze(2) 得到的y的维数为：(3, 2, 1)use repeat – this will copy each vector 28 times. X = torch.randn(100, 700)X = X.unsqueeze(2).repeat(1, 1, 28) 8 torch.masked_fillmasked_fill将一个tensor中为1的元素用指定的值填充。例如： a = torch.ones(3, 3) 9 torch.viewview将一个tensor变换维度，但其中的数值保持不变 10 torch.bmmbmm即batch_matmul，作用是不考虑batch维度将两个矩阵相乘。 a = torch.ones(128, 4, 3) b = torch.ones(128, 3, 10) result = torch.bmm(a, b) print(result.shape) &gt;&gt;&gt; (128, 4, 10) 11 expand&amp;repeatexpand和repeat都用于扩展Tensor的维度。使用前提：原矩阵的维度和扩展后矩阵的维度一致。因此通常先进行squeeze(dim)或unsqueeze(dim)操作。expand的输入参数是扩展后Tensor的维度，repeat的输入参数是扩展后Tensor相对于原Tensor扩展的倍数。此外，注意expand仅限于对张量中维数为1的维度的扩展，否则会报类型不匹配错误。 例如： a = torch.Tensor([1, 2, 3]) # 最终维数为(3, 5)，相当于第一维不变，第二维扩展5次 b = a.unsqueeze(1).expand(3, 5) # 在第一维扩展1次，在第二维扩展5次 c = a.unsqueeze(1).repeat(1, 5) # output: tensor([[1., 1., 1., 1., 1.], [2., 2., 2., 2., 2.], [3., 3., 3., 3., 3.]]) # RuntimeError: The expanded size of the tensor (6) must match the existing size (3) at non-singleton dimension 2. Target sizes: [1, 4, 6]. Tensor sizes: [1, 2, 3] a.expand(1, 4, 6) expand不会复制数组内存，节省空间。repeat会复制所有数据]]></content>
      <categories>
        <category>Pytorch</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令]]></title>
    <url>%2F2019%2F10%2F18%2FGit%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[提交一个工程到github初始化 git config –global user.name xxx git config –global user.email xxx@xxx.com 常用命令 git init git pull origin master git push origin master git add . git add -A 提交所有改变（包括删除） git commit -m &#39;commit_content&#39; git checkout filename git clone xx git clone xx --depth=1 只拷贝最近一次的提交 在coding.net中添加项目的流程1. 将～/.ssh中的public key加入coding.net的设置中 2. `git init` 3. `git add .` 4. `git commit -m &#39;content&#39;` 5. `git remote add origin gitaddress` 6. `git push origin master`创建分支和转换的流程1. 创建分支：`git branch &lt;name&gt;` 2. 切换分支：`git checkout &lt;name&gt;` 3. 创建加切换分支：`git checkout -b &lt;name&gt;` 4. 删除本地分支：`git branch -d &lt;branch_name&gt;`创建多个远程仓库并上传不同分支1. 创建多个远程仓库：`git remote add &lt;name&gt; &lt;address&gt;`. 注意：远程仓库名不能于origin相同 2. 上传不同分支到远程仓库： `git push &lt;remote_name&gt; &lt;local name&gt;` 3. 删除远程仓库中的分支：`git push &lt;remote_name&gt; --delete &lt;branch_name&gt;`.注意，在github上删除master分支前要先到设置更改默认分支.查看git的状态git status 查看文件修改状态git diff (filename)]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[numpy]]></title>
    <url>%2F2019%2F10%2F18%2FPythonPackages%2Fnumpy%2F</url>
    <content type="text"><![CDATA[导入numpy常用代码：import numpy as np或from numpy import *。建议使用第一种。使用第一种时要在numpy函数前加上np.xxx，如·np.array 矩阵的创建常用代码: 创建数组np.array([[1,2,3]])创建一个1*3的numpy数组 创建全1矩阵np.ones([a,b])创建一个a*b的矩阵，元素全为1 注意：np.ones和np.zeros的参数是一维向量，需要使用[]，而np.random.rand不需要使用[] 创建全0矩阵np.zeros([a,b])创建一个a*b的矩阵，元素全为0 创建对角矩阵np.diag([a,b,c])创建一个对角线元素为a,b,c的矩阵np.diag([[a,b,c],[d,e,f],[g,h,i]])创建一个1*3向量，元素为矩阵对角线元素 矩阵的运算 计算向量间的欧氏距离 a1 = np.array([[1,2],[2,3]]) a2 = np.array([[2,0],[2,1]]) dist = np.linalg.norm(a1 - a2) print(dist) 一维数组的转置np.transpose([a]) 矩阵的排序np.sort(a, axis=-1, kind=&#39;quicksort&#39;, order=None)返回排序好的矩阵，a为原矩阵，axis为排序方向，axis = 0为纵轴排序，axis = 1位横轴排序 垂直合并矩阵np.vstack((a,b))将a,b矩阵垂直合并 水平合并矩阵np.hstack((a,b))将a,b矩阵水平合并 按矩阵某行排序data = data[:,data[2].argsort()]按第3行从小到大排序 按矩阵某列排序data = data[data[:,2].argsort()]按第3列从小到大排序 矩阵的乘法np.dot(a,b) 多矩阵乘法np.linalg.multi_dot([a,b,c]) 矩阵的加法np.sum(a)np.sum(a,axis = 0) #每列相加np.sum(a,axis = 1) #每行相加axis代表相加后消失的维数 矩阵的删除np.delete(X,0,axis=0)删除矩阵第一行 行向量转列向量a.shape = (3,1) 矩阵的随机化np.random.shuffle(matrix)沿着第一维进行重新排列。如果是二维数据，那么就按行进行重新排列 去除nan值x = x[~np.isnan(x)]np.nanmean(np.array([1, 2, 3, np.nan]) 统计矩阵不重复的行或列unq, cnt = np.unique(a, return_counts=True, axis=0)return counts表示返回不重复行/列的数目，axis=0表示从行的方向统计。 矩阵的重叠在numpy中，矩阵的重叠有两种： np.tile()和np.repeat()。np.tile()是将整个矩阵进行重叠，np.repeat()是将矩阵中的每个元素进行重叠。 a = np.array([[1, 2, 3], [4, 5, 6]]) b = np.tile(a, (2, 1)) c = np.repeat(a, 2, axis=0) &gt;&gt;&gt; b array([[1, 2, 3], [2, 3, 4], [1, 2, 3], [2, 3, 4]]) &gt;&gt;&gt; c array([[1, 2, 3], [1, 2, 3], [2, 3, 4], [2, 3, 4]]) 使用元组索引数组可以使用元组对数组进行索引，即a[(2, 3)]。如果是其他类型的，可以使用tuple()进行转换。 矩阵元素操作 找出所有等于某个值的所有元素的下标a = np.random.randint(1, 10, 100) np.where(a == 2) np.argwhere(a == 2) 数据的产生 正态分布数据numpy.random.normal(loc, scale, size)loc：float 此概率分布的均值（对应着整个分布的中心centre）scale：float 此概率分布的标准差（对应于分布的宽度，scale越大越矮胖，scale越小，越瘦高）size：int or tuple of ints 输出的shape，默认为None，只输出一个值 随机分布数据numpy.random.rand(a,b)创建一个维数为a*b，数值在[0,1)的随机矩阵 标准正态分布数据中随机抽取numpy.random.randn(a,b)创建一个维数为a*b，数值取值为标准正态分布中随机取样本点 产生不重复随机数组random.sample(a,b)在a数组的范围内随机产生b个不重复的随机数]]></content>
      <categories>
        <category>Python Packages</category>
      </categories>
      <tags>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python常见问题和技巧]]></title>
    <url>%2F2019%2F10%2F18%2FPython%2FPython%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[模块修改后再次载入无变化import importlib importlib.reload(PackageName) %load_ext autoreload %autoreload 2 python数据类型setset是一种无序集合。常见的方法有： 创建集合a = set(&#39;python&#39;) 向集合中传入一个元素并拆分a.update(&#39;java&#39;) 删除集合中元素a.remove(&#39;p&#39;) 利用列表生成字典a = [1, 2, 3] b = [4, 5, 6] dict1 = dict(zip(a, b)) 初始化值类型的字典——defaultdict在python中可以使用collections中的defaultdict对字典中的值类型进行初始化。在初始化defaultdict时，可以加上int，list等参数，表示值的默认类型。 列表删除元素 a.remove(item) del(a[index]) a.pop() python 排序sorted([1, 2, 3, 5, 3])[1, 2, 3, 6, 5].sort() python中的队列from collections import deque queue = deque([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]) queue.append(&#39;e&#39;) queue.popleft()python数组按某列排序data[data[:,2].argsort()]数组按第三列排序 python 字典转变量globals().update(dict)例如： {foo: bar} -&gt; foo = bar Google注释规范def fetch_bigtable_rows(big_table, keys, other_silly_variable=None): &quot;&quot;&quot;Fetches rows from a Bigtable. Retrieves rows pertaining to the given keys from the Table instance represented by big_table. Silly things may happen if other_silly_variable is not None. Args: big_table: An open Bigtable Table instance. keys: A sequence of strings representing the key of each table row to fetch. other_silly_variable: Another optional variable, that has a much longer name than the other args, and which does nothing. Returns: A dict mapping keys to the corresponding table row data fetched. Each row is represented as a tuple of strings. For example: {&#39;Serak&#39;: (&#39;Rigel VII&#39;, &#39;Preparer&#39;), &#39;Zim&#39;: (&#39;Irk&#39;, &#39;Invader&#39;), &#39;Lrrr&#39;: (&#39;Omicron Persei 8&#39;, &#39;Emperor&#39;)} If a key from the keys argument is missing from the dictionary, then that row was not found in the table. Raises: IOError: An error occurred accessing the bigtable.Table object. &quot;&quot;&quot; pass 注意： 函数功能注释与参数说明之间应该空一行 map、reduce和filtermap用于将一个函数映射到后面给出的变量列表中，reduce用于将一个函数依次映射到后面的相邻变量中，filter用于筛选列表中符合某个函数条件的值 map(lambda x: x ** 2, range(1, 10)) from functools import reduce reduce(lambda x, y: x + y, range(1, 11)) filter(lambda x: x % 2, range(1, 11)) *号的使用 乘法符号 当*号用在函数定义时，作用是收集传入的参数，也就是把除a=b形式外的传入参数打包成一个元组，在函数中使用。**号作用相同，是把所有a=b形式的传入参数打包成字典，在函数中使用。 当*号用于函数调用时，作用是把以元组形式的参数集合展开并对应到各个参数位置上。 def print(*param): for item in param: print(item) # Example 1 def print_(a, b, c): print(a) print(b) print(c) a = [&#39;ap&#39;, &#39;ba&#39;, &#39;or&#39;] print(*a) # Example 2 def a(): return 1, 2, 3 print(&#39;{} {} {}&#39;.format(*a())) # Example 3 a = [1, 2, 3] b = [*a] print(b) Python数组拷贝在进行Python的数组拷贝时，有时会用到切片操作。下面是一个例子： dec_seq = torch.rand(3, 4, 5) dec_input = dec_seq[:, :-1] dec_output = dec_seq[:, 1:] 实际上dec_input和dec_output只是对dec_seq的一个引用，并不是对对象的一个完整复制。当dec_seq的值改变时，dec_input和dec_output的值也会随之改变。因此，dec_input和dec_output更像是指向dec_seq一部分的指针。如果想对原数组进行完整的拷贝，应该使用copy模块中的copy和deepcopy。 copy.copy 浅拷贝 只拷贝父对象，不会拷贝对象的内部的子对象。 copy.deepcopy 深拷贝 拷贝对象及其子对象例子：&gt;&gt;&gt; import copy &gt;&gt;&gt; a = [1,2,3,4,[&#39;a&#39;,&#39;b&#39;]] #原始对象 b = a #赋值，传对象的引用 c = copy.copy(a) d = copy.deepcopy(a) a.append(5)a[4].append(‘c’) print ‘a=’,aa= [1, 2, 3, 4, [‘a’, ‘b’, ‘c’], 5]print ‘b=’,bb= [1, 2, 3, 4, [‘a’, ‘b’, ‘c’], 5]print ‘c=’,cc= [1, 2, 3, 4, [‘a’, ‘b’, ‘c’]]print ‘d=’,dd= [1, 2, 3, 4, [‘a’, ‘b’]] Python的异常处理机制python有两种机制可以触发异常： try-except-else-finally程序尝试执行try下的语句，如果触发异常就跳到相应的except语句，如果没有错误就跳到else语句。finally语句是无论是否发生错误都会执行。 try: &lt;语句&gt; #尝试执行 except &lt;异常类型1&gt;： &lt;语句&gt; #如果在try部份引发了&#39;name&#39;异常 except &lt;异常类型2&gt;，&lt;数据&gt;: &lt;语句&gt; #如果引发了&#39;name&#39;异常，获得附加的数据 else: &lt;语句&gt; #正常执行 finally: &lt;语句&gt; #无论是否触发异常都执行的语句 if-raise程序尝试判断if语句下是否成立，如果成立，抛出raise下的error。 if expression: raise Exception 自定义Error类型需要自定义异常类型时，需要继承Exception类 class SomeCustomException(Exception): pass warnings模块warnings.warn()函数用于生成警告信息。格式为： if expression: warnings.warn(&#39;Warning message&#39;, WarningType) 其中WarningType可以是Python模块中的warning，具体目录 Python filter()函数filter(function, iterable) filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。 该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。 使用方法： filter1 = filter(lambda x: x &gt; 0, [-1, 0, 1, 5]) filter1.next() 对于None的判断在 if判断中，None，False，空字符串，0，空列表，空字典，空元组都会被判断成False。因此在使用if not x判断是否为None时，需要排除其余可能的影响。因此，建议的判断方式为：if x is not None 字符串join()方法Python join()方法用于将序列中的元素以指定的字符连接生成一个新的字符串。str.join(sequence)即用str来连接sequencea = &#39;&#39;.join(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;) 响应键盘终止except KeyboardInterrupt: print(&#39;Interrupt&#39;) 字符串不转义在使用正则表达式时，通常不希望表示转义字符，方法是在字符串前加上r，如r&#39;[]\&#39;。 heapq模块及其应用Python中的heapq模块提供了基于堆的优先排序算法。堆可以看成完全二叉树，父节点的值永远比子节点小。常用的方法有 heappush把元素放入堆 heappop返回堆中最小的元素 heappushpop把元素放入堆的同时返回最小的元素 heapify在线性时间内把一个列表转化为堆。注意，这个操作是把原列表直接转化为堆而不是创建一个新的堆 nlargest返回堆中最大的k个元素 nsmallest返回堆中最小的k个元素。nlargest和nsmallest通常用于在一个含有较多元素的列表中找出少数最值，max()和min通常用于找出最大/最小值，如果需要找的最值较多，推荐把列表进行排序后使用切片查找。 merge用于将多个iterable对象进行归并排序。返回一个generator用于生成排序结果。import heapq list1 = [1, 5, 9, 2, 4] dict1 = [{&#39;a&#39;: 2}, {&#39;a&#39;: 3}, {&#39;a&#39;: 8}] heapq.nlargest(2, list1) heapq.nsmallest(4, list1) heapq.nlargest(2, dict1, key=lambda x: x[&#39;a&#39;]) 统计列表中各元素出现的次数from Collections import Counter a = [1, 2, 3, 2, 4, 2] counter = Counter(a) count_list = dict(counter) print(counter.most_common(3)) isinstance()方法Python中isinstance(object, classinfo)方法用于判断一个对象是否是一个已知的类型，与type()类似。它们的区别在于 type() 不会认为子类是一种父类类型，不考虑继承关系。 isinstance() 会认为子类是一种父类类型，考虑继承关系。 如果要判断两个类型是否相同推荐使用 isinstance()。 对于classinfo的选择，可以是int，float，bool，complex，str，list，dict，set，tuple。 global 和 nonlocalglobal用于声明全局变量。如果在函数内部修改函数外的变量，需要在函数中声明全局变量。 foo = 0 def bar(): global foo foo += 1 nonlocal用于声明在内层函数中使用的变量。 def foo1(): bar = 0 def foo2(): nonlocal bar bar += 1 return bar return foo2() 测试程序运行时间可以使用time或timeit模块测试程序的运行时间 def foo(param): pass import time start = time.time() foo() end = time.time() print(end - start) from timeit import timeit print(timeit(&#39;foo(x)&#39;, setup=&#39;from __main__ import foo&#39;, globals={&#39;x&#39;: param}), number=1) 逻辑运算符运算顺序python中逻辑运算符包括not，and和or，其运算顺序为not&gt;and&gt;or。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pytorch知识点学习]]></title>
    <url>%2F2019%2F10%2F18%2FPytorch%2FPytorch%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[1 torch.nn和torch.nn.functional中神经网络层的区别torch.nn中的层是类，torch.nn.functional中的层是函数。torch.nn中的forward()方法是调用torch.nn.functional实现。因此两者从原理上等价。torch.nn一般用于较复杂层的实现，torch.nn.functional一般用于简单层的实现 2 Pytorch的层建立方式 nn.Sequential().add_module(layer) net1 = nn.Sequential() net1.add_module(&#39;conv&#39;, nn.Conv2d(3, 3, 3)) net1.add_module(&#39;batchnorm&#39;, nn.BatchNorm2d(3)) net1.add_module(&#39;activation_layer&#39;, nn.ReLU()) nn.Sequential(layer) net2 = nn.Sequential( nn.Conv2d(3, 3, 3), nn.BatchNorm2d(3), nn.ReLU() ) nn.Sequential(OrderedDict([(multi layername, layer)])) from collections import OrderedDict net3 = nn.Sequential(OrderedDict([ (&#39;conv&#39;, nn.Conv2d(3, 3, 3)), (&#39;batchnorm&#39;, nn.BatchNorm2d(3)), (&#39;activation_layer&#39;, nn.ReLU()) ])) 4. nn.ModuleList([layers]) ```python model1 = nn.ModuleList( nn.Linear(10, 1) for _ in range(3) )3 Pytorch自定义层的编写下面是一个典型的Pytorch自定义层的实现方法 class ScaledDotProductAttention(nn.Module): &quot;&quot;&quot; Scaled Dot-Product Attention &quot;&quot;&quot; def __init__(self, temperature, attn_dropout=0.1): &quot;&quot;&quot; :param temperature: scale parameter in the equation out = Q * K.T / temperature * V. Default is \sqrt d_k :param attn_dropout: dropout rate in the self-attention layer &quot;&quot;&quot; super(ScaledDotProductAttention, self).__init__() self.temperature = temperature self.dropout = nn.Dropout(attn_dropout) self.softmax = nn.Softmax(dim=2) def forward(self, q, k, v, mask=None): &quot;&quot;&quot; Calculate self-attention output :param q: size: (batch_size, max_seq_len or input_len, d_k) :param k: same as q :param v: size: (batch_size, max_seq_len or input_len, d_k) :param mask: :return: &quot;&quot;&quot; attn = torch.bmm(q, k.transpose(1, 2)) attn = attn / self.temperature if mask is not None: attn = attn.masked_fill(mask, -np.inf) attn = self.softmax(attn) attn = self.dropout(attn) output = torch.bmm(attn, v) return output, attn 在self.__init__()函数中，完成对层中要使用的Tensor和调用的层的产生和初始化。初始化可以直接写在__init__()方法中，也可以单独创建一个self.reset_parameters()方法，在__init__()方法中调用。初始化可以自定义，也可以使用torch.nn.init中提供的初始化方法。在该方法中调用的层只是对层的声明，并不是调用。 在self.forward()方法中，完成对调用该层时完成的功能的编写。层的输出写在return行。 4 Pytorch中常见的层 LayerNormLayerNorm层是对数据的最后一维进行归一化。多用在深层RNN中。 Conv1d Conv1d class torch.nn.Conv1d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True) in_channels是输入数据第二维，out_channels是输出数据第二维，kernel_size是卷积占的列数。输入：shape为(a, b, c)的Tensor。Conv1d在最后一维做卷积，卷积核的维数是(in_channels, out_channels, kernel_size)。输出的第二维是out_channels，说明用out_channels个不同的卷积做运算，输出第三维是c - kernel_size + 1,表示共卷积的次数。 # 一个Conv1d的例子 m = nn.Conv1d(16, 33, 3, stride=2) input = torch.randn(20, 16, 50) output = m(input) print(output.shape) print(m.weight.shape) 输出为torch.Size([20, 33, 48])和torch.Size([33, 16, 3])。原理为：Conv1d只在最后一维做卷积。第二维由in_channels变为out_channels，说明共有out_channels组卷积核，1组in_channels个，卷积核宽度为3，每个卷积核分别与输入数据第二维中的一行做卷积。 Conv2d CLASS torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True) # 一个Conv2d的例子： m = nn.Conv2d(16, 33, (3, 4)) input = torch.randn(20, 16, 50, 100) output = m(input) print(output.size) print(m.weight.size) 输出为torch.Size([16, 33, 48, 97])和torch.Size([33, 16, 3, 4])。原理为：Conv2d的in_channels和out_channels与Conv1d保持一致，不同的是kernel_size可以是两维的，也就是同时对input的最后两维进行卷积。其他部分与Conv1d相同。因此由Conv1d不难推出Conv2d的维数变换规律。 5 Pytorch中的数据处理reference:Pytorch数据读取(Dataset, DataLoader, DataLoaderIter) 5.1 torch.utils.data.Datasetreference: Pytorch cn docDataset是一个抽象类，用于将数据封装成Dataset类。它是一个抽象类。在具体使用时需要继承Dataset类并实现其中的2个方法： __getitem__(self, index) 用于决定每次如何取数据。比如对于形如(batch_size, input_length)的数据，每次读取第index行数据 __len__() 用于获取数据的长度 class DealDataset(Dataset): &quot;&quot;&quot; 下载数据、初始5. Pytorch中的数据处理数据，都可以在这里完成 &quot;&quot;&quot; def __init__(self): xy = np.loadtxt(&#39;../dataSet/diabetes.csv.gz&#39;, delimiter=&#39;,&#39;, dtype=np.float32) # 使用numpy读取数据 self.x_data = torch.from_numpy(xy[:, 0:-1]) self.y_data = torch.from_numpy(xy[:, [-1]]) self.len = xy.shape[0] def __getitem__(self, index): return self.x_data[index], self.y_data[index] def __len__(self): return self.len 5.2 torch.utils.data.DataLoaderreference:Pytorch cn doc 用于定义从Dataset中读取数据的方式，包括batch_size, shuffle等 class torch.utils.data.DataLoader(dataset, batch_size=1, shuffle=False, sampler=None, batch_sampler=None, num_workers=0, collate_fn=&lt;function default_collate at 0x4316c08&gt;, pin_memory=False, drop_last=False) 主要参数： dataset: dataset对象 batch_size: 每个 batch 加载多少个样本 (默认值: 1) shuffle: 设置为 True 时, 会在每个 epoch 重新打乱数据 (默认值: False). train_loader = DataLoader(dataset=dealDataset, batch_size=32, shuffle=True) 5.3 训练过程for epoch in epochs: for i, batch in enumerate(train_loader): print(&#39;the {}th batch: {}&#39;.format(i, batch)) 注意:如果在dataloader中定义了多个返回值，那么在训练过程中每个batch都是一个list，使用batch[i]或者(train, test)来调用每个batch中的参数 6 Pytorch中的数据类型及相互转换Pytorch中dtype是tensor的一个属性，使用tensor.dtype获取一个张量的数据类型。主要包括以下几类： Data type dtype Tensor types 32-bit floating point torch.float32 or torch.float torch.*.FloatTensor 64-bit floating point torch.float64 or torch.double torch.*.DoubleTensor 16-bit floating point torch.float16 or torch.half torch.*.HalfTensor 8-bit integer (unsigned) torch.uint8 torch.*.ByteTensor 8-bit integer (signed) torch.int8 torch.*.CharTensor 16-bit integer (signed) torch.int16 or torch.short torch.*.ShortTensor 32-bit integer (signed) torch.int32 or torch.int torch.*.IntTensor 64-bit integer (signed) torch.int64 or torch.long torch.*.LongTensor 数据类型的查看：数据类型之间的转换使用Tensor.long()或dtype=torch.long实现。转换函数有：long(), int(), double(), float(), byte() 注意： Pytorch中的一些层对输入的tensor类型有要求。如Embedding层要求输入的tensor为torch.long类型。 如果Pytorch的数据来源是numpy，要十分注意numpy和pytorch的数据类型匹配。在numpy中，默认数据类型是float，但float与np.float64等价；在pytorch中，整数默认数据类型是torch.long，小数默认数据类型是torch.float，但float与torch.float32等价。也就是说，如果不加转换地使用torch.from_numpy，numpy中的数组将会被转换成pytorch中的torch.double类型。数据类型的不匹配将造成网络无法正确搭建。解决方法：在numpy端将数据转换为np.float32类型，即.astype(np.float32)a = np.sin([i for i in range(10)]).astype(np.float) print(a.dtype) 7 Pytorch中的数据运算位置及相互转换Pytorch中device是tensor的一个属性，使用tensor.device获取一个张量的运算位置。 从cpu转换到gpu：tensor.to(&#39;cuda&#39;)或tensor.cuda() 从gpu转换到cpu：tensor.to(&#39;cpu&#39;)或tensor.cpu() 此外，还要注意tensor和numpy数组之间的转换只能在cpu上完成。即要先使用tensor.to(&#39;cpu&#39;)后才能使用tensor.numpy() 8 Pytorch展示模型结构 展示模型所有层：print(modelname) 展示模型所有参数：print(list(model.named_parameters())) 9 Pytorch学习率调整使用的类：torch.optim.lr_scheduler。这个类的optimizer为常用的优化方法。如果使用scheduler，则在训练过程中只需写scheduler.step()而不需写optimizer.step()。 常用的学习率调整方法： torch.optim.lr_scheduler.StepLR(optimizer, step_size, gamma=0.1, last_epoch=-1) 每过step_size将learning_rate调整为gamma * learning_rate. torch.optim.lr_scheduler.MultiStepLR(optimizer, milestones, gamma=0.1, last_epoch=-1) 每到milestones中包含的训练次数时把learning_rate调整为gamma * learning_rate. milestones:包含迭代次数的列表，必须递增。 torch.optim.lr_scheduler.ReduceLROnPlateau(optimizer, mode=&#39;min&#39;, factor=0.1, patience=10, verbose=False, threshold=0.0001, threshold_mode=&#39;rel&#39;, cooldown=0, min_lr=0, eps=1e-08) 学习率递减函数。当模型性能不再提升时将学习率减少。 mode: ‘min’或’max’。在’min’模式下，衡量标准不再下降时学习率减小。 factor: 学习率更新系数 patience: 学习率更新前指标不再下降/上升的迭代次数 verbose: 每次更新学习率时是否打印信息 10 Pytorch设置随机数种子torch.manual_seed(args.seed) torch.cuda.manual_seed(args.seed)]]></content>
      <categories>
        <category>Pytorch</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习]]></title>
    <url>%2F2019%2F10%2F17%2FGit%2FGit%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[背景介绍Git是由Linux之父使用C语言开发的一个分布式版本控制系统。分布式版本控制系统的特点是没有中央服务器，每一个人的电脑上都有一个完整的版本库。 Git安装与全局配置在Windows系统下可以从官网下载Git安装包。在Mac系统下已经自带Git，如果需要安装更新版本，可以使用homebrew。 在安装完成后，可以进行全局用户名和电子邮件设置 git config --global user.name &#39;name&#39; git config --global user.email &#39;123@example.com&#39; 如果忘记已经设置的用户名和电子邮件，可以使用以下命令查看 git config --global user.name git config --global user.email 如果文件夹名称中有中文，会出现乱码情况。可以使用git config --global core.quotepath false 在Mac下git默认语言为中文，如果想改为中文，可以在~/.zshrc中加入export LC_ALL=en_US.UTF-8 创建一个仓库git init 把文件添加到仓库git add filename 对本次操作进行说明git commit -m &#39;add a file&#39; 对上次的提交信息进行修改和更新git commit --amend -m 查看仓库当前状态git status 查看具体文件修改的内容git diff filename 查看版本历史记录 完整显示git log 单行显示git log --pretty=oneline 版本回退 回退一个版本git reset --hard HEAD^ 回退n个版本git reset --hard HEAD~n 根据版本号回退版本(不需写完整版本号)git reset --hard 1234a 误操作时查看命令历史和版本号git reflog 工作区和暂存区在Git中，平时工作的文件夹称为工作区，.git目录中存放的称为版本库。在版本库中存在一个暂存区。git add可以把文件放入暂存区。git commit可以把暂存区的改动提交到新的分支。如果对文件进行了多次修改，只有经过了git add的改动才会被暂存区记录，否则不会被记录。 丢弃某个文件的修改(还原文件) 这个修改没有经过git add加入暂存区 git checkout -- file 这个修改已经经过git add加入暂存区git rm --cached [filename] 撤销提交 新增一次提交以抵消上一次提交的变化，不会改变过去的所有历史git revert head 新增多次提交以抵消某几次提交的变化git revert [倒数第一次] [倒数第二次] 丢弃提交丢弃提交的含义是使某次提交之后的所有提交在历史中彻底删除，仍可以使用git reflog查看记录 git reset [某次提交] 还可以加上--hard参数，表示让工作区的文件也回到过去的状态 删除文件 删除没有经过git add的文件 rm file 删除已经经过git add的文件 rm file git rm file 本地仓库与远程仓库的结合 把一个本地仓库与远程仓库关联 git remote add origin git@github.com:xxx.git 其中origin表示远程仓库名。 把本地仓库的内容推送到远程仓库 git push -u origin master 把远程仓库的内容拷贝到本地仓库git clone git@github.com:xxx.git git分支 创建一个分支并切换到该分支 git checkout -b dev git switch -c dev 创建一个分支 git branch dev 删除一个分支 git branch -d dev 切换到dev分支 git checkout dev git switch dev 查看所有分支 git branch 把a分支合并到b分支 git checkout b git merge a 非快速合并模式git merge --no-ff -m &#39;merge with no-diff&#39; dev 保存和恢复当前没提交的工作 保存暂存区的工作git stash 恢复暂存区的工作并删除临时存储内容git stash pop 把特定修改复制到当前分支git cherry-pick 1234ab 查看远程地址 简略查看git remote 详细查看git remote -v 给特定的提交打标签 给当前HEAD打标签 git tag tagname 给某个特定分支打标签git tag tagname commit-id 给标签加上说明文字git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb .gitignore.gitignore主要用于忽略一些文件，不加入版本库。 当现有文件已经被git跟踪时，再使用.gitignore并没有用。此时需要使用git rm -r --cached .删除本地缓存，再使用.gitignore进行跟踪。 Referencehttps://www.liaoxuefeng.com/wiki/896043488029600]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[json]]></title>
    <url>%2F2019%2F10%2F02%2FPythonPackages%2Fjson%2F</url>
    <content type="text"><![CDATA[python中的json模块用于python对象与json对象的转换及json文件的读写。 json.dump这个函数主要用于把对象转成str类型并写入json文件。 import json dict1 = {&#39;a&#39;: 1} with open(&#39;a.json&#39;, &#39;w&#39;) as f: json.dump(dict1, f) json.load这个函数主要用于从json文件中读取数据并转成python中对应的对象。 import json with open(&quot;a.json&quot;, &quot;r&quot;) as f: dict1 = json.load(f) print(dict1) json.dumps这个函数主要用于把python中的对象转成json格式的str，因为如果直接将dict类型的数据写入json文件中会发生报错，因此在将数据写入时需要用到该函数。可以传入indent=2参数，结构更清晰。如果对象中有中文，可以传入ensure_ascii=False参数确保显示正确。 import json dict1 = {&quot;name&quot;: &quot;tom&quot;} str1 = json.dumps(dict1) print(type(str1)) with open(&#39;a.json&#39;, &#39;w&#39;) as f: f.write(str1) json.loads这个函数主要用于把json形式的str转化为python对象。 with open(&#39;a.json&#39;, &#39;r&#39;) as f: str1 = f.read() dict1 = json.loads(str1)]]></content>
      <categories>
        <category>Python Packages</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python中的正则表达式——re模块]]></title>
    <url>%2F2019%2F09%2F30%2FPythonPackages%2Fre%2F</url>
    <content type="text"><![CDATA[参考教程：https://www.runoob.com/python/python-reg-expressions.html 一些有用的技巧： (?P&lt;tag\d&gt;)。这种表示方式可以为搜索结果分组。在获取结果时可以使用result.group(&#39;tag&#39;)。通常用于re.search()和`re.match( re.S表示把.认为是(.|\n)，也就是.包含换行符。re.I表示忽略大小写。 re.findall()返回一个列表，列表中每个元素表示一个匹配。]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[$\LaTeX$一些坑]]></title>
    <url>%2F2019%2F07%2F09%2FLaTeX%2FLatex%E4%B8%80%E4%BA%9B%E5%9D%91%2F</url>
    <content type="text"><![CDATA[\indent后要跟空格 \gather不要留空行 \gather内嵌\aligned不能加* 在使用\mathbb前需要导入包\usepackage{amsfonts} 插入小、中、大括号的语句分别为：\left\{ ... \right\} \left[ ... \right] \left( ... \right) 图片、算法的插入一般使用!htb控制位置。如果强制指定图片位置，可使用H 在编译$\LaTeX$前一定要先关闭用acrobat打开的pdf文档！ 插入图片时图片名称不要带空格和点.！否则可能报Cannot determine size of graphic in fig.png (no BoundingBox). 一个gather环境中加入多个align环境且需要纵向对齐时在每一个align后加上\\]]></content>
      <categories>
        <category>Latex</category>
      </categories>
      <tags>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Latex安装]]></title>
    <url>%2F2019%2F07%2F09%2FLaTeX%2FLatex%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[texlive离线安装 texstudio在线安装]]></content>
      <categories>
        <category>Latex</category>
      </categories>
      <tags>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[latex导言区常用设置]]></title>
    <url>%2F2019%2F07%2F09%2FLaTeX%2FLatex%E5%AF%BC%E8%A8%80%E5%8C%BA%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[% Article setting % Article type \documentclass[12]{article} % Page margin \usepackage{geometry} %\geometry{a4paper,scale=0.8} \geometry{a4paper,left=2cm,right=2cm%,top=2cm,%bottom=2cm, includefoot,heightrounded } % set title \title{} \author{} \date{} % import package \usepackage{amsmath, amsfonts, bm} % \numberwithin{equation}{section} % Equation numbering by section \numberwithin{equation}{subsection} % Equation numbering by subsection % \numberwithin{equation}{subsubsection} % Chinese support \usepackage{xeCJK} \usepackage{fontspec} \setCJKmainfont[AutoFakeBold]{SimSun} \setCJKmonofont{SimSun} \setmainfont{Times New Roman} \renewcommand\contentsname{目录} \renewcommand\refname{参考文献} \renewcommand{\figurename}{图} \renewcommand{\tablename}{表} % Indent \usepackage{indentfirst} \setlength{\parindent}{2em} % Python code \usepackage{listings} \usepackage{color} \definecolor{dkgreen}{rgb}{0,0.6,0} \definecolor{gray}{rgb}{0.5,0.5,0.5} \definecolor{mauve}{rgb}{0.58,0,0.82} \lstset{frame=tb, language=Python, aboveskip=3mm, belowskip=3mm, showstringspaces=false, columns=flexible, basicstyle={\small\ttfamily}, numbers=none, numberstyle=\tiny\color{gray}, keywordstyle=\color{blue}, commentstyle=\color{dkgreen}, stringstyle=\color{mauve}, breaklines=true, breakatwhitespace=true, tabsize=3 } % Import image \usepackage{graphicx} \usepackage{subcaption} % Delete : of image caption \usepackage{caption} \DeclareCaptionLabelSeparator{twospace}{\ ~} \captionsetup{labelsep=twospace} %Adjust line space \usepackage{setspace} \renewcommand{\baselinestretch}{1.4} % \setlength{\baselineskip}{20pt} % Adjust table height \usepackage{array} \renewcommand\arraystretch{1.5} % Insert algorithm \usepackage{algorithm, algorithmic} % Reference \usepackage{cite} \usepackage{natbib} \usepackage{hyperref} \hypersetup{ colorlinks=true, linkcolor=black, filecolor=blue, urlcolor=blue, citecolor=blue, } % Delete : of image caption \usepackage{caption} \DeclareCaptionLabelSeparator{twospace}{\ ~} \captionsetup{labelsep=twospace} %Adjust line space \usepackage{setspace} \renewcommand{\baselinestretch}{1.4} % \setlength{\baselineskip}{20pt} % Adjust table height \usepackage{array} \renewcommand\arraystretch{1.5} % Insert algorithm \usepackage{algorithm, algorithmic} % Reference \usepackage{cite} \usepackage{natbib} \usepackage{hyperref} \hypersetup{ colorlinks=true, linkcolor=black, filecolor=blue, urlcolor=blue, citecolor=blue, } ``` citecolor=blue, }]]></content>
      <categories>
        <category>Latex</category>
      </categories>
      <tags>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[$\LaTeX$常用代码段]]></title>
    <url>%2F2019%2F07%2F09%2FLaTeX%2FLatex%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[1 公式一些小技巧： 公式环境加*号会参与自动编号 公式环境可以嵌套。内层嵌套不能使用*号，且要&gt;加上ed。 最好不要留多余空行，否则可能报错。 行内公式$\a+b=c$ 单行行间公式 \begin{equation} X(i, j) = \begin{cases} 0, \quad X(i, j)\text{缺失}\\ 1, \quad \text{其它} \end{cases} \end{equation} 多行推导公式 \begin{align*} f(x) &amp;= (x+a)(x+b) \\ &amp;= x^2 + (a+b)x + ab \end{align*} 多行对齐公式 \begin{gather*} E(Y_t) = \mu \\ E\left(Y_{t}-\mu\right)^{2}=E\left(\epsilon_{t}+\theta \epsilon_{t-1}\right)^{2}=\left(1+\theta^{2}\right) \sigma^{2} \\ E\left(Y_{t}-\mu\right)\left(Y_{t-1}-\mu\right)=\theta \sigma^{2} \\ \end{gather*} 多行条件公式 \begin{equation}\begin{cases} 123&amp;a=5\ 433434&amp;a=64554\\end{cases}\end{equation} 6. gather内嵌套align ```latex gather*内嵌套aligned： \begin{gather*} c=53223 \begin{aligned} a&amp;=1\\ &amp;=332 \end{aligned} \end{gather*} 分段函数```latexsmooth_{L_{1}}(x)=\begin{cases} 5x^{2}, &amp;\left |x \right |\leq 1 \cr \left |x \right|-0.5, &amp; otherwise\end{cases} ## 2 图 1. 一行一图 ```latex \begin{figure} %图 \centering %插入的图片居中表示 \includegraphics[width=\textwidth]{./figures/estimate.jpg} \renewcommand{\figurename}{Fig.}\renewcommand{\figurename}{图} \caption{不同数据缺失率下的数据补全结果} %图片的名称 \label{fig1} %标签，用作引用 \end{figure} 一行多图 \usepackage{subcaption} \begin{figure}[H] \begin{subfigure}{0.5\textwidth} \includegraphics[width=\textwidth]{./figures/ar_1_acf.png} \label{fig:3_classes} \caption{} \end{subfigure} \begin{subfigure}{0.5\textwidth} \includegraphics[width=\textwidth]{./figures/ar_1_pacf.png} \label{fig:5_classes} \caption{} \end{subfigure} \caption{ACF和PACF} \end{figure} 3 列表% 有序列表 \begin{enumerate}[(1)] % \begin{enumerate}[{[1]}] % \begin{enumerate}[(i)] \item 有编号的列表 \item ... \end{enumerate} % 无序列表 \begin{itemize} \item 无编号的列表 \item ... \end{itemize} 4 表格 简单表格 \begin{table}[H] \centering \caption{预测误差分布} \begin{tabular}{|c|c|c|c|c|} % 竖线表示是否在该列加竖线 \hline &amp; 均值 &amp; 均值理论值 &amp;方差&amp;方差理论值\\ \hline 1步 &amp; 0.0103 &amp; 0 &amp; 0.9927 &amp; 1 \\ 2步 &amp; 0.0141 &amp; 0 &amp; 1.2549 &amp; 1.25 \\ \hline \end{tabular} \end{table} 三行线表格 \begin{table}[htp] \centering \caption{MA($\infty$)和GRU的最大可预测步数比较} \label{Tab03} % shorten cline length \begin{tabular}{@{\extracolsep{12pt}}cccccccccc@{}} \hline \multirow{2}{*}{参数} &amp; \multicolumn{3}{c}{AR(1)} &amp; \multicolumn{3}{c}{AR(2)} &amp; \multicolumn{3}{c}{MA(2)} \\ \cline{2-4} \cline{5-7} \cline{8-10} &amp; 0.1 &amp; 0.5 &amp; 0.9 &amp; -0.1 &amp; -0.5 &amp; -0.7 &amp; -0.1 &amp; -0.2 &amp; -0.3 \\ \hline MA($\infty$)&amp; 1 &amp; 3&amp; 19 &amp; 3 &amp; 6 &amp; 11 &amp; 2 &amp; 2 &amp; 2\\ GRU&amp; 1 &amp; 3 &amp; 20 &amp; 3 &amp; 5 &amp; 11 &amp; 2 &amp; 2 &amp; 2\\ \hline \end{tabular} \end{table} 去掉表格标题 % Delete : of image caption \usepackage{caption} \DeclareCaptionLabelSeparator{twospace}{\ ~} \captionsetup{labelsep=twospace} 多行表格 \begin{table}[htp] \centering \caption{不同条件下一些中间结果的动态范围} \label{cha_nonlinear} \begin{tabular}{@{\extracolsep{12pt}}cccccc@{}} \hline \multirow{2}{*}{序列编号} &amp; \multirow{2}{*}{条件} &amp; \multicolumn{4}{c}{动态范围}\\ \cline{3-6}&amp; &amp; $\mathbf{A}_{enc}$ &amp; $X_{attn}$ &amp; $\mathbf{A}_{enc\_dec}$ &amp; $\hat{\mathbf{x}}_{pre}$\\ \hline \multirow{4}{*}{1} &amp; 无线性投影，无位置编码 &amp; 1 &amp; 2 &amp; 3 &amp; 4\\ &amp; 有线性投影，无位置编码 &amp; 1 &amp; 2 &amp; 3 &amp; 4\\ &amp; 无线性投影，有位置编码 &amp; 1 &amp; 2 &amp; 3 &amp; 4 \\ &amp; 有线性投影，有位置编码 &amp; 1 &amp; 2 &amp; 3 &amp; 4\\ \hline \end{tabular} \end{table} 5 调整页边距\usepackage{geometry} \geometry{a4paper,scale=0.8} \geometry{a4paper,left=2cm,right=2cm,top=1cm,bottom=1cm} 6 参考文献 一般参考文献\usepackage{cite} \usepackage{natbib} \usepackage{hyperref} % Place to the location of reference\bibliographystyle{plain}\bibliography{reference} % Refer in the text\cite{Wille1982}% \citep{Wille1982} 2. URL参考文献（无超链接） ```latex \usepackage{url} @Misc{timmurphy.org, howpublished = {\url{http://timmurphy.org/2009/07/22/line-spacing-in-latex-documents/}}, note = {Accessed April 4, 2010}, title = {Line Spacing in LaTeX documents}, author = {Murphy, Timothy I} } 超链接参考文献（可点击）\usepackage{hyperref} % 设置各种颜色 \hypersetup{ colorlinks=true, % 使用颜色代替框 linkcolor=black, % 目录之类的颜色 filecolor=blue, urlcolor=blue, % 引用url颜色 citecolor=blue, % 引用的颜色 } @unpublished{Survey2014, title={Survey on the access to finance of enterprises}, author={Sophie Doove and Petra Gibcus and Ton Kwaak and Lia Smit and Tommy Span}, year=2014, note ={Accessed 16 June 2017. \href{http://wwwe.ansa.it/documents/1415814222451\_Rapporto.pdf/}{http://wwwe.ansa.it/documents/1415814222451/_Rapporto.pdf/}}, } 7 页码\thispagestyle{empty} % 在不需要设置页码的下面加 \setcounter{page}{1} % 强制设置页码值 8 python代码\usepackage{listings} \usepackage{color} \definecolor{dkgreen}{rgb}{0,0.6,0} \definecolor{gray}{rgb}{0.5,0.5,0.5} \definecolor{mauve}{rgb}{0.58,0,0.82} \lstset{frame=tb, language=Python, aboveskip=3mm, belowskip=3mm, showstringspaces=false, columns=flexible, basicstyle={\small\ttfamily}, numbers=none, numberstyle=\tiny\color{gray}, keywordstyle=\color{blue}, commentstyle=\color{dkgreen}, stringstyle=\color{mauve}, breaklines=true, breakatwhitespace=true, tabsize=3 } \begin{lstlisting} print (&#39;Starting Iterations&#39;) for iter in range(n_iterations): for i in range(n): Users[i] = np.dot(np.dot(np.dot(np.linalg.inv(np.dot(np.dot(Items,np.diag(R[i])),Items.T) + lambda_ * np.eye(n_factors)),Items),np.diag(R[i])),A[i]).T for j in range(m): Items[:,j] = np.dot(np.dot(np.dot(np.linalg.inv(np.dot(np.dot(Users.T,np.diag(R[:,j])), Users) + lambda_ *np.eye(n_factors)),Users.T),np.diag(R[:,j])),A[:,j]) #print (&#39;Error after solving for Item Matrix:%f&#39; % get_error(A, Users, Items, R)) NMAE_List.append(get_error(A, Users, Items, R)) print (&#39;%sth iteration is complete...&#39; % iter) print(&#39;Iteration finish&#39;) \end{lstlisting} ```) \end{lstlisting}]]></content>
      <categories>
        <category>Latex</category>
      </categories>
      <tags>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux系统使用过程中遇到的一些问题]]></title>
    <url>%2F2019%2F07%2F09%2FLinux%2FLinux%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1 无法进入GUI界面，可以使用Ctrl+Alt+F4进入命令行界面这种情况可能是Nvidia显卡驱动安装出现了问题。解决方法： 卸载原驱动：sudo apt-get purge nvidia* 把显卡驱动加入PPA：sudo add-apt-repository ppa:graphics-drivers sudo apt-get update 查找显卡驱动最新的版本号sudo apt-cache search nvidia 采用apt-get命令在终端安装sudo apt-get install nvidia-390 nvidia-settings nvidia-prime 使用lsmod | grep nvidia或watch -n 1 nvidia-smi查看是否安装成功-smi`查看是否安装成功]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈深度学习中的 Batch_Size]]></title>
    <url>%2F2019%2F07%2F09%2FDeepLearning%2F%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84batch%20size%2F</url>
    <content type="text"><![CDATA[本文转载自:谈谈深度学习中的 Batch_Size Batch_Size（批尺寸）是机器学习中一个重要参数，涉及诸多矛盾，下面逐一展开。 首先，为什么需要有 Batch_Size 这个参数？Batch 的选择，首先决定的是下降的方向。如果数据集比较小，完全可以采用全数据集 （ Full Batch Learning ）的形式，这样做至少有 2 个好处：其一，由全数据集确定的方向能够更好地代表样本总体，从而更准确地朝向极值所在的方向。其二，由于不同权重的梯度值差别巨大，因此选取一个全局的学习率很困难。 Full Batch Learning 可以使用 Rprop 只基于梯度符号并且针对性单独更新各权值。 对于更大的数据集，以上 2 个好处又变成了 2 个坏处：其一，随着数据集的海量增长和内存限制，一次性载入所有的数据进来变得越来越不可行。其二，以 Rprop 的方式迭代，会由于各个 Batch 之间的采样差异性，各次梯度修正值相互抵消，无法修正。这才有了后来 RMSProp 的妥协方案。 既然 Full Batch Learning 并不适用大数据集，那么走向另一个极端怎么样？所谓另一个极端，就是每次只训练一个样本，即 Batch_Size = 1。这就是在线学习（Online Learning）。线性神经元在均方误差代价函数的错误面是一个抛物面，横截面是椭圆。对于多层神经元、非线性网络，在局部依然近似是抛物面。使用在线学习，每次修正方向以各自样本的梯度方向修正，横冲直撞各自为政，难以达到收敛。如图所示： 可不可以选择一个适中的 Batch_Size 值呢？当然可以，这就是批梯度下降法（Mini-batches Learning）。因为如果数据集足够充分，那么用一半（甚至少得多）的数据训练算出来的梯度与用全部数据训练出来的梯度是几乎一样的。 在合理范围内，增大 Batch_Size 有何好处？ 内存利用率提高了，大矩阵乘法的并行化效率提高。 跑完一次 epoch（全数据集）所需的迭代次数减少，对于相同数据量的处理速度进一步加快。 在一定范围内，一般来说 Batch_Size 越大，其确定的下降方向越准，引起训练震荡越小。 盲目增大 Batch_Size 有何坏处？ 内存利用率提高了，但是内存容量可能撑不住了。 跑完一次 epoch（全数据集）所需的迭代次数减少，要想达到相同的精度，其所花费的时间大大增加了，从而对参数的修正也就显得更加缓慢。 Batch_Size 增大到一定程度，其确定的下降方向已经基本不再变化。 调节 Batch_Size 对训练效果影响到底如何？这里跑一个 LeNet 在 MNIST 数据集上的效果。MNIST 是一个手写体标准库，我使用的是 Theano 框架。这是一个 Python 的深度学习库。安装方便（几行命令而已），调试简单（自带 Profile），GPU / CPU 通吃，官方教程相当完备，支持模块十分丰富（除了 CNNs，更是支持 RBM / DBN / LSTM / RBM-RNN / SdA / MLPs）。在其上层有 Keras 封装，支持 GRU / JZS1, JZS2, JZS3 等较新结构，支持 Adagrad / Adadelta / RMSprop / Adam 等优化算法。如图所示： 运行结果如上图所示，其中绝对时间做了标幺化处理。运行结果与上文分析相印证： Batch_Size 太小，算法在 200 epoches 内不收敛。 随着 Batch_Size 增大，处理相同数据量的速度越快。 随着 Batch_Size 增大，达到相同精度所需要的 epoch 数量越来越多。 由于上述两种因素的矛盾， Batch_Size 增大到某个时候，达到时间上的最优。 由于最终收敛精度会陷入不同的局部极值，因此 Batch_Size 增大到某些时候，达到最终收敛精度上的最优。 关于batchsize和epoch的理解batchsize指的是使超参数发生一次迭代输入的样本数，也就是完成一次反向传播、求导、参数更新过程所需要输入的样本数。epoch指完成将所有训练数据全部应用于参数更新的过程。在样本数据比较小时，batchsize可以取为训练样本数，这样完成一次epoch只需进行一次梯度下降和参数更新。将全部输入数据作为一个batch进行训练的方法称为批梯度下降法（Batch Gradient Descend）。与之相对应的是随机梯度下降法（Stochastic Gradient Descent）。这种梯度下降法每次只选取一个样本进行参数更新，因此完成一次epoch需要进行size(X)次迭代。这种方法梯度下降的方向一般不是最优的。将这两种方法折中的一种方法称为小批量梯度下降法（Mini-batch Gradient Descent）。这种方法每次将batchsize的数据用来训练网络，完成一次迭代。那么完成一次epoch需要进行的迭代次数为np.ceil(size(x) / batchsize)。在实际使用时，可以在一定范围内尽可能增大batchsize的值。当然，如果增大batch值，达到相同精度的epoch数会越来越多，因此需要在精度和运算速度这两方面来考虑选取的batchsize。方面来考虑选取的batchsize。]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小二乘解与最小二乘估计]]></title>
    <url>%2F2019%2F07%2F09%2FMachineLearning%2F%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E8%A7%A3(Least-squares%20Minimization)%2F</url>
    <content type="text"><![CDATA[最小二乘解与最小二乘估计资料 最小二乘解 最小二乘估计]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matlab GUI变成]]></title>
    <url>%2F2019%2F07%2F09%2FMatlab%2FMATLAB%20GUI%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[1 题外话这学期刚好在学信息论，里面各种熵函数信道容量的计算十分繁杂，于是乎想编写一个有GUI界面的信息论计算器。由于MATLAB对于矩阵的运算十分方便，所以选择以MATLAB为基础进行程序编写和界面设计。 2 回调函数callback中常用函数 get(hObject,’String’) 获得一个控件的字符串属性，常配合str2double函数使用，用于获得输入的数字以及判断输入的是否为数字 hObject相当于当前操作的控件的句柄，如果是在同一个GUI界面，可以使用handles.Tags，也就是 当前GUI的句柄名.要获得数据的控件标签名 来从其他控件获得数据。 set(hObject,’String’,’content’)设置一个控件的字符串属性，常用于设置输入数字的设置 guidata(hObject,handles)保存前面对hObject和handles的设置，一般回传函数callback的最后一行都是这段代码，用来更新数据 常用对话框tips: 每个GUI窗口都有一个初始化函数，类似于function simple_gui_OpeningFcn(hObject, eventdata, handles, varargin),这个初始化函数用于在创建这个GUI时创建一些参数以及在退出时返回一些参数。在这个函数中创建的参数可以被这个GUI里面的所有Object控件的回调函数调用。 fdsf 常用控件 弹出菜单（Pop-up Menu）在属性设置菜单（Inspector）中的’String’项可以对弹出菜单的项目进行设置，在’String’项第一行的内容将默认显示在弹出菜单中。在回调函数中，需要对弹出菜单中的每一项设置相应的代码，常用的语句是switch…case…end语句。常用的代码段：string = get(hObject,&#39;String&#39;); value = get(hObject,&#39;Value&#39;); switch string{value} case &#39;A&#39; %列表第一项 end value = get(hObject,’Value’);switch valuecase 1 %1即为列表中的第一项end ======================================= 创建新窗口的方法： 1. 使用guide创建一个新窗口并对其中的控件进行设置，将其命名（假设为child.fig） 2. 在触发显示新窗口的回调函数中加上如下语句： ``` matlab run(&#39;child&#39;); %or open(&#39;child.fig&#39;); h = guihandles; %h为新窗口的句柄变量，相当于原窗口的handles，可以使用如h.text1来操作新窗口的控件 set(h.text1,&#39;String&#39;,&#39;Hello child&#39;); %这是一个将新窗口中的text1控件显示的字符串设置成&#39;Hello child&#39;的例子 ======================================在回调函数之间和UI之间传递数据的方法1.setappdata(obj,name,val) obj为想要存储的数据所在的窗口的句柄变量，类似于handles，称为图形对象 name为存储该数据的变量名 val为数据的值例如：setappdata(f,&#39;todaysdate&#39;,val); %将句柄名为f的UI窗口中的数据val存放在名为todaysdate的变量中 val = getappdata(obj,name)vals = getappdata(obj) obj为想要取出的数据所在的窗口的句柄变量，类似于handles，它的值应该和对应的getappdata函数中的obj相同 name为存储该数据的变量名 注意左边需要设置一个val变量用于存放取出该数据的变量 vals为取出同一个图形对象中存放的所有共享数据 =========================================在同一个窗口中根据不同选择显示不同控件的方法初始化时将要显示的控件的Visible属性选择为On，其他控件选择为Off，在每个按钮的回调函数中利用set(handles.edit4,&#39;Visible&#39;,&#39;on&#39;)等代码进行调整即可 =======================================设置按下按钮或右上角弹出是否关闭的对话框的方法：在按钮的回调函数或当前窗口的CloseRequestFcn函数中加上selection = questdlg(‘Close the figure window?’,… ‘Confirmation’,… ‘Yes’,’No’,’Yes’);switch selection, case ‘Yes’, delete(gcf); %gcf为当前图像句柄 case ‘No’ returnend ============================================matlab GUI中插入图片的方法axes(handles.axes2);imshow(‘jin.jpg’); 清除图片的方法cla reset; 不显示坐标轴的方法：set(handles.axes1,’visible’,’off’)需要使用时改成on即可 =================================控件大小通过更改position中的height和weight选项即可 换行可以使用sprintf(‘\n’)或 [char(10,13)’]实现 matlab两个浮点数或整数和浮点数比较应该用abs(a - b) &lt; eps，而不是a - b ==================================调整当前窗口到屏幕中央movegui( gcf, &#39;center&#39;)。其他位置查阅movegui函数即可 ===================================matlab 显示矩阵set(handles.uitable1, ‘Data’, comparison); =================================判断一个矩阵中所有元素是否等于0any(abs(input2_2_temp(:) - 0 ) &gt; eps) MATLAB解线性方程组Ax = bx = A\b ====================================matlab中取出一个数组中某些特定元素a(a == 0) %取出a中所有等于0的元素，可接赋值语句，如a(a == 0) = 1; =================MATLAB 函数句柄格式：H = @(x)cos(x)相当于H(x) = cos(x) ==================================标记图像中的最大值 %first solution clc;clear all x=0:0.01:2*pi; y=sin(x); p=find(y == max(y)); plot(x,y,&#39;r&#39;,&#39;linewidth&#39;,2) grid on text(x(p),y(p),&#39;o&#39;,&#39;color&#39;,&#39;g&#39;) axis([0 2*pi -1.4 1.4]); %second solution clc;clear all x=0:0.01:2*pi; y=sin(x); p=find(y==max(y)); plot(x,y,&#39;r&#39;,&#39;linewidth&#39;,2) grid on axis([0 2*pi -1.4 1.4]) text(x(p),y(p),[&#39;(&#39;,num2str(x(p)),&#39;,&#39;,num2str(y(p)),&#39;)&#39;],&#39;color&#39;,&#39;b&#39;); ====================================MATLAB GUI 设置每个控件的显示顺序右键单击控件，有两个选项：Bring to front 和send to back，可以设置控件图层顺序]]></content>
      <categories>
        <category>Matlab</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[颜色收集]]></title>
    <url>%2F2019%2F07%2F09%2FOthers%2F%E5%B8%B8%E7%94%A8%E9%A2%9C%E8%89%B2%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[#929292 grey #FFBBFF pink #BBFFBB green #BBFFFF blue #FFFFBB yellow #FF9999 red]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Color</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 迭代器(iterator) 生成器(generator)]]></title>
    <url>%2F2019%2F07%2F09%2FPython%2FPython%20%E8%BF%AD%E4%BB%A3%E5%99%A8(iterator)%20%E7%94%9F%E6%88%90%E5%99%A8(generator)%2F</url>
    <content type="text"><![CDATA[可迭代对象(iterable) 定义 iterable又称为可迭代对象。在Python中，如果一个对象（又称为container object）实现了__iter__()方法或者可以支持下标索引的__getitem__()方法，就称为一个可迭代对象。 __iter__()方法 调用一个可迭代对象的__iter__()方法会返回一个当前可迭代对象的一个迭代器(iterator)。这个在下一章会提到。 iter()方法 调用一个可迭代对象的iter()方法会返回一个当前可迭代对象的一个迭代器(iterator)。 判断方法在Python中，我们常用到的集合数据类型都是iterable的。如列表(list)，元组(tuple)，字典(dict)，集合(set)，字符串(str)等。在程序中判断一个对象是否是iterable的方法为 # Method1: use isinstance from collections import Iterable isinstance([1, 2, 3], Iterable) # Method2: use for loop for i in [1, 2, 3]: print(i) 迭代器(iterator) 定义 借用Python文档中对迭代器的定义，一个迭代器指的是一个包含着数据流的对象，它每次返回数据中的一个元素。一个可迭代对象本身也可以是迭代器，但是这样在迭代一次之后数据本身将无法使用，除非将迭代器重置。在Python中大部分迭代器和可迭代对象是分离的，这样就保证了能够重复产生迭代器。 __next__()方法 一个迭代器必须实现__next__()方法。在每次调用迭代器（注意，不是可迭代对象）的__next__()方法时顺序返回数据的一个元素。当遍历完数据后抛出StopIteration异常，表示迭代完成。这时迭代器也就完成了它的使命。 __iter__()方法 调用一个迭代器的__iter__()方法会返回迭代器对象本身，注意每次调用产生一个新的迭代器对象。 next()方法 在next()内传入一个迭代器，可以得到迭代器的下一个值。 生成器(generator) 定义 生成器可以看成是迭代器的简化版。生成器只需要定义一个函数，并将普通函数的return改为yield即可。 使用 在使用生成器时，可以像一个普通的迭代器一样，使用for in或者next()方法获取其中的值。 # Define a generator def range_like(n): i = 0 while i &lt; n: yield i i += 1 # Create a generator object a = range_like(5) a.__next__() for i in range_like(n): print(i) 迭代器、生成器的关系迭代器、生成器、可迭代对象的关系可用下图表示 for语句的执行顺序在对一个iterable对象使用for语句时，实际上先调用了iter()方法返回一个iterator，然后再依次调用__next__()方法获得每一个值。当抛出StopIteration异常时意味着for语句的结束。 参考 What exactly are iterator, iterable and iteration 9.8. Iterators 彻底理解Iterable, Iterator, generator Python中iteration(迭代)、iterator(迭代器)、generator(生成器)等相关概念的理解]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python常用文件及目录操作]]></title>
    <url>%2F2019%2F07%2F09%2FPython%2FPython%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6%E5%8F%8A%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1 目录操作 遍历文件夹：os.listdir() 得到当前工作目录：os.getcwd() 新建文件夹：os.makedirs() 2 删除相关 删除文件：os.remove() 删除空文件夹：os.removedirs() 删除空/非空文件夹：shutil.rmtree() 3 检验相关 检验路径是否为文件：os.path.isfile() 检验路径是否为文件夹：os.path.isdir() 检验路径是否为快捷方式：os.path.islink() 检验路径是否存在：os.path.exists() 4 分离目录、文件相关 分离路径的目录名和文件名：os.path.split() 分离扩展名：os.path.splitext()。注意：分离出的扩展名带. 分离扩展名2：path.split(&#39;.&#39;)。分离出的扩展名不带. 5 重命名 重命名文件/文件夹：os.rename(old, new) 6 复制相关 复制文件：shutil.copyfile(old, new)。注意：old和new必须是文件 复制文件：shutil.copy(old, new)。注意：old必须是文件，new可以是文件/文件夹。如果是文件夹，执行的操作是复制文件到指定文件夹 复制文件夹：shutil.copytree(olddir, newdir)。注意：olddir和newdir都必须是文件夹，且newdir必须不存在 7 移动相关 移动文件/文件夹：shutil.move(old, new)件夹：shutil.move(old, new)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google Python Style Guide]]></title>
    <url>%2F2019%2F07%2F09%2FPython%2Fsimpread-styleguide%20_%20Style%20guides%20for%20Google-originated%20open-source%20projects%2F</url>
    <content type="text"><![CDATA[Google Python styleguide]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[argparse]]></title>
    <url>%2F2019%2F07%2F09%2FPythonPackages%2Fargparse%2F</url>
    <content type="text"><![CDATA[argparse模块用于在运行python程序时加入命令行参数。其基本用法是： 创建一个parser parser = argparse.ArgumentParser() 添加一个命令行参数parser.add_argument(&#39;-data&#39;, help=&#39;func_help&#39; required=True, type=int, choices=[1, 2, 3], nargs=&#39;?)其中，nargs表示需要参数的个数，’?’表示0或1，’*’表示任意，’+’表示1或多 获取传入的参数变量 opt = parser.parse_args() data = opt.data Reference]]></content>
      <categories>
        <category>Python Packages</category>
      </categories>
      <tags>
        <tag>argparse Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习参考资料]]></title>
    <url>%2F2019%2F07%2F09%2FDeepLearning%2F%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%2F</url>
    <content type="text"><![CDATA[整理了一些与深度学习有关的资料如下 lstm实现http://blog.csdn.net/mydear_11000/article/details/52414342###http://blog.csdn.net/u013082989/article/details/73693392 RNN和LSTM基础http://blog.csdn.net/xingzhedai/article/details/53144126https://www.jianshu.com/p/9dc9f41f0b29http://colah.github.io/posts/2015-08-Understanding-LSTMs/https://www.zybuluo.com/hanbingtao/note/476663 tensorflow 常用算子https://www.cnblogs.com/wuzhitj/p/6431381.html DBN算法实现http://blog.csdn.net/zhanglu_wind/article/details/78949020 数据分析必读书目http://www.cnblogs.com/charlotte77/p/5381681.html 深度神经网络系列文章 零基础入门深度学习(1) - 感知器 零基础入门深度学习(2) - 线性单元和梯度下降 零基础入门深度学习(3) - 神经网络和反向传播算法 零基础入门深度学习(4) - 卷积神经网络 零基础入门深度学习(5) - 循环神经网络 零基础入门深度学习(6) - 长短时记忆网络(LSTM) 零基础入门深度学习(7) - 递归神经网络]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[getopt]]></title>
    <url>%2F2019%2F07%2F09%2FPythonPackages%2Fgetopt%2F</url>
    <content type="text"><![CDATA[例子： import sys, getopt def main(argv): print(str(argv)) inputfile = &#39;&#39; outputfile = &#39;&#39; try: opts, args = getopt.getopt(argv, &#39;hi:o:&#39;, [&#39;help&#39;, &#39;ifile=&#39;, &#39;ofile=&#39;]) except getopt.GetoptError: print(&#39;test.py -i &lt;inputfle&gt; -o &lt;outputfile&gt;&#39;) sys.exit() for opt, arg in opts: if opt in [&#39;-h&#39;, &#39;--help&#39;]: print(1) elif opt in ([&#39;-i&#39;, &#39;--ifile&#39;]): inputfile = arg elif opt in ([&#39;-o&#39;, &#39;--ofile&#39;]): outputfile = arg print(&#39;input file is : &#39;, inputfile) print(&#39;output file is : &#39;, outputfile) if __name__ == &#39;__main__&#39;: main(sys.argv[1:]) 核心函数：options, args = getopt.getopt(args, shortopts, longopts=[])参数： shortopts：短格式参数串。shortopts 后的冒号(:)表示如果设置该选项，必须有附加的参数，不带冒号表示该选项没有附加参数如：”h f: v:”。h后面没有冒号，表示该选项没有附加参数，如用于输出命令用法f和v后面带有冒号，表示该选项有附加参数。无附加参数的示例为：python test.py -h。有附加参数的示例为：python test.py -h content。注意：加了冒号的参数的选项自带-，因此在获取opt时需要加上- longopts：长格式参数列表。longopts 后的等号(=)表示如果设置该选项，必须有附加的参数，否则就没有附加参数如：[“help”, “file=”, “version=”]。help 后面没有等号，表示该选项没有附加参数file 和 version 后面带冒号，表示如果设置该选项，必须有附加参数。无附加参数的示例为：python test.py --help。有附加参数的示例为：python test.py --help content 返回值含义：options：元组列表，每个元组的形式为：(选项, 附加参数)，如：(‘-f’, ‘data.csv’)args：包含那些没有 ‘-‘ 或 ‘–’ 的参数列表]]></content>
      <categories>
        <category>Python Packages</category>
      </categories>
      <tags>
        <tag>getopt Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言中数组名作为参数进行函数传递]]></title>
    <url>%2F2019%2F07%2F09%2FCProgrammingLanguage%2FC%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%95%B0%E7%BB%84%E5%90%8D%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E8%BF%9B%E8%A1%8C%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"><![CDATA[在普通变量或下标变量作函数参数时，形参变量和实参变量是由编译系统分配的两个不同的内存单元。在函数调用时发生的值传送是把实参变量的值赋予形参变量。在用数组名作函数参数时，不是进行值的传送，即不是把实参数组的每一个元素的值都赋予形参数组的各个元素。因为实际上形参数组并不存在，编译系统不为形参数组分配内存。那么，数据的传送是如何实现的呢?在我们曾介绍过，数组名就是数组的首地址。因此在数组名作函数参数时所进行的传送只是地址的传送，也就是说把实参数组的首地址赋予形参数组名。形参数组名取得该首地址之后，也就等于有了实在的数组。实际上是形参数组和实参数组为同一数组，共同拥有一段内存空间。因此当形参数组发生变化时，实参数组也随之变化。上图说明了这种情形。图中设a为实参数组，类型为整型。a占有以2000为首地址的一块内存区。b为形参数组名。当发生函数调用时，进行地址传送，把实参数组a的首地址传送给形参数组名b，于是b也取得该地址2000。于是a，b两数组共同占有以2000为首地址的一段连续内存单元。从图中还可以看出a和b下标相同的元素实际上也占相同的两个内存单元（整型数组每个元素占二字节）。例如a[0]和b[0]都占用2000和2001单元，当然a[0]等于b[0]。类推则有a[i]等于b[i]。多维数组也可以作为函数的参数。在函数定义时对形参数组可以指定每一维的长度，也可省去第一维的长度。因此，以下写法都是合法的：int MA(int a[3][10]);或int MA(int a[][10]); 下面给出两个将数组传递进函数的例子：ex1: //求5名学生的平均成绩 #include &lt;stdio.h&gt; float aver(float a[5]) //此处函数的定义中数组的元素个数可以省略，由传入的数组决定 { int i; float av,s=a[0]; for(i=1;i&lt;5;i++) s=s+a[i]; av=s/5; return av; } int main(void){ float sco[5],av; int i; printf(&quot;\ninput 5 scores:\n&quot;); for(i=0;i&lt;5;i++) scanf(&quot;%f&quot;,&amp;sco[i]); av=aver(sco); //此处将数组传递进函数时使用的是数组名称，没有括号 printf(&quot;average score is %5.2f&quot;,av); return 0; } ex2: //将数组中小于0的元素置成0 #include &lt;stdio.h&gt; void nzp(int a[8]) { int i; printf(&quot;\nvalues of array are:\n&quot;); for(i=0;i&lt;8;i++) { if(a[i]&lt;0) a[i]=0; printf(&quot;%d &quot;,a[i]); } } int main(void) { int b[5],i; printf(&quot;\ninput 5 numbers:\n&quot;); for(i=0;i&lt;5;i++) scanf(&quot;%d&quot;,&amp;b[i]); printf(&quot;initial values of array b are:\n&quot;); for(i=0;i&lt;5;i++) printf(&quot;%d &quot;,b[i]); nzp(b); //将有5个元素的数组传递进一个有8个元素的数组的函数，编译通过 printf(&quot;\nlast values of array b are:\n&quot;); for(i=0;i&lt;5;i++) printf(&quot;%d &quot;,b[i]); return 0; }]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pip换源]]></title>
    <url>%2F2019%2F07%2F09%2FPythonPackages%2Fpip%E6%8D%A2%E6%BA%90%2F</url>
    <content type="text"><![CDATA[临时pip install -i https://pypi.tuna.tsinghua.edu.cn/simple packagename清华大学镜像站 永久在./user/pip/下新建pip.ini，内容为： index-url = https://pypi.tuna.tsinghua.edu.cn/simple trusted-host = pypi.tuna.tsinghua.edu.cn ```du.cn]]></content>
      <categories>
        <category>Python Packages</category>
      </categories>
      <tags>
        <tag>Pip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pandas]]></title>
    <url>%2F2019%2F07%2F09%2FPythonPackages%2Fpandas%2F</url>
    <content type="text"><![CDATA[1 对于时间的处理python中datetime模块非常好用，提供了日期格式和字符串格式相互转化的函数strftime/strptime 1、由日期格式转化为字符串格式的函数为: datetime.datetime.strftime() 2、由字符串格式转化为日期格式的函数为: datetime.datetime.strptime() 3、两个函数都涉及日期时间的格式化字符串，列举如下： %a 星期几的简写;如 星期三为Web %A 星期几的全称;如 星期三为Wednesday %b 月份的简写; 如4月份为Apr %B 月份的全称; 如4月份为April %c 标准的日期的时间串;（如： 04/07/10 10:43:39） %C 年份的后两位数字 %d 十进制表示的每月的第几天 %D 月/天/年 %e 在两字符域中，十进制表示的每月的第几天 %F 年-月-日 %g 年份的后两位数字，使用基于周的年 %G 年分，使用基于周的年 %h 简写的月份名 %H 24小时制的小时 %I 12小时制的小时 %j 十进制表示的每年的第几天 %m 十进制表示的月份 %M 十时制表示的分钟数 %n 新行符 %p 本地的AM或PM的等价显示 %r 12小时的时间 %R 显示小时和分钟：hh:mm %S 十进制的秒数 %t 水平制表符 %T 显示时分秒：hh:mm:ss %u 每周的第几天，星期一为第一天 （值从0到6，星期一为0） %U 第年的第几周，把星期日做为第一天（值从0到53） %V 每年的第几周，使用基于周的年 %w 十进制表示的星期几（值从0到6，星期天为0） %W 每年的第几周，把星期一做为第一天（值从0到53） %x 标准的日期串 %X 标准的时间串 %y 不带世纪的十进制年份（值从0到99） %Y 带世纪部分的十制年份 %z，%Z 时区名称，如果不能得到时区名称则返回空字符。 %% 百分号2 入门及基本操作 查看数据的头5行/后5行 df.head()` df.tail() 查看数据索引，数据的列名，数据的值 df.index df.columns df.values 对坐标轴进行排序df.sort_index(axis=1, ascending=False)注意：axis=1是以列名作为索引，也就是columns；axis=0是以行名作为索引，也就是index 对值进行排序df.sort_values(by=&#39;B&#39;) 数据切片操作df.loc 按照行、列名选取df.iloc 按照行、列号选取df.ix iloc和loc的结合 df.loc[&#39;20010101&#39;] #选取行 df.loc[:, [&#39;A&#39;]] #选取列 df.iloc[0] df.iloc[:, [0]]注意:使用loc进行切片时，括号左右两边的值都包含，如df.loc[&#39;A&#39;:&#39;B&#39;]取出的行包括index为A和B的行。使用iloc进行切片时，括号右边的值不包含，如df.iloc[:2]取出的行为序号为0和1的行 对残缺数据处理 df.dropna() df.fillna()inplace参数：在原dataframe中进行修改 数据的读取：读取txt文件：df = pd.read_table(&#39;./data/bili.txt&#39;, sep=&#39;,&#39;)查看各列类型：df.info()调整列顺序：df = df[[&#39;a&#39;, &#39;c&#39;, &#39;b&#39;]]删除一列：df.drop(axis=1, inplace=True)查找某行某列的值 # df.loc[conditions, column name] = newvalue df_full.loc[(df_full[&#39;date&#39;] == date_temp) &amp; (df_full[&#39;time&#39;] == time_temp), &#39;reqnum&#39;] = reqnum_temp`]]></content>
      <categories>
        <category>Python Packages</category>
      </categories>
      <tags>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大似然估计]]></title>
    <url>%2F2019%2F07%2F09%2FDeepLearning%2F%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[目的有时候，直接估计条件概率密度函数很难，因此将概率密度估计问题转化为参数估计问题，极大似然法就是一种参数估计问题。 重要前提训练样本的分布能代表样本的真实分布。每个样本集中的样本都是所谓独立同分布的随机变量 (iid条件)，且有充分的训练样本。 基本内容极大似然估计的基本内容是：利用已知的样本结果，反推最有可能导致这样结果的参数值。似然函数指联合概率密度函数关于每个样本以及需要估计的参数的函数。一般形式为：$$L(\theta) = f(x_{1}, x_{2}, … ,x_{n};\theta)$$ 一般步骤求最大似然估计量的一般步骤： 由总体分布导出样本的联合概率函数（或联合密度）； 把样本联合概率函数的自变量看成是已知常数，而把θθ看做是自变量，得到似然函数$L(\theta)$; 求似然函数的最大值（常常取对数，然后求驻点）； 用样本值带入得到参数的最大似然估计 最大似然估计的特点： 比其他估计方法更加简单； 收敛性：无偏或者渐近无偏，当样本数目增加时，收敛性质会更好； 如果假设的类条件概率模型正确，则通常能获得较好的结果。但如果假设模型出现偏差，将导致非常差的估计结果。 最大似然估计(MLE)和最小二乘法估计(LSE)的区别最小二乘法估计的目的是让估计量最好地拟合样本数据，也就是让估计值与样本值之差的平方和最小$$Q = \sum_{i=1}^{n}(Y_{i} - \hat{Y}_{i})^{2}$$ 参考极大似然估计详解]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[联合体（Union）]]></title>
    <url>%2F2019%2F07%2F09%2FCProgrammingLanguage%2F%E8%81%94%E5%90%88%E4%BD%93%EF%BC%88Union%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原文地址：http://c.biancheng.net/cpp/html/2932.html 1. 共用体的简介在C语言中，还有另外一种和结构体非常类似的语法，叫做共用体（Union），它的定义格式为： union 共用体名{ 成员列表 }; 结构体和共用体的区别在于：结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，所有成员的存储首地址相同。因此更改一个成员的值可能影响所有成员的值。结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙），共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。共用体也是一种自定义类型，可以通过它来创建变量，例如： union data{ int n; char ch; double f; }; union data a, b, c; 上面是先定义共用体，再创建变量，也可以在定义共用体的同时创建变量： union data{ int n; char ch; double f; } a, b, c; 如果不再定义新的变量，也可以将共用体的名字省略： union{ int n; char ch; double f; } a, b, c; 共用体 data 中，成员 f 占用的内存最多，为 8 个字节，所以 data 类型的变量（也就是 a、b、c）也占用 8 个字节的内存，请看下面的演示： #include &lt;stdio.h&gt; union data{ int n; //int类型占用4个字节 char ch; //char类型占用1个字节 short m; //short类型占用2个字节 }; int main(){ union data a; printf(&quot;%d, %d\n&quot;, sizeof(a), sizeof(union data) ); a.n = 0x40; printf(&quot;%X, %c, %hX\n&quot;, a.n, a.ch, a.m); a.ch = &#39;9&#39;; printf(&quot;%X, %c, %hX\n&quot;, a.n, a.ch, a.m); a.m = 0x2059; printf(&quot;%X, %c, %hX\n&quot;, a.n, a.ch, a.m); a.n = 0x3E25AD54; printf(&quot;%X, %c, %hX\n&quot;, a.n, a.ch, a.m); return 0; } 运行结果： 4, 440, @, 40 //‘@’是ASCII码等于0x40的字符39, 9, 39 //0x39是’9’的ASCII码2059, Y, 2059 //‘Y’是ASCII码等于0x59的字符3E25AD54, T, AD54 这段代码不但验证了共用体的长度，还说明共用体成员之间会相互影响，修改一个成员的值会影响其他成员。要想理解上面的输出结果，弄清成员之间究竟是如何相互影响的，就得了解各个成员在内存中的分布。以上面的 data 为例，各个成员在内存中的分布如下： 成员 n、ch、m 在内存中“对齐”到一头，对 ch 赋值修改的是前一个字节，对 m 赋值修改的是前两个字节，对 n 赋值修改的是全部字节。也就是说，ch、m 会影响到 n 的一部分数据，而 n 会影响到 ch、m 的全部数据。上图是在绝大多数 PC机上的内存分布情况，如果是51单片机，情况就会有所不同： 为什么不同的机器会有不同的分布情况呢？这跟机器的存储模式有关。 2. 共用体的应用共用体在一般的编程中应用较少，在单片机中应用较多。对于PC机，经常使用到的一个实例是：现有一张关于学生信息和教师信息的表格。学生信息包括姓名、编号、性别、职业、分数，教师的信息包括姓名、编号、性别、职业、教学科目。请看下面的表格： Name Num Sex Profession Score / Course HanXiaoXiao 501 f s 89.5 YanWeiMin 1011 m t math LiuZhenTao 109 f t English ZhaoFeiYan 982 m s 95.0 f 和 m 分别表示女性和男性，s表示学生，t表示教师。可以看出，学生和教师所包含的数据是不同的。现在要求把这些信息放在同一个表格中，并设计程序输入人员信息然后输出。如果把每个人的信息都看作一个结构体变量的话，那么教师和学生的前4个成员变量是一样的，第 5个成员变量可能是score或者course。当第4个成员变量的值是 s 的时候，第 5 个成员变量就是score；当第4个成员变量的值是t的时候，第 5 个成员变量就是 course。经过上面的分析，我们可以设计一个包含共用体的结构体，请看下面的代码： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define TOTAL 4 //人员总数 struct{ char name[20]; int num; char sex; char profession; union{ float score; char course[20]; } sc; } bodys[TOTAL]; int main(){ int i; //输入人员信息 for(i=0; i&lt;TOTAL; i++){ printf(&quot;Input info: &quot;); scanf(&quot;%s %d %c %c&quot;, bodys[i].name, &amp;(bodys[i].num), &amp;(bodys[i].sex), &amp;(bodys[i].profession)); if(bodys[i].profession == &#39;s&#39;){ //如果是学生 scanf(&quot;%f&quot;, &amp;bodys[i].sc.score); }else{ //如果是老师 scanf(&quot;%s&quot;, bodys[i].sc.course); } fflush(stdin); } //输出人员信息 printf(&quot;\nName\t\tNum\tSex\tProfession\tScore / Course\n&quot;); for(i=0; i&lt;TOTAL; i++){ if(bodys[i].profession == &#39;s&#39;){ //如果是学生 printf(&quot;%s\t%d\t%c\t%c\t\t%f\n&quot;, bodys[i].name, bodys[i].num, bodys[i].sex, bodys[i].profession, bodys[i].sc.score); }else{ //如果是老师 printf(&quot;%s\t%d\t%c\t%c\t\t%s\n&quot;, bodys[i].name, bodys[i].num, bodys[i].sex, bodys[i].profession, bodys[i].sc.course); } } return 0; } 运行结果： Input info: HanXiaoXiao 501 f s 89.5Input info: YanWeiMin 1011 m t mathInput info: LiuZhenTao 109 f t EnglishInput info: ZhaoFeiYan 982 m s 95.0 Name Num Sex Profession Score / CourseHanXiaoXiao 501 f s 89.500000YanWeiMin 1011 m t mathLiuZhenTao 109 f t EnglishZhaoFeiYan 982 m s 95.000000]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pytorch入门]]></title>
    <url>%2F2019%2F07%2F09%2FPytorch%2FPytorch%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[1 Pytorch教程 Pytorch中文文档 Pytorch英文文档 英文版：http://pytorch.org/tutorials/beginner/deep_learning_60min_blitz.html 中文版：https://www.jianshu.com/p/889dbc684622 Pytorch github项目整理 2 Pytorch安装 建议使用Anaconda安装。清华大学anaconda pytorch地址： https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/]]></content>
      <categories>
        <category>Pytorch</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pytorch使用过程中遇到的问题]]></title>
    <url>%2F2019%2F07%2F09%2FPytorch%2FPytorch%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1 tensor.to(device)和module.to(device)tensor.to(device)不是inplace operation。因此在给一个tensor指定device时需要用：tensor1 = tensor1.to(device)。而Module.to(device)是inplace operation，因此直接使用Module.to(device)即可。 2 Numpy和Tensor的数据转换在将Numpy的数据转化为Tensor时，需要注意一个问题。Numpy中默认浮点类型是np.float64，Pytorch中默认浮点类型是torch.float32。直接使用torch.tensor(array)得到的会是torch.double类型的数据。如果想得到torch.float类型的数据，需要对Numpy数据进行类型转换：array = array.astype(np.float32) 3 ‘bool value of Tensor with more than one value is ambiguous’这种情况可能是损失函数声明时没有加括号。即应该是loss_function=nn.MSELoss()而不是loss_function=nn.MSELoss 4 Dataloader的数据格式在使用Dataloader导入训练数据时，会使用for batch in dataloader，batch实际上是一个包含所有data的列表。即使只有一组数据，也必须使用batch[0]对数据进行提取。 5 在训练过程中loss不下降一种可能原因是在计算loss = torch.nn.functional.mseloss(output, real)时，output和real的维数不完全一致。 6 matplotlib和pytorch同时导入报错在同时导入matplotlib和pytorch.optim时报错：Process finished with exit code -1073740791 (0xC0000409)。解决方法：先导入pytorch再导入matplotlib，如下： import torch.optim as opt import matplotlib.pyplot as plt 7 Pytorch显存不足在使用Pytorch时，有时可能遇到显存不足的问题。即RuntimeError: CUDA out of memory. Tried to allocate 11.88 MiB (GPU 0; 6.00 GiB total capacity; 4.52 GiB already allocated; 11.60 MiB free; 758.50 KiB cached)。出现这种问题的原因可能是在保存结果时将过大的张量保存在GPU中，导致GPU存储空间不足。解决方法：检查所有存储在GPU中的张量，将其中一些较大的用tensor.to(&#39;cpu&#39;)转到内存中储存。 。]]></content>
      <categories>
        <category>Pytorch</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式学习和查询网站]]></title>
    <url>%2F2019%2F07%2F09%2FRegex%2F%E5%B8%B8%E7%94%A8%E6%9F%A5%E8%AF%A2%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[正则表达式学习和查询网站 正则表达式30分钟入门教程 正则表达式手册 正则表达式快速参考]]></content>
      <categories>
        <category>Regex</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式一些知识点]]></title>
    <url>%2F2019%2F07%2F09%2FRegex%2F%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1 括号的区别 小括号()：匹配小括号内的字符串，可以是一个，也可以是多个，常跟“|”（或）符号搭配使用，是多选结构的。通俗的说小括号匹配的是具体的字符示例1：string name = “way2014”; regex：(way|zgw) result：结果是可以匹配出way的，因为是多选结构，小括号是匹配字符串的示例2：string text = “123456789”; regex：(0-9) result：结果是什么都匹配不到的，它只匹配字符串”0-9”而不是匹配数字, [0-9]这个字符组才是匹配0-9的数字 中括号[]：匹配字符组内的字符，比如咱们常用的[0-9a-zA-Z.*?!]等，在[]内的字符都是字符，不是元字符，比如“0-9”、“a-z”这中间的“-”就是连接符号，表示范围的元字符，如果写成[-!?*(]这样的话，就是普通字符。通俗的说中括号匹配的是元字符示例1： string text = “1234567890”; regex：[0-9] result：结果是可以匹配出字符串text内的任意数字了，像上边的【或符号“|”在字符组内就是一个普通字符】示例2：string text = “a|e|s|v”; regex：[a|e|s] result：结果就是匹配字符a、e、|三个字符，这个跟(a|e|s)有区别的，区别就是(a|e|s)匹配的是a、e、s三个字符的随意一个，三个中的任意一个，这是的|是元字符 大括号{}：匹配次数，匹配在它之前表达式匹配出来的元素出现的次数，{n}出现n次、{n,}匹配最少出现n次、{n,m}匹配最少出现n次，最多出现m次 2 替换一部分内容在替换正则表达式内容时，有时需要保持一部分内容不变。具体做法是：将需要保留的部分用小括号括起来，在修改后的表达式中使用$1,$2…引用。$0表示整个匹配项。如：把trim(ABC)替换成trim(replace(ABC,char(9),’ ‘)，正则表达式为：trim\(([^).]*)\)替换成trim\(replace\($1,char\(9\),&#39; &#39;\)place($1,char(9),’ ‘)`]]></content>
      <categories>
        <category>Regex</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建我的Hexo博客——从入门到放弃]]></title>
    <url>%2F2019%2F07%2F09%2FHexo%2F%E6%90%AD%E5%BB%BA%E6%88%91%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2%E2%80%94%E2%80%94%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%2F</url>
    <content type="text"><![CDATA[这篇博客记录的是我从0开始搭建自己的博客的过程。注意:这不是一篇搭建博客教程！！! 它只是记录了我走过的一些弯路以及摸索和学习的过程，因此写的顺序并不符合教程的格式。内容也比较零碎。如果你也想用我的主题搭建自己的博客，那么这篇文章也许有一定的参考价值。 1 Hexo博客安装与部署参考Windows下，Hexo+GitHub搭建博客这篇博客。其中一些常用命令为 hexo g # 完整命令为hexo generate，用于生成静态文件 hexo s # 完整命令为hexo server，用于启动服务器，主要用来本地预览 hexo d # 完整命令为hexo deploy，用于将本地文件发布到github上 hexo n # 完整命令为hexo new，用于新建一篇文章 hexo clean # 清除hexo缓存2 新建页面hexo new page pagename 这个操作会在source中新建一个名为pagename的文件夹。里面的内容就是新页面的内容。 3 文章属性设置以下设置置于文章顶端，用于修改页面显示属性 色块 color: blue/purple/green/yellow/red，如果不设置则随机选择。 个性化徽标 icon: book/game/note/chat/code/image/web/link/design/lock，如果不设置则随机选择。 缩略图设置 thumb:，如果不设置则优先级顺序为：文章第一张图片$\rightarrow$默认缩略图。通过thumb:设置的缩略图可以是外链或本地文件。本地文件需要放在/source/images/文件夹下，支持png，jpg，jpeg，webp。 代码高亮设置 在这里修改。将样式名称所有字母小写并用-隔开即可。 4 分页设置 首页分页index_generator: path: &#39;&#39; per_page: 12 order_by: -date 归档页分页archive_generator: enabled: true per_page: 0 yearly: true monthly: true daily: false order_by: -date 5 第一次加入自己的HTML代码需求：在页脚处加入一个跳动的$\hearts$并设置颜色为红色。 html &lt;link href=&quot;//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;link href=&quot;//cdn.bootcss.com/animate.css/3.5.1/animate.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;i class=&quot;fa fa-heart animated infinite pulse&quot;&gt;&lt;/i&gt; css .fa.fa-heart { color: red; font-size: 5em; } 加入方法：找到footer.ejs文件，在对应位置插入html代码。找到style.min.css文件，在结尾处加上相应地css代码。 6 加入看板娘功能 基本版 高级版 高级版设置教程 高级版教程2 终极版教程(推荐使用) 7 对超链接的设置.post-content p a { color: #313131; border-bottom: 1px solid #ccc; } 8 图标素材库font awesome 9 源代码结构 source _posts 存放文章。每个Markdown文件就是一个页面。 about 存放about页面。 categories 存放categories页面 links 存放links页面。 plugins 存放一些插件，如live2d tags 存放tags页面 themes pinghsu languages 不同语言文本显示。默认采用zh-CN.yml中的配置 layout _partial footer.ejs 页面底部相关设置 header.ejs 页面顶部相关设置 page-archive.ejs 标签页点击各标签进入的页面 page-category.ejs 首页点击分类进入的页面 page-custom.ejs 自定义页面 page-search.ejs 搜索页面 page-tag.ejs 首页点击标签进入的页面 pagination.ejs 分页设置，即每页显示多少内容 archive.ejs 归档页设置 category.ejs 分类页设置 index.egs 首页设置 layout.ejs 暂不清楚 scripts 一些用到的js脚本 source images 用到的图片 js 一些用到的脚本 style.min.css 页面css设置 _congfig.yml 与主题相关的配置文件 _config.yml Hexo配置文件 10 修改Tags页面每行显示个数style.min.css中的.connon-page .post-list-item的width项 11 修改页面显示的一些文字/languages/default.yml 12 将配置中的一些文字加入代码__(&#39;menu.tags&#39;) 13 看板娘相关设置 看板娘基础设置看板娘基础设置包括样式设置及事件应答语句。样式设置在waifu-tips.js开头，事件应答语句设置在waifu-tips.json中。 mouseClick和mouseMove的响应为了响应mouseClick和mouseMove事件，需要指定selector和响应的text。模板已经在waifu-tips.json中给出。其中selector即为触发条件。为了快速找到触发条件，可以使用Chrome的检查，找到元素所属的类(class)或超链接(a href)即可。 14 Mouseover多次触发问题在测试看板娘的时候，发现多次移动鼠标都会触发mouseover语句，上网查阅后发现mouseover会冒泡，也就是会触发父类。因此改成了mouseenter。仅在进入时触发。 15 &lt;a&gt;标签的属性这里可以看到&lt;a&gt;标签的属性。有时候需要加入title属性以方便引用。 16 添加搜索功能 在page.ejs中加入else if (is_current(&#39;/search&#39;)) { %&gt; &lt;%- partial(&#39;_partial/page-search&#39;) %&gt; &lt;% } hexo new page search 新建page-search.ejs 在style.min.css中 修改搜索框及搜索结果边框和样式 在search.js中修改关键词高亮样式 在测试时发现匹配时会匹配到标签中的值(如&lt;strong&gt;)等，因此在正则表达式中需要进行修改。查询结果是在RegExp的keyword后加上&quot;(?![^&lt;&gt;]*&gt;)&quot;。这句话的意思是把关键词后带&gt;的去掉，也就是去掉了标签里的关键词以免将标签内的关键词作替换。 这个搜索的关键词是用[\s\-]+隔开。 在测试时发现搜索结果框在没有输入关键词时仍显示，于是在search.js中加了一段脚本，使之在无关键词时隐藏。if (this.value.trim().length &lt;= 0) { document.getElementById(content_id).style.display=&quot;none&quot; return; } else { document.getElementById(content_id).style.display=&quot;&quot; } 另外，在page-search.ejs中让搜索结果一开始默认不显示。&lt;div id=&quot;local-search-result&quot; class=&quot;local-search-result-cls&quot; style=&quot;display:none&quot;&gt;&lt;/div&gt; Console报错Uncaught TypeError: Cannot read property &#39;addEventListener&#39; of null原因：在一开始$input为空，所以不能添加监听函数。解决方法是加一个判断if ($input)。 17 滑动条的实现&lt;% if (is_post()) { %&gt; var postSharer = new Headroom(document.getElementById(&quot;post-bottom-bar&quot;), { tolerance: 0, offset : 70, classes: { initial: &quot;animated&quot;, pinned: &quot;pinned&quot;, unpinned: &quot;unpinned&quot; } }); postSharer.init(); &lt;% } %&gt; var header = new Headroom(document.getElementById(&quot;header&quot;), { tolerance: 0, offset : 70, classes: { initial: &quot;animated&quot;, pinned: &quot;slideDown&quot;, unpinned: &quot;slideUp&quot; } }); header.init(); 18 加入音乐播放器在post.ejs中找到 &lt;% if (theme.music.enable) { %&gt; &lt;meting-js id=&quot;&lt;%= theme.music.id %&gt;&quot; fixed=&quot;true&quot; server=&quot;&lt;%= theme.music.server %&gt;&quot; type=&quot;&lt;%= theme.music.type %&gt;&quot; auto=&quot;&lt;%= theme.music.auto %&gt;&quot; autoplay=&quot;&lt;%= theme.music.autoplay %&gt;&quot; order=&quot;&lt;%= theme.music.order %&gt;&quot; lrc-type=&quot;0&quot; &gt; &lt;/meting-js&gt; &lt;% } %&gt; 具体选项可googlemeting-js进行设置。另外注意要在配置文件中把music.enable项设为true。 19 为博客标题中的超链接加上下划线用Chrome调试找到 .post-content ol a { color: #313131; border-bottom: 1px solid #ccc; } .post-content ol a:hover { color: #eb5055; border-bottom: 1px solid #eb5055; } 20 修改光标样式在想修改的地方（如body）添加cursor:url(&#39;https://cdn.jsdelivr.net/gh/moezx/cdn@3.1.9/img/Sakura/cursor/normal.cur&#39;), auto; 21 打字彩花特效]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python装饰器]]></title>
    <url>%2F2019%2F07%2F09%2FPython%2FPython%E8%A3%85%E9%A5%B0%E5%99%A8(decorator)%2F</url>
    <content type="text"><![CDATA[一般来说我们经常性会在工程性的代码里面经常性看到例如@staticmethod或是@classmethod等等，这就是装饰器，通常来说，装饰器的作用我们可以这样理解，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。这样说着可能比较抽象，我们稍微接着看个很简单的例子就能很容易理解了。 1 关于装饰器直接看一个很简单的例子 比如说我有一个func()函数， def func(): for i in xrange(100): print &quot;bendawang&quot; 我现在想要记录这个函数的执行时间。一般我们可能会这样写 import time def func(): a=time.time() for i in xrange(100): print &quot;bendawang&quot; b=time.time() print str((b-a))+&quot; s&quot; 即记录下前后的时间，然后做个减法。 那如果我有100个和func()一样的函数func1(),func2(),func3()......，我要对每一个都记录执行时间怎么办呢？ 这样一个一个加代码肯定不划算啊，而且考虑到以后万一我又不想统计它们的时间，又还得一个个注释掉。 这里我们先看一种写法， import time def get_time(myfunc): a=time.time() myfunc() b=time.time() print myfunc.__name__+&quot; cost &quot;+str((b-a))+&quot; s&quot; def func(): for i in xrange(100): print &quot;bendawang&quot; get_time(func) 这样我通过一个get_time()来间接调用func(),func1(),func2()......就能够成功记录时间了。 好的，能够简单的记录所有时间的问题解决了。 但是现在我们又面临了一个新的问题，比如我使用上面的方法，也就意味着我所有调用func(),func1(),func2()......的地方,现在都要换成get_time(func),get_time(func1),get_time(func2)......，但是我这是一个大的工程，要改那么多地方相当麻烦啊。 这个时候我们突然想到了，之前第一篇文章里面说过python一切皆对象，函数也是，那么我们的返回值也可以是一个函数咯，所以可以这样子写： import time def get_time(myfunc): def wrapper(): a=time.time() myfunc() b=time.time() print myfunc.__name__+&quot; cost &quot;+str((b-a))+&quot; s&quot; return wrapper def func(): for i in xrange(100): print &quot;bendawang&quot; func=get_time(func) func() 我们以一个函数为返回值覆盖原来的func，这样子我们就可以直接调用func(),func1(),func2()......，而且也能够记录时间也不用大动干戈去修改工程里面的其他代码。 这get_time()函数就可以叫做装饰器了，即装饰器的本质实际上就是一个函数而已，不过通常我们都通过@语法糖来简化装饰器的写法，上述代码可以这样子写： import time def get_time(myfunc): def wrapper(): a=time.time() myfunc() b=time.time() print myfunc.__name__+&quot; cost &quot;+str((b-a))+&quot; s&quot; return wrapper @get_time def func(): for i in xrange(100): print &quot;bendawang&quot; func() 所以其实@get_time的本质就是func=get_time(func)。 2 关于参数问题装饰器基本理解了，那么如果我们需要往函数里面传递参数怎么办？ 那其实这个问题是一样的，如下： import time def get_time(myfunc): def wrapper(count): a=time.time() myfunc(count) b=time.time() print myfunc.__name__+&quot; cost &quot;+str((b-a))+&quot; s&quot; return wrapper @get_time def func(count): for i in xrange(count): print &quot;bendawang&quot; func(10) 有一个就给get_time加一个参数，有两个就给它搞两个参数就好了。 那么这样子又有新的问题了。刚才说了，我有100个func函数，那么如果这些函数传入的参数不一样怎么办？怎么共用这个装饰器get_time？ 那么我们通常装饰器的写法就出来了，利用python中的*args, **kwargs来引入可变参数 简单说一下这两兄弟的用法，*args表示任何多个无名参数，它是一个tuple；**kwargs表示关键字参数，它是一个 dict。并且同时使用*args和**kwargs时，必须*args参数列要在**kwargs前。 那么看一个例子就基本能理解了。 def foo(*args, **kwargs): print &#39;args = &#39;, args print &#39;kwargs = &#39;, kwargs print &#39;---------------------------------------&#39; if __name__ == &#39;__main__&#39;: foo(1,2,3,4) foo(a=1,b=2,c=3) foo(1,2,3,4, a=1,b=2,c=3) foo(&#39;a&#39;, 1, None, a=1, b=&#39;2&#39;, c=3) Result as follow: args = (1, 2, 3, 4) kwargs = {} --------------------------------------- args = () kwargs = {&#39;a&#39;: 1, &#39;c&#39;: 3, &#39;b&#39;: 2} --------------------------------------- args = (1, 2, 3, 4) kwargs = {&#39;a&#39;: 1, &#39;c&#39;: 3, &#39;b&#39;: 2} --------------------------------------- args = (&#39;a&#39;, 1, None) kwargs = {&#39;a&#39;: 1, &#39;c&#39;: 3, &#39;b&#39;: &#39;2&#39;} --------------------------------------- 所以我们的装饰器可以这样写 import time def get_time(myfunc): def wrapper(*args,**kwargs): a=time.time() myfunc(*args,**kwargs) b=time.time() print myfunc.__name__+&quot; cost &quot;+str((b-a))+&quot; s&quot; return wrapper @get_time def func(count): for i in xrange(count): print &quot;bendawang&quot; func(10) 所以其实我们经常在一些工程的项目里面都会看到例如下面的一些代码 def handleException(func): def _wrapper(args): try: out = Output() return func(args, out) except PenError as error: out.error(str(error)) except ExploitError as error: out.error(str(error)) except NotImplementError as error: out.error(str(error)) except ORMError as error: out.error(str(error)) except Exception as error: out.error(u&quot;未知错误, &#39;{0}&#39;&quot;.format(error)) except KeyboardInterrupt: out.error(u&quot;用户强制退出&quot;) finally: out.close() return _wrapper 然后工程中的很多函数都会用@handleException，相信很好理解了，就是对这些函数统一进行出错处理避免代码冗杂。这是工程中必不可少的思维，虽然我还没怎么写过工程性的东西。 3 关于多个装饰器的问题因为可以使用多个装饰器，那么执行顺序就是问题，如下： @get_time @test def func(count): for i in xrange(count): print &quot;bendawang&quot; func(10) 上述代码我用了get_time和test两个装饰器，执行顺序是先执行test在执行get_time。 4 python-内置装饰器这个算是本文的重要部分了，Python中有三个内置的装饰器，staticmethod、classmethod 和property。这些都是和类相关的，所以尽量看完第一篇再看这里。 首先说说staticmethod、classmethod，用文字说起来可能比较绕，用staticmethod和classmethod装饰的类中的函数实际上和一个全局函数差不多，可以通过类或是类的实例来调用，而一般的函数是不能通过类本身来调用，只能通过类的实例来调用。而这两个装饰器的差别在于，classmethod会将类本身当作第一个参数传入,即可以获得当前类的属性和方法。看一个例子 class Foo: @staticmethod def bar1(hello): print &quot;this is the staticmethod===&gt;&quot;+hello+&quot;\n&quot; @classmethod def bar2(cls,hello): print &quot;this is the classmethod ===&gt;&quot;+hello+&quot;\n&quot; def bar3(self,hello): print &quot;this is a normal method ===&gt;&quot;+hello+&quot;\n&quot; Foo.bar1(&#39;test&#39;) Foo.bar2(&#39;test&#39;) Foo.bar3(&#39;test&#39;) 结果如下： this is the staticmethod===&gt;test this is the classmethod ===&gt;test Traceback (most recent call last): File &quot;a.py&quot;, line 15, in &lt;module&gt; Foo.bar3(&#39;test&#39;) TypeError: unbound method bar3() must be called with Foo instance as first argument (got str instance instead) 可以看出来第三个报错了，因为说过了普通函数只能用实例来调用，所以只能这样子写 class Foo: @staticmethod def bar1(hello): print &quot;this is the staticmethod===&gt;&quot;+hello+&quot;\n&quot; @classmethod def bar2(cls,hello): print &quot;this is the classmethod ===&gt;&quot;+hello+&quot;\n&quot; def bar3(self,hello): print &quot;this is a normal method ===&gt;&quot;+hello+&quot;\n&quot; Foo.bar1(&#39;test&#39;) Foo.bar2(&#39;test&#39;) foo=Foo() foo.bar3(&#39;test&#39;) 接下来是@property，个人感觉这就是java程序员带过来的东西。。。先说这个装饰器吧，这里直接用了廖雪峰官网关于@property的介绍中的例子。 在绑定类属性时，如果我们直接把属性暴露出去，虽然写起来很简单，但是，没办法检查参数，比如如下： s = Student() s.score = 9999 如果我们想要限制s.score在一个范围怎么办，作为半个曾经的java程序员，我必然是会用eclipse的右键对这个score属性创建一个getter和setter方法，即在调用的时候不直接s.score，而是用getter方法，在修改的时候不直接赋值，而是用setter方法，从而避免属性暴露。用python 写就是这样子： class Student(object): def get_score(self): return self._score def set_score(self, value): if not isinstance(value, int): raise ValueError(&#39;score must be an integer!&#39;) if value &lt; 0 or value &gt; 100: raise ValueError(&#39;score must between 0 ~ 100!&#39;) self._score = value 但是这样子的话就很麻烦，每一次调用都要手动调用一次get_score函数，每次修改都要手动调用一次set_score函数，当然java这门语言本身就很麻烦所以再麻烦一点也没啥关系了，但是python不一样啊。所以有了这个@property，如下： class Student(object): @property def score(self): return self._score @score.setter def score(self, value): if not isinstance(value, int): raise ValueError(&#39;score must be an integer!&#39;) if value &lt; 0 or value &gt; 100: raise ValueError(&#39;score must between 0 ~ 100!&#39;) self._score = value 把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值。 当然如果这个变量不叫score，比如叫point，那么另一个装饰器自然就变成了@point.setter。 这样子我们就可以这样操作了： &gt;&gt;&gt; s=Student() &gt;&gt;&gt; s.score=50 &gt;&gt;&gt; s.score 50 &gt;&gt;&gt; s.score=1000 Traceback (most recent call last): File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt; s.score=1000 File &quot;&lt;input&gt;&quot;, line 12, in score raise ValueError(&#39;score must between 0 ~ 100!&#39;) ValueError: score must between 0 ~ 100! 所以有了这个@property，我们在对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过getter和setter方法来实现的。 当然python里面除了本文介绍的函数装饰器之外，还有类装饰器，但是个人遇到的较少所以此处不介绍了。 5 关于装饰器的其他内容 在使用装饰器后， 调用函数的__name__和__doc__属性，发现不再是原函数的名称和文档，而是装饰器函数wrapper的名称和文档。为了在装饰后保持原函数的名称和文档，需要在def wrapper()前加上另一个装饰器：@wraps(func)。具体使用方法为：from functools import wraps def my_decorator(func): @wraps(func) def wrapper(*args, **kwargs): &#39;&#39;&#39;decorator&#39;&#39;&#39; print(&#39;Calling decorated function...&#39;) return func(*args, **kwargs) return wrapper wrapper]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有哪些适合新手练手的Java项目]]></title>
    <url>%2F2019%2F07%2F09%2FJava%2F%E9%80%82%E5%90%88%E7%BB%83%E6%89%8B%E7%9A%84Java%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[Java作为一门古老的语言，已有20年左右的历史，这在发展日新月异的技术圈可以说是一个神话。虽然不少人曾抱怨Java语言就像老太太的裹脚布，又臭又长，有时写了500行都不能表达程序员的意图。但从市场上的招聘现状看，Java工程师依然有着其他语言不可取代的竞争优势。 看到了这里，恭喜正式开始进入主题：适合新手练手的Java项目？源码下载（实例一）：jsp开发完整的博研图书馆后台管理系统，不使用框架开发的，太完美了 源码下载（实例二）：javaWeb图书馆管理系统源码mysql版本 源码下载（实例三）GitHub - uboger/LibraryManager: JAVA GUI 图书馆管理系统 源码下载（实例四）：java swing开发企业人事管理系统源代码下载 源码下载（实例一）：java swing开发网络聊天室群聊系统,基于java多线程socket编程 源码下载（实例二）：java swing开发大猫聊天室源码，简单易懂，适合java swing初学者 源码下载（实例三）：java websocket开发简单聊天室系统，实现群聊与一对一单人聊天案例 源码下载（实例四）：jsp开发简单聊天室demo-分享 源码下载（一）：java通讯录实现了添加删除和查找功能 源码下载（二）：JAVA版通讯录管理系统课程设计源码 源码下载（三）：Java Swing界面.完美设计通讯录..有需要的下 源码下载（一）：JAVA坦克大战+源代码（适合初学者） 源码下载（二）：GitHub - wangzhengyi/TankWar: 用J2SE写的一个坦克大战小游戏，巩固一下java基础 源码下载（一）：俄罗斯方块 JAVA版 源码下载（二）：GitHub - FieldSoft-HelloClyde/Tetris-Swing: Swing编写的俄罗斯方块 源码下载（三）：java swing开发的俄罗斯方块游戏，包含完整代码+详细注释 源码下载（一）：Java实践（十一）——五子棋 源码下载（二）：java swing开发的五子棋小游戏源码 源码下载（三）：java swing开发单机版五子棋源代码下载 源码下载（四）：Java五子棋算法和代码 源码下载（一）：Java实践（十二）——中国象棋 源码下载（实例一）：JAVA贪吃蛇源代码 源码下载（实例二）：java swing编写的3个小游戏程序源码，俄罗斯方块，贪吃蛇和坦克大战 源码下载（实例三）：java贪吃蛇源代码 java贪吃蛇源代码.net/yaerfeng/article/details/23254623)]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matplotlib]]></title>
    <url>%2F2019%2F07%2F09%2FPythonPackages%2Fmatplotlib%2F</url>
    <content type="text"><![CDATA[实用网站： https://matplotlib.org/gallery/index.html https://matplotlib.org/index.html 1 画图1.1 直线plt.subplots(1, 1) x= range(100) y= [i**2 for i in x] plt.plot(x, y, linewidth = &#39;1&#39;, label = &quot;test&quot;, color=&#39; coral &#39;, linestyle=&#39;:&#39;, marker=&#39;|&#39;) plt.legend(loc=&#39;upper left&#39;) plt.show() 1.2 平行于坐标轴的直线plt.axvline(x, ymin, ymax) plt.axhline(y, xmin, xmax) 1.3 柱状图plt.figure(4, figsize=(10, 8), dpi=100 mean = [35.886, 20.512, 22.029, 31.130, 42.842] std = [82.987, 65.015, 66.816, 71.533, 74.364] width = 0.2 axislabel = [&#39;10&#39;, &#39;25&#39;, &#39;50&#39;, &#39;75&#39;, &#39;100&#39;] x = list(range(len(mean))) plt.bar(x, mean, width=width, label=&#39;均值&#39;, edgecolor=&#39;black&#39;, facecolor=&#39;white&#39;, hatch=&#39;&#39;) for i in range(len(x)): x[i] = x[i] + width plt.bar(x, std, width=width, label=&#39;标准差&#39;, edgecolor=&#39;black&#39;, facecolor=&#39;white&#39;, hatch=&#39;/&#39;) plt.xticks([(i + width / 2) for i in range(len(axislabel))], axislabel) plt.xlabel(&#39;输入历史窗长&#39;) plt.legend(loc=&#39;upper right&#39;) plt.show()1.4 画热图（Heatmap）Creating annotated heatmaps cmap参数查询 2 图像参数及属性2.1 linestyle参数&#39;-&#39; solid line style &#39;--&#39; dashed line style &#39;-.&#39; dash-dot line style &#39;:&#39; dotted line style2.2 marker参数&#39;.&#39; point marker &#39;,&#39; pixel marker &#39;o&#39; circle marker &#39;v&#39; triangle_down marker &#39;^&#39; triangle_up marker &#39;&lt;&#39; triangle_left marker &#39;&gt;&#39; triangle_right marker &#39;1&#39; tri_down marker &#39;2&#39; tri_up marker &#39;3&#39; tri_left marker &#39;4&#39; tri_right marker &#39;s&#39; square marker &#39;p&#39; pentagon marker &#39;*&#39; star marker &#39;h&#39; hexagon1 marker &#39;H&#39; hexagon2 marker &#39;+&#39; plus marker &#39;x&#39; x marker &#39;D&#39; diamond marker &#39;d&#39; thin_diamond marker &#39;|&#39; vline marker &#39;_&#39; hline marker2.3 color参数&#39;aliceblue&#39;: &#39;#F0F8FF&#39;, &#39;antiquewhite&#39;: &#39;#FAEBD7&#39;, &#39;aqua&#39;: &#39;#00FFFF&#39;, &#39;aquamarine&#39;: &#39;#7FFFD4&#39;, &#39;azure&#39;: &#39;#F0FFFF&#39;, &#39;beige&#39;: &#39;#F5F5DC&#39;, &#39;bisque&#39;: &#39;#FFE4C4&#39;, &#39;black&#39;: &#39;#000000&#39;, &#39;blanchedalmond&#39;: &#39;#FFEBCD&#39;, &#39;blue&#39;: &#39;#0000FF&#39;, &#39;blueviolet&#39;: &#39;#8A2BE2&#39;, &#39;brown&#39;: &#39;#A52A2A&#39;, &#39;burlywood&#39;: &#39;#DEB887&#39;, &#39;cadetblue&#39;: &#39;#5F9EA0&#39;, &#39;chartreuse&#39;: &#39;#7FFF00&#39;, &#39;chocolate&#39;: &#39;#D2691E&#39;, &#39;coral&#39;: &#39;#FF7F50&#39;, &#39;cornflowerblue&#39;: &#39;#6495ED&#39;, &#39;cornsilk&#39;: &#39;#FFF8DC&#39;, &#39;crimson&#39;: &#39;#DC143C&#39;, &#39;cyan&#39;: &#39;#00FFFF&#39;, &#39;darkblue&#39;: &#39;#00008B&#39;, &#39;darkcyan&#39;: &#39;#008B8B&#39;, &#39;darkgoldenrod&#39;: &#39;#B8860B&#39;, &#39;darkgray&#39;: &#39;#A9A9A9&#39;, &#39;darkgreen&#39;: &#39;#006400&#39;, &#39;darkkhaki&#39;: &#39;#BDB76B&#39;, &#39;darkmagenta&#39;: &#39;#8B008B&#39;, &#39;darkolivegreen&#39;: &#39;#556B2F&#39;, &#39;darkorange&#39;: &#39;#FF8C00&#39;, &#39;darkorchid&#39;: &#39;#9932CC&#39;, &#39;darkred&#39;: &#39;#8B0000&#39;, &#39;darksalmon&#39;: &#39;#E9967A&#39;, &#39;darkseagreen&#39;: &#39;#8FBC8F&#39;, &#39;darkslateblue&#39;: &#39;#483D8B&#39;, &#39;darkslategray&#39;: &#39;#2F4F4F&#39;, &#39;darkturquoise&#39;: &#39;#00CED1&#39;, &#39;darkviolet&#39;: &#39;#9400D3&#39;, &#39;deeppink&#39;: &#39;#FF1493&#39;, &#39;deepskyblue&#39;: &#39;#00BFFF&#39;, &#39;dimgray&#39;: &#39;#696969&#39;, &#39;dodgerblue&#39;: &#39;#1E90FF&#39;, &#39;firebrick&#39;: &#39;#B22222&#39;, &#39;floralwhite&#39;: &#39;#FFFAF0&#39;, &#39;forestgreen&#39;: &#39;#228B22&#39;, &#39;fuchsia&#39;: &#39;#FF00FF&#39;, &#39;gainsboro&#39;: &#39;#DCDCDC&#39;, &#39;ghostwhite&#39;: &#39;#F8F8FF&#39;, &#39;gold&#39;: &#39;#FFD700&#39;, &#39;goldenrod&#39;: &#39;#DAA520&#39;, &#39;gray&#39;: &#39;#808080&#39;, &#39;green&#39;: &#39;#008000&#39;, &#39;greenyellow&#39;: &#39;#ADFF2F&#39;, &#39;honeydew&#39;: &#39;#F0FFF0&#39;, &#39;hotpink&#39;: &#39;#FF69B4&#39;, &#39;indianred&#39;: &#39;#CD5C5C&#39;, &#39;indigo&#39;: &#39;#4B0082&#39;, &#39;ivory&#39;: &#39;#FFFFF0&#39;, &#39;khaki&#39;: &#39;#F0E68C&#39;, &#39;lavender&#39;: &#39;#E6E6FA&#39;, &#39;lavenderblush&#39;: &#39;#FFF0F5&#39;, &#39;lawngreen&#39;: &#39;#7CFC00&#39;, &#39;lemonchiffon&#39;: &#39;#FFFACD&#39;, &#39;lightblue&#39;: &#39;#ADD8E6&#39;, &#39;lightcoral&#39;: &#39;#F08080&#39;, &#39;lightcyan&#39;: &#39;#E0FFFF&#39;, &#39;lightgoldenrodyellow&#39;: &#39;#FAFAD2&#39;, &#39;lightgreen&#39;: &#39;#90EE90&#39;, &#39;lightgray&#39;: &#39;#D3D3D3&#39;, &#39;lightpink&#39;: &#39;#FFB6C1&#39;, &#39;lightsalmon&#39;: &#39;#FFA07A&#39;, &#39;lightseagreen&#39;: &#39;#20B2AA&#39;, &#39;lightskyblue&#39;: &#39;#87CEFA&#39;, &#39;lightslategray&#39;: &#39;#778899&#39;, &#39;lightsteelblue&#39;: &#39;#B0C4DE&#39;, &#39;lightyellow&#39;: &#39;#FFFFE0&#39;, &#39;lime&#39;: &#39;#00FF00&#39;, &#39;limegreen&#39;: &#39;#32CD32&#39;, &#39;linen&#39;: &#39;#FAF0E6&#39;, &#39;magenta&#39;: &#39;#FF00FF&#39;, &#39;maroon&#39;: &#39;#800000&#39;, &#39;mediumaquamarine&#39;: &#39;#66CDAA&#39;, &#39;mediumblue&#39;: &#39;#0000CD&#39;, &#39;mediumorchid&#39;: &#39;#BA55D3&#39;, &#39;mediumpurple&#39;: &#39;#9370DB&#39;, &#39;mediumseagreen&#39;: &#39;#3CB371&#39;, &#39;mediumslateblue&#39;: &#39;#7B68EE&#39;, &#39;mediumspringgreen&#39;: &#39;#00FA9A&#39;, &#39;mediumturquoise&#39;: &#39;#48D1CC&#39;, &#39;mediumvioletred&#39;: &#39;#C71585&#39;, &#39;midnightblue&#39;: &#39;#191970&#39;, &#39;mintcream&#39;: &#39;#F5FFFA&#39;, &#39;mistyrose&#39;: &#39;#FFE4E1&#39;, &#39;moccasin&#39;: &#39;#FFE4B5&#39;, &#39;navajowhite&#39;: &#39;#FFDEAD&#39;, &#39;navy&#39;: &#39;#000080&#39;, &#39;oldlace&#39;: &#39;#FDF5E6&#39;, &#39;olive&#39;: &#39;#808000&#39;, &#39;olivedrab&#39;: &#39;#6B8E23&#39;, &#39;orange&#39;: &#39;#FFA500&#39;, &#39;orangered&#39;: &#39;#FF4500&#39;, &#39;orchid&#39;: &#39;#DA70D6&#39;, &#39;palegoldenrod&#39;: &#39;#EEE8AA&#39;, &#39;palegreen&#39;: &#39;#98FB98&#39;, &#39;paleturquoise&#39;: &#39;#AFEEEE&#39;, &#39;palevioletred&#39;: &#39;#DB7093&#39;, &#39;papayawhip&#39;: &#39;#FFEFD5&#39;, &#39;peachpuff&#39;: &#39;#FFDAB9&#39;, &#39;peru&#39;: &#39;#CD853F&#39;, &#39;pink&#39;: &#39;#FFC0CB&#39;, &#39;plum&#39;: &#39;#DDA0DD&#39;, &#39;powderblue&#39;: &#39;#B0E0E6&#39;, &#39;purple&#39;: &#39;#800080&#39;, &#39;red&#39;: &#39;#FF0000&#39;, &#39;rosybrown&#39;: &#39;#BC8F8F&#39;, &#39;royalblue&#39;: &#39;#4169E1&#39;, &#39;saddlebrown&#39;: &#39;#8B4513&#39;, &#39;salmon&#39;: &#39;#FA8072&#39;, &#39;sandybrown&#39;: &#39;#FAA460&#39;, &#39;seagreen&#39;: &#39;#2E8B57&#39;, &#39;seashell&#39;: &#39;#FFF5EE&#39;, &#39;sienna&#39;: &#39;#A0522D&#39;, &#39;silver&#39;: &#39;#C0C0C0&#39;, &#39;skyblue&#39;: &#39;#87CEEB&#39;, &#39;slateblue&#39;: &#39;#6A5ACD&#39;, &#39;slategray&#39;: &#39;#708090&#39;, &#39;snow&#39;: &#39;#FFFAFA&#39;, &#39;springgreen&#39;: &#39;#00FF7F&#39;, &#39;steelblue&#39;: &#39;#4682B4&#39;, &#39;tan&#39;: &#39;#D2B48C&#39;, &#39;teal&#39;: &#39;#008080&#39;, &#39;thistle&#39;: &#39;#D8BFD8&#39;, &#39;tomato&#39;: &#39;#FF6347&#39;, &#39;turquoise&#39;: &#39;#40E0D0&#39;, &#39;violet&#39;: &#39;#EE82EE&#39;, &#39;wheat&#39;: &#39;#F5DEB3&#39;, &#39;white&#39;: &#39;#FFFFFF&#39;, &#39;whitesmoke&#39;: &#39;#F5F5F5&#39;, &#39;yellow&#39;: &#39;#FFFF00&#39;, &#39;yellowgreen&#39;: &#39;#9ACD32&#39;3 图像处理3.1 最大化图像figManager = plt.get_current_fig_manager() figManager.window.showMaximized() 3.2 将图像紧密排布plt.tight_layout() 3.3 在线上标注某个点plt.scatter(x, y, size) 3.4 给线加标签plt.plot([1,2,3], label=&#39;abc&#39;) plt.legend()3.5 坐标轴# 设置X轴和Y轴的说明 plt.xlabel() plt.ylabel() # 设置X轴和Y轴的刻度 plt.xticks() plt.yticks() # 设置范围 plt.xlim(0, 1) plt.ylim(ymin=0) 4 字体修改## 查看可用系统字体 import matplotlib.font_manager print ([f.name for f in matplotlib.font_manager.fontManager.ttflist]) # 修改默认字体为Times New Roman plt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Times New Roman&#39;] plt.rcParams[&#39;axes.unicode_minus&#39;] = False # 单独修改某些部分的字体 chinese_font = &#39;Simsun&#39; ax = plt.gca() # 8 这四个分别为图例、x轴标签、y轴标签和标题 modified_font_list = [ax.legend().texts, ax.xaxis.label, ax.title] plt.setp(modified_font_list, family=chinese_font) 5 图例(legend)plt.legend()可传入的一些参数： fontsize: 字号 labelspacing: label之间的间距 loc:图例的位置 6 figsize和dpi的关系在plt.figure()中，figsize只改变图像的绝对大小不改变图像内元素的大小。而dpi会改变图像中元素的大小，同时改变图像的大小。 7 对ax对象的处理7.1 画子图figure, ax = plt.subplots(2, 1, figsize=(12, 8)) ax[0].plot() ax[1].plot() 7.2 设置axis# 设置label ax.set_xlabel() ax.set_ylabel() # 设置label到坐标轴的距离 ax.xaxis.set_label_coords(-0.0075, 0.5) ax.yaxis.set_label_coords(-0.0075, 0.5) 8 一些常用代码8.1 Gaussian分布拟合# Gaussian distribution simulation xt = plt.xticks()[0] xmin, xmax = min(xt), max(xt) lnspc = np.linspace(xmin, xmax, len(mape_attn)) # 12 lets try the normal distribution first m, s = stats.norm.fit(mape_attn) # get mean and standard deviation pdf_g = stats.norm.pdf(lnspc, m, s) # now get theoretical values in our interval plt.plot(lnspc, pdf_g, label=&quot;高斯分布拟合&quot;, linestyle=&#39;--&#39;) # plot it 8.2 PDF &amp; CDFplt.figure(7, figsize=(18, 9)) mape_attn = (attn_predict - attn_real) / attn_real * 100 mape_lstm = (lstm_predict - lstm_real) / lstm_real * 100 bins = np.arange(-15, 16, 2) bins_axis = [(bins[i] + bins[i + 1]) / 2 for i in range(len(bins) - 1)] plt.subplot(121) hist_attn, _ = np.histogram(mape_attn, bins=bins, density=True) cdf_attn = np.cumsum(hist_attn / sum(hist_attn)) hist_lstm, _ = np.histogram(mape_lstm, bins=bins, density=True) cdf_lstm = np.cumsum(hist_lstm / sum(hist_lstm)) plt.plot(bins_axis, hist_attn, label=&#39;注意力网络&#39;, marker=&#39;^&#39;, markersize=markersize) plt.plot(bins_axis, hist_lstm, label=&#39;GRU网络&#39;, marker=&#39;o&#39;, markersize=markersize) plt.xlabel(&#39;相对百分比误差（%）&#39;) plt.xlim(-15, 15) plt.ylim(ymin=0) plt.title(&#39;PDF&#39;) # Gaussian distribution simulation xt = plt.xticks()[0] xmin, xmax = min(xt), max(xt) lnspc = np.linspace(xmin, xmax, len(mape_attn)) # lets try the normal distribution first m, s = stats.norm.fit(mape_attn) # get mean and standard deviation pdf_g = stats.norm.pdf(lnspc, m, s) # now get theoretical values in our interval plt.plot(lnspc, pdf_g, label=&quot;高斯分布拟合&quot;, linestyle=&#39;--&#39;) # plot it ax = plt.gca() modified_font_list = [ax.xaxis.label, ax.yaxis.label] plt.setp(ax.legend(loc=&#39;upper left&#39;).texts, family=chinese_font, fontsize=legendsize) plt.setp(modified_font_list, family=chinese_font) # Draw cdf figure plt.subplot(122) plt.plot(bins_axis, cdf_attn, label=&#39;注意力网络&#39;, marker=&#39;^&#39;, markersize=markersize) plt.plot(bins_axis, cdf_lstm, label=&#39;GRU网络&#39;, marker=&#39;o&#39;, markersize=markersize) plt.xlabel(&#39;相对百分比误差（%）&#39;) plt.xlim(-15, 15) plt.ylim(ymin=0) plt.title(&#39;CDF&#39;) ax = plt.gca() modified_font_list = [ax.xaxis.label, ax.yaxis.label] plt.setp(ax.legend(loc=&#39;upper left&#39;).texts, family=chinese_font, fontsize=legendsize) plt.setp(modified_font_list, family=chinese_font) plt.tight_layout() plt.show() 9 一些实用步骤9.1 matplotlib加入中文字体 下载相应的中文ttf字体放入matplotlib的font文件夹 在代码中加入plt.rcParams[&#39;font.sans-serif&#39;] = [&#39;SimSun&#39;] 删除C://Username//.matplotlib//文件夹下的字体缓存 9.2 matplotlib画图名称不重复plt.figure(len(plt.get_fignums()) + 1) 10 matplotlib面向对象编程 绘制基本图片 fig = plt.figure(1) axes = fig.add_subplot(111) axes1.plot(range(10)) plt.show() 添加子图fig, ax = plt.subplots(3, 2) 添加标题ax.set_title(&#39;title1&#39;) 修改x/y轴刻度ax.set_xticks(range(len(data)))ax.set_xticklabels(ticklist)ax.set_yticklabels(ticklist) 10.1 放大图像的一部分plt.figure(1, figsize=(16, 8), dpi=100) # Add subplot16 ax1 = plt.subplot(211) ts1 = attn_predict[0: 120 * displayday] / 1e9 ts2 = attn_real[0: 120 * displayday] / 1e9 ax1.plot(ts1, label=&#39;注意力模型预测值&#39;, color=&#39;k&#39;) ax1.plot(ts2, label=&#39;真实值&#39;, linestyle=&#39;--&#39;, color=&#39;k&#39;) plt.xlabel(&#39;时间(30秒)&#39;)ax1.yaxis.set_label_coords(-0.05, 0.5) plt.ylabel(&#39;流量（GByte）&#39;) plt.xlim(0, len(attn_predict[0: 120 * displayday + 100])) # plt.ylim(0,17 ) plt.legend() x1 = 560 x2 = 600 # select y-range for zoomed region y1 = 28 y2 = 35 # Make the zoom-in plot: axins1 = zoomed_inset_axes(ax1, zoom_scale, loc=4) # zoom = 2 axins1.plot(ts1, color=&#39;k&#39;) axins1.plot(ts2, linestyle=&#39;--&#39;, color=&#39;k&#39;) axins1.set_xlim(x1, x2) axins1.set_ylim(y1, y2) plt.xticks(visible=False) plt.yticks(visible=False) mark_inset(ax1, axins1, loc1=2, loc2=4, fc=&quot;none&quot;, ec=&quot;0.5&quot;)]]></content>
      <categories>
        <category>Python Packages</category>
      </categories>
      <tags>
        <tag>matplotlib Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scikit-learn]]></title>
    <url>%2F2019%2F07%2F09%2FPythonPackages%2Fscikit-learn%2F</url>
    <content type="text"><![CDATA[在机器学习和数据挖掘的应用中，scikit-learn是一个功能强大的python包。在数据量不是过大的情况下，可以解决大部分问题。学习使用scikit-learn的过程中，我自己也在补充着机器学习和数据挖掘的知识。这里根据自己学习sklearn的经验，我做一个总结的笔记。另外，我也想把这篇笔记一直更新下去。 1 scikit-learn基础介绍1.1 估计器（Estimator）估计器，很多时候可以直接理解成分类器，主要包含两个函数： fit()：训练算法，设置内部参数。接收训练集和类别两个参数。 predict()：预测测试集类别，参数为测试集。 大多数scikit-learn估计器接收和输出的数据格式均为numpy数组或类似格式。 1.2 转换器（Transformer）转换器用于数据预处理和数据转换，主要是三个方法： fit()：训练算法，设置内部参数。 transform()：数据转换。 fit_transform()：合并fit和transform两个方法。 inverse_transform()：将转换后的数据进行逆转换得到原始数据 1.3 流水线（Pipeline）sklearn.pipeline包 1.3.1 流水线的功能： 跟踪记录各步骤的操作（以方便地重现实验结果） 对各步骤进行一个封装 确保代码的复杂程度不至于超出掌控范围 1.3.2 基本使用方法流水线的输入为一连串的数据挖掘步骤，其中最后一步必须是估计器，前几步是转换器。输入的数据集经过转换器的处理后，输出的结果作为下一步的输入。最后，用位于流水线最后一步的估计器对数据进行分类。 每一步都用元组（ ‘名称’，步骤）来表示。现在来创建流水线。 scaling_pipeline = Pipeline([ (&#39;scale&#39;, MinMaxScaler()), (&#39;predict&#39;, KNeighborsClassifier()) ])1.4 预处理主要在sklearn.preprcessing包下。 规范化： MinMaxScaler :最大最小值规范化 Normalizer :使每条数据各特征值的和为1 StandardScaler :为使各特征的均值为0，方差为1 编码： LabelEncoder ：把字符串类型的数据转化为整型 OneHotEncoder ：特征用一个二进制数字来表示 Binarizer :为将数值型特征的二值化 MultiLabelBinarizer：多标签二值化 1.5 特征1.5.1 特征抽取包：sklearn.feature_extraction 特征抽取是数据挖掘任务最为重要的一个环节，一般而言，它对最终结果的影响要高过数据挖掘算法本身。只有先把现实用特征表示出来，才能借助数据挖掘的力量找到问题的答案。特征选择的另一个优点在于：降低真实世界的复杂度，模型比现实更容易操纵。 一般最常使用的特征抽取技术都是高度针对具体领域的，对于特定的领域，如图像处理，在过去一段时间已经开发了各种特征抽取的技术，但这些技术在其他领域的应用却非常有限。 DictVectorizer： 将dict类型的list数据，转换成numpy array FeatureHasher ： 特征哈希，相当于一种降维技巧 image：图像相关的特征抽取 text： 文本相关的特征抽取 text.CountVectorizer：将文本转换为每个词出现的个数的向量 text.TfidfVectorizer：将文本转换为tfidf值的向量 text.HashingVectorizer：文本的特征哈希 示例 data.png CountVectorize只数出现个数 count.png hash.png TfidfVectorizer：个数+归一化（不包括idf） tfidf(without idf).png 1.5.2 特征选择包：sklearn.feature_selection 特征选择的原因如下： (1)降低复杂度 (2)降低噪音 (3)增加模型可读性 VarianceThreshold： 删除特征值的方差达不到最低标准的特征 SelectKBest： 返回k个最佳特征 SelectPercentile： 返回表现最佳的前r%个特征 单个特征和某一类别之间相关性的计算方法有很多。最常用的有卡方检验（χ2）。其他方法还有互信息和信息熵。 chi2： 卡方检验（χ2） 1.6 降维包：sklearn.decomposition 主成分分析算法（Principal Component Analysis， PCA）的目的是找到能用较少信息描述数据集的特征组合。它意在发现彼此之间没有相关性、能够描述数据集的特征，确切说这些特征的方差跟整体方差没有多大差距，这样的特征也被称为主成分。这也就意味着，借助这种方法，就能通过更少的特征捕获到数据集的大部分信息。 1.7 组合包：*sklearn.ensemble * 组合技术即通过聚集多个分类器的预测来提高分类准确率。 常用的组合分类器方法： (1)通过处理训练数据集。即通过某种抽样分布，对原始数据进行再抽样，得到多个训练集。常用的方法有装袋（bagging）和提升（boosting）。 (2)通过处理输入特征。即通过选择输入特征的子集形成每个训练集。适用于有大量冗余特征的数据集。随机森林（Random forest）就是一种处理输入特征的组合方法。 (3)通过处理类标号。适用于多分类的情况，将类标号随机划分成两个不相交的子集，再把问题变为二分类问题，重复构建多次模型，进行分类投票。 BaggingClassifier： Bagging分类器组合 BaggingRegressor： Bagging回归器组合 AdaBoostClassifier： AdaBoost分类器组合 AdaBoostRegressor： AdaBoost回归器组合 GradientBoostingClassifier：GradientBoosting分类器组合 GradientBoostingRegressor： GradientBoosting回归器组合 ExtraTreeClassifier：ExtraTree分类器组合 ExtraTreeRegressor： ExtraTree回归器组合 RandomTreeClassifier：随机森林分类器组合 RandomTreeRegressor： 随机森林回归器组合 使用举例 AdaBoostClassifier(DecisionTreeClassifier(max_depth=1), algorithm=&quot;SAMME&quot;, n_estimators=200)解释装袋（bagging）：根据均匀概率分布从数据集中重复抽样（有放回），每个自助样本集和原数据集一样大，每个自助样本集含有原数据集大约63%的数据。训练k个分类器，测试样本被指派到得票最高的类。提升（boosting）：通过给样本设置不同的权值，每轮迭代调整权值。不同的提升算法之间的差别，一般是（1）如何更新样本的权值，（2）如何组合每个分类器的预测。其中Adaboost中，样本权值是增加那些被错误分类的样本的权值，分类器C_i的重要性依赖于它的错误率。 Boosting主要关注降低偏差，因此Boosting能基于泛化性能相当弱的学习器构建出很强的集成；Bagging主要关注降低方差，因此它在不剪枝的决策树、神经网络等学习器上效用更为明显。偏差指的是算法的期望预测与真实预测之间的偏差程度，反应了模型本身的拟合能力；方差度量了同等大小的训练集的变动导致学习性能的变化，刻画了数据扰动所导致的影响。 1.7.1 模型评估（度量）包：sklearn.metrics sklearn.metrics包含评分方法、性能度量、成对度量和距离计算。分类结果度量 参数大多是y_true和y_pred。 accuracy_score：分类准确度 condusion_matrix ：分类混淆矩阵 classification_report：分类报告 precision_recall_fscore_support：计算精确度、召回率、f、支持率 jaccard_similarity_score：计算jcaard相似度 hamming_loss：计算汉明损失 zero_one_loss：0-1损失 hinge_loss：计算hinge损失 log_loss：计算log损失 其中，F1是以每个类别为基础进行定义的，包括两个概念：准确率（precision）和召回率（recall）。准确率是指预测结果属于某一类的个体，实际属于该类的比例。召回率是被正确预测为某类的个体，与数据集中该类个体总数的比例。F1是准确率和召回率的调和平均数。 回归结果度量 explained_varicance_score：可解释方差的回归评分函数 mean_absolute_error：平均绝对误差 mean_squared_error：平均平方误差 多标签的度量 coverage_error：涵盖误差 label_ranking_average_precision_score：计算基于排名的平均误差Label ranking average precision (LRAP) 聚类的度量 adjusted_mutual_info_score：调整的互信息评分 silhouette_score：所有样本的轮廓系数的平均值 silhouette_sample：所有样本的轮廓系数 1.8 交叉验证包：sklearn.cross_validation KFold：K-Fold交叉验证迭代器。接收元素个数、fold数、是否清洗 LeaveOneOut：LeaveOneOut交叉验证迭代器 LeavePOut：LeavePOut交叉验证迭代器 LeaveOneLableOut：LeaveOneLableOut交叉验证迭代器 LeavePLabelOut：LeavePLabelOut交叉验证迭代器 LeaveOneOut(n) 相当于 KFold(n, n_folds=n) 相当于LeavePOut(n, p=1)。 LeaveP和LeaveOne差别在于leave的个数，也就是测试集的尺寸。LeavePLabel和LeaveOneLabel差别在于leave的Label的种类的个数。 LeavePLabel这种设计是针对可能存在第三方的Label，比如我们的数据是一些季度的数据。那么很自然的一个想法就是把1,2,3个季度的数据当做训练集，第4个季度的数据当做测试集。这个时候只要输入每个样本对应的季度Label，就可以实现这样的功能。 以下是实验代码，尽量自己多实验去理解。 #coding=utf-8 import numpy as np import sklearnfrom sklearn import cross_validation X = np.array([[1, 2], [3, 4], [5, 6], [7, 8],[9, 10]]) y = np.array([1, 2, 1, 2, 3]) def show_cross_val(method): if method == &quot;lolo&quot;: labels = np.array([&quot;summer&quot;, &quot;winter&quot;, &quot;summer&quot;, &quot;winter&quot;, &quot;spring&quot;]) cv = cross_validation.LeaveOneLabelOut(labels) elif method == &#39;lplo&#39;: labels = np.array([&quot;summer&quot;, &quot;winter&quot;, &quot;summer&quot;, &quot;winter&quot;, &quot;spring&quot;]) cv = cross_validation.LeavePLabelOut(labels,p=2) elif method == &#39;loo&#39;: cv = cross_validation.LeaveOneOut(n=len(y)) elif method == &#39;lpo&#39;: cv = cross_validation.LeavePOut(n=len(y),p=3) for train_index, test_index in cv: print(&quot;TRAIN:&quot;, train_index, &quot;TEST:&quot;, test_index) X_train, X_test = X[train_index], X[test_index] y_train, y_test = y[train_index], y[test_index] print &quot;X_train: &quot;,X_train print &quot;y_train: &quot;, y_train print &quot;X_test: &quot;,X_test print &quot;y_test: &quot;,y_test if __name__ == &#39;__main__&#39;: show_cross_val(&quot;lpo&quot;) 常用方法 train_test_split：分离训练集和测试集（不是K-Fold） cross_val_score：交叉验证评分，可以指认cv为上面的类的实例 cross_val_predict：交叉验证的预测。 1.9 网格搜索包：sklearn.grid_search 网格搜索最佳参数 GridSearchCV：搜索指定参数网格中的最佳参数 ParameterGrid：参数网格 ParameterSampler：用给定分布生成参数的生成器 RandomizedSearchCV：超参的随机搜索 通过best_estimator_.get_params()方法，获取最佳参数。 1.10 多分类、多标签分类包：sklearn.multiclass OneVsRestClassifier：1-rest多分类（多标签）策略 OneVsOneClassifier：1-1多分类策略 OutputCodeClassifier：1个类用一个二进制码表示 示例代码 #coding=utf-8 from sklearn import metrics from sklearn import cross_validation from sklearn.svm import SVC from sklearn.multiclass import OneVsRestClassifier from sklearn.preprocessing import MultiLabelBinarizer import numpy as np from numpy import random X=np.arange(15).reshape(5,3) y=np.arange(5) Y_1 = np.arange(5) random.shuffle(Y_1) Y_2 = np.arange(5) random.shuffle(Y_2) Y = np.c_[Y_1,Y_2] def multiclassSVM(): X_train, X_test, y_train, y_test = cross_validation.train_test_split(X, y, test_size=0.2,random_state=0) model = OneVsRestClassifier(SVC()) model.fit(X_train, y_train) predicted = model.predict(X_test) print predicted def multilabelSVM(): Y_enc = MultiLabelBinarizer().fit_transform(Y) X_train, X_test, Y_train, Y_test = cross_validation.train_test_split(X, Y_enc, test_size=0.2, random_state=0) model = OneVsRestClassifier(SVC()) model.fit(X_train, Y_train) predicted = model.predict(X_test) print predicted if __name__ == &#39;__main__&#39;: multiclassSVM() # multilabelSVM() 上面的代码测试了svm在OneVsRestClassifier的包装下，分别处理多分类和多标签的情况。特别注意，在多标签的情况下，输入必须是二值化的。所以需要MultiLabelBinarizer()先处理。 2 具体模型2.1 朴素贝叶斯（Naive Bayes）包：sklearn.cross_validation 朴素贝叶斯.png 朴素贝叶斯的特点是分类速度快，分类效果不一定是最好的。 GasussianNB：高斯分布的朴素贝叶斯 MultinomialNB：多项式分布的朴素贝叶斯 BernoulliNB：伯努利分布的朴素贝叶斯 所谓使用什么分布的朴素贝叶斯，就是假设P(x_i|y)是符合哪一种分布，比如可以假设其服从高斯分布，然后用最大似然法估计高斯分布的参数。 高斯分布.png 多项式分布.png 伯努利分布.png 3 scikit-learn扩展3.1 概览具体的扩展，通常要继承sklearn.base包下的类。 BaseEstimator： 估计器的基类 ClassifierMixin ：分类器的混合类 ClusterMixin：聚类器的混合类 RegressorMixin ：回归器的混合类 TransformerMixin ：转换器的混合类 关于什么是Mixin（混合类），具体可以看这个知乎链接。简单地理解，就是带有实现方法的接口，可以将其看做是组合模式的一种实现。举个例子，比如说常用的TfidfTransformer，继承了BaseEstimator， TransformerMixin，因此它的基本功能就是单一职责的估计器和转换器的组合。 3.2 创建自己的转换器在特征抽取的时候，经常会发现自己的一些数据预处理的方法，sklearn里可能没有实现，但若直接在数据上改，又容易将代码弄得混乱，难以重现实验。这个时候最好自己创建一个转换器，在后面将这个转换器放到pipeline里，统一管理。 例如《Python数据挖掘入门与实战》书中的例子，我们想接收一个numpy数组，根据其均值将其离散化，任何高于均值的特征值替换为1，小于或等于均值的替换为0。 代码实现： from sklearn.base import TransformerMixin from sklearn.utils import as_float_array class MeanDiscrete(TransformerMixin): #计算出数据集的均值，用内部变量保存该值。 def fit(self, X, y=None): X = as_float_array(X) self.mean = np.mean(X, axis=0) #返回self，确保在转换器中能够进行链式调用（例如调用transformer.fit(X).transform(X)） return self def transform(self, X): X = as_float_array(X) assert X.shape[1] == self.mean.shape[0] return X &gt; self.mean]]></content>
      <categories>
        <category>Python Packages</category>
      </categories>
      <tags>
        <tag>scikit-learn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Keras搭建第一个神经网络]]></title>
    <url>%2F2019%2F07%2F09%2FKeras%2FBuild%20the%20First%20Neural%20Network%2F</url>
    <content type="text"><![CDATA[1 Steps Load Data Define Model Compile Model Fit Model Evaluate Model Tie It All Together 2 Load Data Define a certain random number seed. By doing so, you can get the same result to compare it with other model.Method:import numpy as np np.random.seed(7) We use pima-indians-diabetes.csv as our dataset. To load the .csv data, we use np.loadtxt and split it into input and output section. 3 Define ModelModels in Keras are defined as a sequence of layers.While defining the first layer, we can define the input number with the input_dim argument.In this example, we will use a fully-connected network structure with three layers.Fully connected layers are defined using the Dense class. We can specify: the number of neurons in the layer as the first argument the initialization method as the second argument as init specify the activation function using the activation argument.4 Build the Modeldefine a model class. In this problem, we use a sequential model. So we use a model = keras.sequential() to instantiate the class. And then use the .add method to add layers in the model.We want to add a layer into our model, so we use keras.layers.Dense() to be the parameter of add. The activation function must be in the string form like activation=&#39;relu&#39;. 5 Compile the ModelWhen compiling, we must specify some additional properties required when training the network.We must specify the loss function to use to evaluate a set of weights, the optimizer used to search through different weights for the network and any optional metrics we would like to collect and report during training. 6 Fit the modeluse model.fit() method to define fit parameters like epochs and batch_size. 7 Evaluate the modeluse model.evaluate and a set of X and Y to calculate the model performance. 8 Predictionuse model.fit and a set of X to predict the predicted Y value. 9 Related material https://machinelearningmastery.com/ Keras中文文档 Keras Examples-team/keras/tree/master/examples)]]></content>
      <categories>
        <category>Keras</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《C程序设计语言》读书笔记（七）——输入与输出]]></title>
    <url>%2F2019%2F07%2F09%2FBookNotes%2FThe%20C%20Programming%20Language%2F%E3%80%8AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[7.2 格式化输出利用printf控制输出时，每个控制语句由’%’号8开始，由转换字符结束，在’%’号和控制字符之间可以有下列组成成分： 负号：表示输出内容左对齐 a.b：a表示最小字段宽度，对于右对齐来说，如果最小字段宽度大于输出的字符数，则在左端用相应数量的空格填充，对于右对齐则正好相反；b表示精度，用于指定字符串中要打印的最大字符数和浮点数小数点后的位数例如： char *s = &quot;Hello world!&quot;; printf(&quot;%15.8s&quot;,s);将打印出：（7个空格）Hello wo h或l：h表示将整数作为short类型打印，l表示将整数作为long类型打印 下面列出一些不常见到的转换字符，常见的不再举例： u：无符号十进制数 e/E：double类型的科学计数法 g/G：如果置数小于-4或大于等于精度，则使用%e格式输出，否则使用%f格式输出 p：指针类型 sprintf函数：将输出结果存放到字符数组中，成功则返回字符串的长度。其语法为：int sprintf(char *string, char *format, arg1,arg2);f(char *string, char *format, arg1,arg2);`]]></content>
      <categories>
        <category>Book Notes</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《C程序设计语言》读书笔记（四）——函数与程序结构]]></title>
    <url>%2F2019%2F07%2F09%2FBookNotes%2FThe%20C%20Programming%20Language%2F%E3%80%8AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[4.1 找出某一字符串在一段文本内的位置并返回 int strindex(char s[], char t[]) { int i,j,k; for(i = 0;s[i] != &#39;\0&#39;;i++) //遍历初始位置 { for (j = i,k = 0;t[k] != &#39;\0&#39; &amp;&amp; s[j] == t[k];j++,k++) ; if(k &gt; 0 &amp;&amp; t[k] == &#39;\0&#39;) //t[k] == &#39;\0&#39;表示完全匹配 return i; } return -1; //遍历完成后没有找到匹配的 } 4.4 外部变量或函数的作用域从声明它的地方开始，到其所在的（待编译的的）文件的末尾为结束。如果要在外部变量的定义之前使用该变量，或者外部变量的定义与变量的使用不在同一源文件中，则必须在相应的变量声明中强制性地使用关键字extern. 外部变量定义与声明外部变量的声明英语说明变量的属性（主要是变量的类型），而那两定义除此之外还将引起存储器的分配。一个外部变量只能某个文件中定义一次，而其他文件可以通过extern声明访问它；下面给出变量定理和声明的例子：//变量定义 int sp; double val[MAXVAL]; //要说明数组的大小 //变量声明extern int sp;extern double val[]; ## 4.5 - 头文件的作用 由于一些共同使用的外部变量和函数在不同文件中被使用的时候需要被重新声明，所以可以将这些需要共同使用的变量和函数的 *声明* 放在同一个文件中，在需要用到这些函数的文件中只要将这个文件包含进来就可以直接使用，不必再在每个文件重新声明外部变量和函数。这个包含外部变量和共同使用的函数的文件就叫做头文件，包含头文件的操作叫`#include&lt;a.h&gt;`。一般头文件只会存放外部变量和函数的声明，定义在各个.c文件中实现，因为函数的声明只能出现一次，如果定义放在头文件中，而这个头文件又被多个文件引用，那么容易出现重复定义的问题。 ## 4.6 - 静态变量 声明一个变量为静态变量`static`的作用在于限定该变量的作用区域。如对一个外部变量声明为静态变量表示该变量只能在声明的文件中使用，在其他文件中不能使用该外部变量。对一个函数中的变量声明为静态变量表示该变量只能在该函数的范围内使用。**注意**：在函数中声明的静态变量和函数内部变量的区别是静态变量始终存在于内存中，下次调用时存放在里面的值是上次调用完毕后的值；而内部变量在函数开始时被分配内存，在函数结束后内存被收回，下次调用重新分配内存。 ## 4.9 - 初始化 在不进行人为初始化的情况下，外部变量和静态变量都被初始化为0，而内部变量和寄存器变量没有定义。外部变量和静态变量的初始化必须是 *常量* 表达式。 ## 4.11.2 - 宏替换 宏定义可以带参数，不过要十分注意括号的添加，如`#define square(x) (x)*(x)`中的括号不可省略，否则在计算square(a+1)时会发生错误 ## 4.11.3 - 条件包含 #ifdef 在头文件的编写中，为了防止一个头文件被重复包含在同一个.c文件中，最好使用条件包含格式。 头文件被重复包含情况： 假设 a.h 和 b.h 中有 \#include &quot;c.h&quot;语句，而在 main.c 中出现了\#include &quot;a.h&quot; 和\#include &quot;b.h&quot; 那么 v.h就属于在一个.c 文件中重复引用的情况。这时候就会用到如下格式的语句： ``` c #ifndef B_H #define B_H //declarations #endifendif]]></content>
      <categories>
        <category>Book Notes</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[受限玻尔兹曼机（RBM）&深度信念网络（DBN）]]></title>
    <url>%2F2019%2F07%2F09%2FDeepLearning%2FDBN%2F%E5%8F%97%E9%99%90%E7%8E%BB%E5%B0%94%E5%85%B9%E6%9B%BC%E6%9C%BA%EF%BC%88RBM%EF%BC%89%26%E6%B7%B1%E5%BA%A6%E4%BF%A1%E5%BF%B5%E7%BD%91%E7%BB%9C%EF%BC%88DBN%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1 原理 深度信念网络(Deep Belief Network) 深度学习读书笔记之RBM（限制波尔兹曼机） 2 实现 scikit-learn Tensorflow Pytorchion_pytorch)]]></content>
      <categories>
        <category>RBM</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NLP新的发展方向]]></title>
    <url>%2F2019%2F07%2F09%2FDeepLearning%2FNLP%2FNLP%E5%8F%91%E5%B1%95%E6%96%B0%E6%96%B9%E5%90%91%2F</url>
    <content type="text"><![CDATA[将一些比较新的关于NLP发展方向的博客和文章收集如下 从Word Embedding到Bert模型—自然语言处理中的预训练技术发展史 NLP的巨人肩膀上 NLP的巨人肩膀下 https://lilianweng.github.io/lil-log/2018/06/24/attention-attention.html 放弃幻想，全面拥抱Transformer：自然语言处理三大特征抽取器（CNN/RNN/TF）比较 NLP中的attention机制 从Word Embedding到Bert模型—自然语言处理中的预训练技术发展史 ICLR 2019最佳论文 | ON-LSTM：用有序神经元表达层次结构 Bert时代的创新（应用篇）：Bert在NLP各领域的应用进展 XLNet:运行机制及和Bert的异同比较 15篇论文全面概览BERT压缩方法]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Word2vec]]></title>
    <url>%2F2019%2F07%2F09%2FDeepLearning%2FNLP%2FWord2vec%E8%B5%84%E6%96%99%2F</url>
    <content type="text"><![CDATA[将一些Word2vec资料收集如下 Word embedding word2vec原理(一) CBOW与Skip-Gram模型基础 word2vec原理(二) 基于Hierarchical Softmax的模型 word2vec原理(三) 基于Negative Sampling的模型]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[batch & layer normalization]]></title>
    <url>%2F2019%2F07%2F09%2FDeepLearning%2Fother%20techniques%2Flayer%20normalization%2F</url>
    <content type="text"><![CDATA[Weight Normalization and Layer Normalization Explained Batch Normalization详解]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《C程序设计语言》读书笔记（五）——指针与数组]]></title>
    <url>%2F2019%2F07%2F09%2FBookNotes%2FThe%20C%20Programming%20Language%2F%E3%80%8AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[5.1 指针的概念 声明：int *ip; \\一个指向int类型的指针 基本操作：ip = &amp;x; \\将ip指向x，ip中存放x的地址 b = *ip; \\将ip指向地址的变量中的值取出赋给b取地址符号的优先级高于+-*/和+=等，但与++和–优先级相同，运算顺序从右向左，因此在表示取ip指向的地址里的值并自加时应表示为：(*ip)++ 5.3 指针与数组 当一个指针指向数组的某一个元素时，指针数值加一必然指向数组的下一个元素，无论数组中元素的类型数组的长度是多少。 数组名与指向该数组第一个元素的指针含义相同，即int a[10]; a = &amp;a[0]; *(a+i) = a[i];。但是注意指针是变量，值可更改，数组名是常量，值不可更改。 当数组作为参数传入一个函数中时，实际传入的是指向该数组的指针，因此之前在传入数组的函数定义中使用的a[]等价于*a。 5.4 指针用于地址分配 在进行存储空间的分配和释放时，对于外部来说存放数据的数组名字和容量并不需要知道，只需设置一个静态数组和一个指向数组栈顶的指针，返回指向存储起点的指针即可。 5.5 字符指针char *s为指向一个字符串常量的指针，其实际指向为该字符串首个字符的地址址，可以通过*(s + 1)来访问字符串中的每一个字符，但试图通过s来修改字符串是没有意义的，因为指针指向的字符串是作为常量保存在静态存储区的。如果想要通过类似于*(s + 1) = &#39;A&#39;;的方法来修改字符串，只能通过前面介绍的字符串数组实现。ex: void Strcpy(char *ori,char *des) { while(*des++ = *ori++); //先计算++，再赋值并与&#39;\0&#39;比较，最后des和des自加 } 5.6 指针数组和指向指针的指针 形如char *a[]格式的称为指针数组，数组中的每一个元素为一个char类型的指针，可指向一个字符串或一个字符串数组。以char *a[]为例，下面给出一些指针数组的用法： a[0] = &quot;abcd&quot;; //将指针数组中的第一个元素——一个char类型的指针指向一个字符串&quot;abcd&quot; putchar(*(a[0]+1)); //打印a[0]指向的字符串中的第二个字符 指向指针的指针下面是一个简单的指向指针的指针的例子： int a = 1,b = 2; int *p1 = &amp;a; int *p2 = &amp;b; int *pp1 = &amp;p1; printf(&quot;%d %d %d&quot;,a,*p1,**pp1); //利用三种方法打印变量a的值，结果相同由指针的知识我们知道变量p1中存放的是变量a的地址，变量p2中存放的是变量b的地址。如果我们想用一个变量存放p1或p2的地址，就需要对p1或p2取地址，再放到一个变量里，这种变量就称为指向指针的指针，在上例中为pp1。那么，自然有*pp1 = p1和pp1 = &amp;p1。 如果令*pp1 = p2;，完成的操作是将p2中存放的地址拷贝给p1，这时候p1和p2均指向b，自然有*p1 == *p2，且该值为2。注意：此时pp1仍然指向p1，也就是仍有pp1 = &amp;p1成立，改变的是存储在p1中的值。如果想改变pp1的指向，应该用pp1 = &amp;p2;来表示。在使用这些指向指针的指针时，记住一句话：要想改变一个指针指向的变量，等号左边必须是指针名字；要想改变指针指向变量的值而不是改变指向关系，等号左边必须是对指针取值，即\号。* 5.7 多维数组 个人感觉多维数组和指针数组以及指向指针的指针有异曲同工之处。还是拿一个简单的例子来说说。设有一个二维数组char a[3][10]。容易联想到，这个数组实际上包含3个元素，而每一个元素又是一个长度为10的字符串数组。我们分两个层次分析这个数组： 联想到刚才的指针数组以及前面所学的数组名实际上是一个指向数组首地址的指针，我们发现a[3]实际上就是一个指针数组，a[0]~a[2]是分别指向三个字符串的首地址的指针。这样一来，想要打印出第i个字符串中的第j个字符的代码就显而易见了，有以下三种方法： putchar(a[i - 1][j - 1]); //直接取数组元素，最容易想到的方法 putchar(*(a[i - 1] + j - 1)) //利用指针来取元素，利用数组来取指针 putchar(*(*(a + i - 1) + j - 1)) //这里用指针来取指针数组的元素，感觉是最容易把人绕晕的方法_(:з」∠)_ 再来看a[3]这个指针数组，重复使用刚才提到的数组名实际上是一个指向数组首地址的指针，可以看出a实际上是一个指向指针数组首个元素a[0]的指针，那么我们要想访问这个指针数组中的第i个元素，可以使用*(a + i - 1)完成，也就有了上面的第三种最容易把人绕晕的方法。接下来提供两个有关多维数组和指向指针的指针的例子（写的不完善，仅供参考）ex1： //一个简单的利用指针进行字符串排序的程序 #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define MAXSTRNUM 4 //最大输入数组数 #define MAXSTRLEN 10 //每个数组最大长度 void StringComp(char *[]); int main() { char s[MAXSTRNUM][MAXSTRLEN]; char *q[MAXSTRNUM]; int i; printf(&quot;Please enter %d strings:\n&quot;, MAXSTRNUM); for (i = 0;i &lt; MAXSTRNUM;i++) { scanf(&quot;%s&quot;,*(s + i)); *(q + i) = *(s + i); /*指针数组q的每一个元素指向二维数组的每一个字符串，这里不能直接用s[i]当做指向字符串的指针，因为后面涉及到指针指向地址的交换，s[i]不具有交换功能*/ } StringComp(q); for(i = 0;i &lt; MAXSTRNUM;i++) printf(&quot;%s\n&quot;,*(q + i)); return 0; } void StringComp(char l[]){ int j,k; char *temp; for(j = 0;j &lt; MAXSTRNUM - 1;j++) //冒泡排序法 { for(k = 0;k &lt; MAXSTRNUM - 1 - j;k++) if(strcmp((l + k),*(l + k + 1)) &gt; 0 ) { temp = *(l + k + 1); // 交换指针指向的对象 *(l + k + 1) = *(l + k); *(l + k) = temp; } }} ex2： ``` c //一个可以得到某年第几天的具体日期或某天是当年第几天的程序 #include &lt;stdio.h&gt; int day_of_year(int,int *,int *); void month_day(int,int,int *,int *); int main(int argc, char const *argv[]) { int year,yearday,i,c,monthtemp,daytemp; int temp[4]; int *month,*day; month = &amp;monthtemp; day = &amp;daytemp; printf(&quot;Please enter the year and yearday or the year,month and day:\n&quot;); scanf(&quot;%d,%d,%d,%d&quot;,temp,temp + 1,temp +2,temp + 3); if(*(temp + 3) == 1) { year = temp[0]; yearday = temp[1]; month_day(year,yearday,month,day); printf(&quot;year:%d month:%d day:%d\n&quot;,year,*month,*day ); } else if(*(temp + 3) == 2) { year = temp[0]; month = &amp;temp[1]; day = &amp;temp[2]; printf(&quot;year:%d yearday:%d\n&quot;,year,day_of_year(year,month,day)); } else printf(&quot;Enter wrong~\n&quot;); return 0; } static char daytab[2][13] = { {0,29,28,31,30,31,30,31,31,30,31,30,31}, {0,31,29,31,30,31,30,31,31,30,31,30,31} }; //daytab[][0]被设为0是为了方便计算月份的时候从1开始，符合习惯 int day_of_year(int year,int *month,int *day) { int i,leap,yearday; yearday = *day; leap = year % 4 == 0 &amp;&amp; year % 100 != 0 || year % 400 == 0; //选择是否为闰年，闰年leap = 1 for(i = 1;i &lt; *month;i++) yearday += daytab[leap][i]; //总天数等于当月天数day加上该月份之前的天数之和 return yearday; } void month_day(int year,int yearday,int *month,int *day) { int i,leap; leap = year % 4 == 0 &amp;&amp; year % 100 != 0 || year % 400 == 0; //选择是否为闰年，闰年leap = 1 for(i = 1;yearday &gt; daytab[leap][i];i++) //判断天数是否还大于一个月，若不大于，则返回结果 yearday -= daytab[leap][i]; *month = i; *day = yearday; }5.10 命令行参数 在c程序开始执行时，可以向程序传递命令行参数，我们经常见到的int main(int argc, char const *argv[])就是命令行参数的表示。可以看到，命令行参数包括两个参数：int 类型的argc和char *[]类型的argv。argc用于存放命令行参数的数目，argv是一个指向一系列字符串的数组，用于存放参数。由c语言规定，*argv指向的是启动该程序的程序名，因此argc的值最小为1，自定义参数的存放也从*(argv + 1)开始。同时，argv[argc]的值规定为null，也就是空指针，因此能够存放命令行参数的就只有argv[1]到argv[argc - 1]。在编译时，可以通过IDE选择传递到程序的参数，在Dev-C++中设置方法为菜单栏Execute-&gt;Parameters。相邻参数使用空格分隔。比如，传入a b c，则有argc = 4,*(*argv + 1) = “a”,*(*argv + 2) = “b”,*(*argv + 3) = “c”。 课本中的改写后的find函数实际上就是将一些指定的参数（如-n，-x）传进程序，从而查找并输出相应的行。while(--argc &gt; 0 &amp;&amp; (*++argv)[0] == &#39;-&#39;的含义是：遍历每一个输入参数的第一个字符，判断是否等于’-‘。(*++argv)[0]以二维数组的形式改写就是argv[i + 1][0]。下一行c = *++argv[0]的意思是取下一个字符，由此判断要查找的类型。由于’*‘和’++’是同级运算符，结合顺序是由右向左，而argv[0]是指向一个字符串（第一个字符）的指针，因此自加后该指针指向第二个字符，再用*取出该字符。 5.11 指向函数的指针 这一节出现了一个看上去很奇怪的函数声明：void qsort(void *lineptr[],int left,int right,int (*comp)(void *,void *). 这里面的(*comp)其实就是一个指向函数的指针，这个函数传入两个通用指针类型void *,返回int类型。 函数指针变量的声明、初始化和使用：函数指针的声明和普通函数的声明几乎一样，与普通函数声明唯一区别之处在于函数名是(*comp)而不是comp，这点应该很好理解，因为声明的是一个指向函数的指针。在声明完成后，要让这个函数指针指向一个具体的函数。很显然指向的函数必须与函数指针的输入和返回参数的类型完全一致，这样才能匹配。初始化方法为:comp = &amp;compare，compare为函数名。而使用函数指针的方法为：*comp(a,b)原理很简单，相当于取出指针指向的函数。下面给出一个简单的使用函数指针变量和函数指针类型的程序： #include &lt;stdio.h&gt; void Change(int,int); int main(int argc, char const *argv[]) { int a = 1,b = 2; /*1.定义一个指向函数的指针变量*/ void (*Func1)(int,int); printf(&quot;Exercise1:\n&quot;); Func1 = &amp;Change; //函数指针初始化 (*Func1)(a,b); //注意此处不可以写成*Func1(a,b) /*2.定义一个指向函数的指针变量类型*/ typedef void(*Func2)(int,int); //定义了一个名为Func2的函数指针类型 Func2 func2; //定义一个名为func2的函数指针 func2 = &amp;Change; printf(&quot;Exercise2:\n&quot;); (*func2)(a,b); /*3.将一个指向函数的指针变量传递进一个函数*/ printf(&quot;Exercise3:\n&quot;); void Func3(void (*func3)(int,int),int c,int d) //注意这里传入Func3的函数指针func3相当于声明，不用写形参 { (*func3)(c,d); } Func3(Func1,a,b); /*4.在一个函数中定义一个指向函数的指针类型*/ printf(&quot;Exercise4:\n&quot;); void Func4(Func2 func4,int a, int b) { (*func4)(a,b); } Func4(Func1,a,b); return 0; } void Change(int a,int b) //交换a,b的值并打印 { int i; i = a; a = b; b = i; printf(&quot;a = %d, b = %d\n&quot;,a,b ); }]]></content>
      <categories>
        <category>Book Notes</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《C程序设计语言》读书笔记（六）——结构]]></title>
    <url>%2F2019%2F07%2F09%2FBookNotes%2FThe%20C%20Programming%20Language%2F%E3%80%8AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[6.1结构的初始化只能紧跟在结构类型的变量声明后面，必须对所有结构成员进行初始化，且初始化的值必须为常量。比如 struct abc { int a; int b; } x = {100,200}; 或者 struct abc y = {200,390}; 或者 struct abc z; z.a = 200; z.b = 300; 而不允许 struct abc y; y = {200,300}; 6.2 结构与函数、指针1.在函数中可以调用结构，也可以在一个函数中返回一个结构。这里要注意的是，在函数的声明中如果出现结构的形式，其类型是struct + 结构标记，如struct abc。下面给出课本上两个使用结构的函数： struct point makepoint (int x,int y) //返回类型为struct point { struct point temp; temp.x = x; temp.y = y; return temp; //返回结构时只写结构名即可 } struct point addpoint(struct point p1,struct point p2) //形参为两个struct point类型，返回为struct point类型 { p1.x += p2.x; p1.y += p2.y; return p1; } 2. 结构指针在结构很大的条件下，使用指针方式的结构比普通的结构效率更高。结构指针的定义方式和普通指针类似：struct point *pp;。调用结构成员时可使用两种方法：(*pp).a或pp-&gt;a。个人感觉第二种方法不容易出错，因为运算符.的优先级高于*，所以第一种方法中圆括号不可少，而第二种方法简单直观。实际上，通过查找2.12的运算符优先级表可以看到，-&gt;和.的优先级是最高的，所以在类似于++、*等操作时一定注意括号的使用。 6.5 自引用结构在结构的声明中不能包括结构本身，但是可以包括指向本结构的指针。在下面这个课本例子对于结构的声明中我们可以看到这一点。 /*例6.5 统计单词出现的次数完整版代码*/ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;malloc.h&gt; #define MAXWORDNUM 100 //输入字符串最大数目 #define MAXWORDLEN 10 //输入每个字符串最大长度 struct tnode { char *tword; int num; struct tnode *left; struct tnode *right; }; struct tnode * Addtree(struct tnode *p, char *word) //判断一个单词是否在二叉树中并添加其到合适位置，返回根节点 { if (p == NULL) { p = (struct tnode *)malloc(sizeof(struct tnode)); //分配struct tnode大小的空间 p-&gt;tword = word; p-&gt;num = 1; p-&gt;left = NULL; p-&gt;right = NULL; } else if ((strcmp(p-&gt;tword, word)) == 0) p-&gt;num++; else if ((strcmp(p-&gt;tword, word)) &gt; 0) p-&gt;left = Addtree(p-&gt;left, word); //递归调用 else p-&gt;right = Addtree(p-&gt;right, word); return p; } int Findtree(struct tnode *p,char *word) //查找一个单词是否在二叉树中，找到返回1，否则返回0 { int result = 0; if(p != NULL) { result |= Findtree(p-&gt;left,word); //如果在左子树中找到，左子树的Findtree返回1，和总结果做或运算即可 if(strcmp(p-&gt;tword,word) == 0) result = 1; result |= Findtree(p-&gt;right,word); } return result; } void Printtree(struct tnode *p) //打印整个二叉树 { if (p != NULL) //这里不能使用while，否则会一直循环 { Printtree(p-&gt;left); //递归调用 printf(&quot;word:%10s\t\tnumber:%2d\n&quot;, p-&gt;tword, p-&gt;num); Printtree(p-&gt;right); } } int main(int argc, char const *argv[]) { char *wordarray[MAXWORDNUM]; int i = 0, j,result; char *temp,*tempword; printf(&quot;Please enter all words:\n&quot;); //将所有单词输入进一个字符串指针数组中 do { wordarray[i] = (char*)malloc(MAXWORDLEN * sizeof(char)); //使用gets()输入字符串 gets(wordarray[i]); i++; } while (*wordarray[i - 1] != &#39;\0&#39; &amp;&amp; i &lt; MAXWORDNUM); struct tnode *root; root = NULL; for (j = 0; j &lt; ((*wordarray[i - 1] == &#39;\0&#39; ? i - 1 : i); j++) root = Addtree(root, wordarray[j]); //创建整棵二叉树。注意每一个Addtree的调用返回的是它本身，所以root并不会因此 printf(&quot;Press 1 to find a specific word,press 2 to print all words existed:\n&quot;); temp = (char *)malloc(sizeof(char)); gets(temp); switch(*temp) { case &#39;1&#39;: //选择1：查找某个单词是否在二叉树中 printf(&quot;Please enter the word you want to find:\n&quot;); tempword = (char*)malloc(MAXWORDLEN*sizeof(char)); gets(tempword); result = Findtree(root,tempword); result &gt; 0 ? puts(&quot;Found!&quot;):puts(&quot;Not found!&quot;); break; case &#39;2&#39;: //选择2：打印整棵二叉树 Printtree(root); printf(&quot;\nPrint complete!\n&quot;); break; default: printf(&quot;Input error!\n&quot;); break; } return 0; } 6.6 表查找给出一个课本例题的稍微改动和添加版本，其中包含了hash表的初始化、添加数据、删除和查找功能，也包括使用malloc()和get_s()为字符串指针申请内存以及一些编程中容易出错的地方（花了我快一天啊啊啊效率太低了(╯°口°)╯(┴—┴） //hash表的初始化、添加、删除和查找练习 // ConsoleApplication2.cpp : 定义控制台应用程序的入口点。 // #include &quot;stdafx.h&quot; #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;malloc.h&gt; #define MAXHASHSIZE 20 #define MAXCHARSIZE 20 #define SUCCESS 1 #define FAIL -1 typedef struct tnode { char *tword; int count; }Hashtable; int InitHashtable(Hashtable *[]); int AddToHashtable(Hashtable *[], char*); int DeleteHashtable(Hashtable *[], char *); int FindInHashtable(Hashtable *[], char *); int InitHashtable(Hashtable *root[]); unsigned int CalcHashValue(char *); int InitHashtable(Hashtable *root[]) //初始化hash表，所有字符串指针指向NULL，计数为0 { int i; for (i = 0; i &lt; MAXHASHSIZE; i++) { root[i] = (Hashtable*)malloc(sizeof(Hashtable)); //为字符串指针分配地址 if ((*(root + i))-&gt;tword == NULL) //存储空间满 return FAIL; (*(root + i))-&gt;tword = NULL; (*(root + i))-&gt;count = 0; } return SUCCESS; } int AddToHashtable(Hashtable *root[], char *data) //将一个字符串加入hash表 { unsigned int hashvalue, i = 0; hashvalue = CalcHashValue(data); while ((*(root + hashvalue))-&gt;tword != NULL &amp;&amp; i &lt; MAXHASHSIZE) //欲放入的位置不为空 { if (strcmp((*(root + hashvalue))-&gt;tword, data) == 0) { (*(root + hashvalue))-&gt;count++; break; } else hashvalue = (hashvalue + i) % MAXHASHSIZE; //存放位置加1 i++; } if (i == MAXHASHSIZE) { printf(&quot;Stack full!&quot;); return FAIL; } else { (*(root + hashvalue))-&gt;tword = data; //放入字符串 (*(root + hashvalue))-&gt;count = 1; //计数 return SUCCESS; } } int DeleteHashtable(Hashtable *root[], char *word) //从hash表中删除一个字符串数据 { unsigned int hashvalue; int temp; temp = FindInHashtable(root, word); if (temp == FAIL) { printf(&quot;Cannot delete!\n&quot;); return FAIL; } else { (*(root + temp))-&gt;tword = NULL; //字符串指针指向NULL (*(root + temp))-&gt;count = 0; return SUCCESS; } } int FindInHashtable(Hashtable *root[], char *word) //在hash表中查找某个字符串 { unsigned int hashvalue; int i; hashvalue = CalcHashValue(word); for (i = 0;(*(root + hashvalue))-&gt;tword != NULL &amp;&amp; strcmp((*(root + hashvalue))-&gt;tword, word) != 0 &amp;&amp; i &lt; MAXHASHSIZE; i++) hashvalue = (hashvalue + i) % MAXHASHSIZE; if (i &lt; MAXHASHSIZE &amp;&amp; (*(root + hashvalue))-&gt;tword != NULL) //找到的时候没有循环一次而且不为空指针，说明已经找到 return (hashvalue + i) % MAXHASHSIZE; //返回hash表中位置 else return FAIL; } unsigned int CalcHashValue(char *data) //计算一个字符串hash的值 { int i = 0; unsigned int result = 0; while (*data != &#39;\0&#39;) result = result * 31 + *data++; return result % MAXHASHSIZE; } int main(int argc, char const *argv[]) { char *temp[MAXHASHSIZE]; char *wordtemp; int i = 0, j = 0, k, l; char m; Hashtable *root[MAXHASHSIZE]; //初始化过程 printf(&quot;Please enter all words:\n&quot;); do { *(temp + i) = (char *)malloc(MAXCHARSIZE * sizeof(char)); //为字符串指针分配存储空间 gets_s(*(temp + i),MAXCHARSIZE); i++; } while (**(temp + i - 1) != &#39;\0&#39; &amp;&amp; i &lt; MAXHASHSIZE); if (InitHashtable(root) == SUCCESS) printf(&quot;Initial complete!\n&quot;); else { printf(&quot;Initial fail!\n&quot;); return FAIL; } //添加字符串数据过程 for (j = 0; j &lt; (**(temp + i - 1) == &#39;\0&#39; ? i - 1 : i); j++) { if (l = AddToHashtable(root, *(temp + j)) != SUCCESS) { printf(&quot;Add fail!\n&quot;); return FAIL; } } printf(&quot;Add complete!\n&quot;); //查找，删除或退出 while (1) { printf(&quot;Press 1 to delete a word,press 2 to find a word,press 3 to break:\n&quot;); m = getchar(); getchar(); /*注意注意注意在getchar()获取一个字符后一定要加一个getchar()清楚缓存区， 否则下面的gets_s()会直接从缓存区读取回车号，造成的后果是读取的直接为空字符_(:3」∠)_*/ switch (m) { case &#39;1&#39;: //删除 printf(&quot;Please enter the word you want to delete:\n&quot;); wordtemp = (char*)malloc(MAXCHARSIZE * sizeof(char)); gets_s(wordtemp, MAXCHARSIZE); k = DeleteHashtable(root, wordtemp); if (k == SUCCESS) printf(&quot;Delete successful!\n&quot;); else printf(&quot;Delete fail!\n&quot;); break; case &#39;2&#39;: //查找 printf(&quot;Please enter the word you want to find:\n&quot;); wordtemp = (char*)malloc(MAXCHARSIZE * sizeof(char)); gets_s(wordtemp, MAXCHARSIZE); k = FindInHashtable(root, wordtemp); if (k &gt;= 0 &amp;&amp; k &lt; MAXHASHSIZE) printf(&quot;Found!%s is in the %d place.\n&quot;, (*(root + k))-&gt;tword, k); else if (k == FAIL) printf(&quot;Not found!\n&quot;); else printf(&quot;Error!\n&quot;); break; case &#39;3&#39;: return 0; } } return 0; } 6.7 类型定义格式：typedef 原类型名 新类型名例子： typedef int length; typedef char *string; 定义string为字符串指针类型 typedef struct tnode{} Tree; 定义Tree为struct tnode类型，因此Tree tnode1等价于struct tnode tnode1; typedef struct tnode *pTree; 定义pTree为指向struct tnode类型的指针，因此可用：pTree pTree1; pTree1-&gt;member访问成员变量 typedef int (*Func1)(char*,char*); 定义一个指向函数的指针，这个函数返回char类型，因此可用：Func1 func1; a = (*func1)(str1,str2);来调用这个函数 6.8 共用体共用体（Union）简介 6.9 位字段位字段的作用是将多个对象保存在同一个机器字中，机器字是指计算机一次运算能够同时处理的最大位数，通常所说的32/64位电脑就是指机器字的长度。位字段在一个结构中声明，方式为： //代码引用自：http://blog.csdn.net/lovecodeless/article/details/23270911 struct { unsigned int a : 1; //冒号“:”后的数字为该位字段所占的bit位数 unsigned int b : 3; unsigned int c : 5; }flags; 因此，在对每个字段进行赋值的时候，要注意不能超过定义的最大范围，在上例中范围为0~2^(n-1)更详细的介绍请参考：http://blog.csdn.net/lovecodeless/article/details/23270911]]></content>
      <categories>
        <category>Book Notes</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度信念网络(Deep Belief Network,DBN)]]></title>
    <url>%2F2019%2F07%2F09%2FDeepLearning%2FDBN%2F%E6%B7%B1%E5%BA%A6%E4%BF%A1%E5%BF%B5%E7%BD%91%E7%BB%9C(Deep%20Belief%20Network%2CDBN)%2F</url>
    <content type="text"><![CDATA[1 初识深度信念网络深度信念网络是一个概率生成模型，与传统的判别模型的神经网络相对，生成模型是建立一个观察数据和标签之间的联合分布，对$P(Observation|Label)$和 $P(Label|Observation)$都做了评估，而判别模型仅仅而已评估了后者，也就是$P(Label|Observation)$。DBNs由多个限制玻尔兹曼机（Restricted Boltzmann Machines）层组成，一个典型的网络结构如图1所示。这些网络被“限制”为一个可视层和一个隐层，层间存在连接，但层内的单元间不存在连接。隐层单元被训练去捕捉在可视层表现出来的高阶数据的相关性。 2 需要面对的问题对于在深度神经网络应用传统的BP算法的时候，DBN遇到了以下问题： 需要为训练提供一个有标签的样本集； 学习过程较慢； 不适当的参数选择会导致学习收敛于局部最优解。 Solution：首先，先不考虑最顶构成一个联想记忆（associative memory）的两层，一个DBN的连接是通过自顶向下的生成权值来指导确定的，RBMs就像一个建筑块一样，相比传统和深度分层的sigmoid信念网络，它能易于连接权值的学习。最开始的时候，通过一个非监督贪婪逐层方法去预训练获得生成模型的权值，非监督贪婪逐层方法被Hinton证明是有效的，并被其称为对比分歧（contrastive divergence）。在这个训练阶段，在可视层会产生一个向量v，通过它将值传递到隐层。反过来，可视层的输入会被随机的选择，以尝试去重构原始的输入信号。最后，这些新的可视的神经元激活单元将前向传递重构隐层激活单元，获得h（在训练过程中，首先将可视向量值映射给隐单元；然后可视单元由隐层单元重建；这些新可视单元再次映射给隐单元，这样就获取新的隐单元。执行这种反复步骤叫做吉布斯采样）。这些后退和前进的步骤就是我们熟悉的Gibbs采样，而隐层激活单元和可视层输入之间的相关性差别就作为权值更新的主要依据。训练时间会显著的减少，因为只需要单个步骤就可以接近最大似然学习。增加进网络的每一层都会改进训练数据的对数概率，我们可以理解为越来越接近能量的真实表达。这个有意义的拓展，和无标签数据的使用，是任何一个深度学习应用的决定性的因素。在最高两层，权值被连接到一起，这样更低层的输出将会提供一个参考的线索或者关联给顶层，这样顶层就会将其联系到它的记忆内容。而我们最关心的，最后想得到的就是判别性能，例如分类任务里面。在预训练后，DBN可以通过利用带标签数据用BP算法去对判别性能做调整。在这里，一个标签集将被附加到顶层（推广联想记忆），通过一个自下向上的，学习到的识别权值获得一个网络的分类面。这个性能会比单纯的BP算法训练的网络好。这可以很直观的解释，DBNs的BP算法只需要对权值参数空间进行一个局部的搜索，这相比前向神经网络来说，训练是要快的，而且收敛的时间也少。 3 详细训练算法流程在训练时,Hinton采用了逐层无监督的方法来学习参数。如图3所示，首先把数据向量x和第一层隐藏层作为一个RBM, 训练出这个RBM的参数(连接x和h1的权重, x和h1各个节点的偏置等等), 然后固定这个RBM的参数, 把h1视作可见向量, 把h2视作隐藏向量, 训练第二个RBM, 得到其参数, 然后固定这些参数, 训练h2和h3构成的RBM, 具体的训练算法如下: CD的训练过程中用到了Gibbs 采样，即在训练过程中，首先将可视向量值映射给隐单元，然后用隐层单元重建可视向量，接着再将可视向量值映射给隐单元……反复执行这种步骤。 k-Gibbs的过程如下：其中，P是model distribution，$\hat{P}$是training set distribution.DBN训练算法：DBN运用CD算法逐层进行训练，得到每一层的参数Wi和ci用于初始化DBN，之后再用监督学习算法对参数进行微调。 4 经典网络结构经典的DBN网络结构是由若干层RBM和一层BP组成的一种深层神经网络, 结构如下图4所示。DBN 在训练模型的过程中主要分为两步: 分别单独无监督地训练每一层 RBM 网络,确保特征向量映射到不同特征空间时,都尽可能多地保留特征信息; 在 DBN 的最后一层设置BP网络,接收RBM的输出特征向量作为它的输入特征向量,有监督地训练实体关系分类器.而且每一层 RBM 网络只能确保自身层内的 权值对该层特征向量映射达到最优,并不是对整个 DBN 的特征向量映射达到最优,所以反向传播网络还将错误信息自顶向下传播至每一层 RBM,微调整个 DBN 网络.RBM 网络训练模型的过程可以看作对一个深层 BP 网络权值参数的初始化,使DBN 克服了 BP 网络因随机初始化权值参数而容易陷入局部最优和训练时间长的缺点。上述训练模型中第一步在深度学习的术语叫做预训练，第二步叫做微调。最上面有监督学习的那一层，根据具体的应用领域可以换成任何分类器模型，而不必是BP网络。 5 拓展DBN的灵活性使得它的拓展比较容易。一个拓展就是卷积DBNs(Convolutional Deep Belief Networks(CDBN))。DBN并没有考虑到图像的2维结构信息，因为输入是简单的从一个图像矩阵一维向量化的。而CDBN就是考虑到了这个问题，它利用邻域像素的空域关系，通过一个称为卷积RBM的模型区达到生成模型的变换不变性，而且可以容易得变换到高维图像。DBN并没有明确地处理对观察变量的时间联系的学习上，虽然目前已经有这方面的研究，例如堆叠时间RBMs，以此为推广，有序列学习的dubbed temporal convolutionmachines，这种序列学习的应用，给语音信号处理问题带来了一个让人激动的未来研究方向。目前，和DBN有关的研究包括堆叠自动编码器，它是通过用堆叠自动编码器来替换传统DBN里面的RBM。这就使得可以通过同样的规则来训练产生深度多层神经网络架构，但它缺少层的参数化的严格要求。与DBN不同，自动编码器使用判别模型，这样这个结构就很难采样输入采样空间，这就使得网络更难捕捉它的内部表达。但是，降噪自动编码器却能很好的避免这个问题，并且比传统的DBN更优。它通过在训练过程添加随机的污染并堆叠产生场泛化性能。训练单一的降噪自动编码器的过程和RBM训练生成模型的过程一样。 6 更多资料 深度学习方法：受限玻尔兹曼机RBM（一）基本概念 深度学习方法：受限玻尔兹曼机RBM（二）网络模型 深度学习方法：受限玻尔兹曼机RBM（三）模型求解，Gibbs sampling 深度学习方法：受限玻尔兹曼机RBM（四）对比散度contrastive divergence，C]]></content>
      <categories>
        <category>DBN</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据可视化Seaborn从零开始学习教程（一） 风格选择]]></title>
    <url>%2F2019%2F07%2F09%2FPythonPackages%2Fseaborn%2F%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%20Seaborn%20%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%20%E9%A3%8E%E6%A0%BC%E9%80%89%E6%8B%A9%2F</url>
    <content type="text"><![CDATA[本文转载自数据可视化Seaborn从零开始学习教程（一） 风格选择 最近在做几个项目的数据分析，每次用到seaborn进行可视化绘图的时候总是忘记具体操作。虽然seaborn的官方网站已经详细的介绍了使用方法，但是毕竟是英文，而且查找不是很方便。因此博主想从零开始将seaborn学习一遍，做一个总结，也希望供大家使用参考。 Seaborn 简介seaborn同matplotlib一样，也是 Python 进行数据可视化分析的重要第三方包。但seaborn是在 matplotlib的基础上进行了更高级的 API 封装，使得作图更加容易，图形更加漂亮。 博主并不认为seaborn可以替代matplotlib。虽然seaborn可以满足大部分情况下的数据分析需求，但是针对一些特殊情况，还是需要用到matplotlib的。换句话说，matplotlib更加灵活，可定制化，而seaborn像是更高级的封装，使用方便快捷。 应该把seaborn视为matplotlib的补充，而不是替代物。 Seaborn 学习内容seaborn的学习内容主要包含以下几个部分： 风格管理 绘图风格设置 颜色风格设置 绘图方法 数据集的分布可视化 分类数据可视化 线性关系可视化 结构网格 数据识别网格绘图 本次将主要介绍风格管理的使用。 风格管理 - 绘图风格设置除了各种绘图方式外，图形的美观程度可能是我们最关心的了。将它放到第一部分，因为风格设置是一些通用性的操作，对于各种绘图方法都适用。 让我们先看一个例子。 %matplotlib inline import numpy as np import matplotlib as mpl import matplotlib.pyplot as plt import seaborn as sns np.random.seed(sum(map(ord, &quot;aesthetics&quot;)))我们定义了一个简单的方程来绘制一些偏置的正弦波，用来帮助我们查看不同的图画风格是什么样子的。 def sinplot(flip=1): x = np.linspace(0, 14, 100) for i in range(1, 7): plt.plot(x, np.sin(x + i * .5) * (7 - i) * flip)matplotlib默认参数下绘制结果是这样的： sinplot() 转换为seaborn默认绘图，可以简单的用set()方法。 sns.set() sinplot() Seaborn 将 matplotlib 的参数划分为两个独立的组合。第一组是设置绘图的外观风格的，第二组主要将绘图的各种元素按比例缩放的，以至可以嵌入到不同的背景环境中。 操控这些参数的接口主要有两对方法： 控制风格：axes_style(), set_style() 缩放绘图：plotting_context(), set_context() 每对方法中的第一个方法（axes_style(), plotting_context()）会返回一组字典参数，而第二个方法（set_style(), set_context()）会设置 matplotlib 的默认参数。 Seaborn 的五种绘图风格有五种seaborn的风格，它们分别是：darkgrid, whitegrid, dark, white, ticks。它们各自适合不同的应用和个人喜好。默认的主题是 darkgrid。 sns.set_style(&quot;whitegrid&quot;) data = np.random.normal(size=(20, 6)) + np.arange(6) / 2 sns.boxplot(data=data); sns.set_style(&quot;dark&quot;) sinplot() sns.set_style(&quot;white&quot;) sinplot() sns.set_style(&quot;ticks&quot;) sinplot() 移除轴脊柱white 和 ticks 两个风格都能够移除顶部和右侧的不必要的轴脊柱。通过matplotlib参数是做不到这一点的，但是你可以使用seaborn的despine()方法来移除它们： sinplot() sns.despine() 一些绘图也可以针对数据将轴脊柱进行偏置，当然也是通过调用despine()方法来完成。而当刻度没有完全覆盖整个轴的范围时，trim参数可以用来限制已有脊柱的范围。 f, ax = plt.subplots() sns.violinplot(data=data) sns.despine(offset=10, trim=True); 你也可以通过despine()控制哪个脊柱将被移除。 sns.set_style(&quot;whitegrid&quot;) sns.boxplot(data=data, palette=&quot;deep&quot;) sns.despine(left=True) 临时设置绘图风格虽然来回切换风格很容易，但是你也可以在一个with语句中使用axes_style()方法来临时的设置绘图参数。这也允许你用不同风格的轴来绘图： with sns.axes_style(&quot;darkgrid&quot;): plt.subplot(211) sinplot() plt.subplot(212) sinplot(-1) 覆盖 seaborn 风格元素如果你想定制化seaborn风格，你可以将一个字典参数传递给axes_style()和set_style()的参数rc。而且你只能通过这个方法来覆盖风格定义中的部分参数。 如果你想要看看这些参数都是些什么，可以调用这个方法，且无参数，这将会返回下面的设置： sns.axes_style() {&#39;axes.axisbelow&#39;: True, &#39;axes.edgecolor&#39;: &#39;.8&#39;, &#39;axes.facecolor&#39;: &#39;white&#39;, &#39;axes.grid&#39;: True, &#39;axes.labelcolor&#39;: &#39;.15&#39;, &#39;axes.linewidth&#39;: 1.0, &#39;figure.facecolor&#39;: &#39;white&#39;, &#39;font.family&#39;: [u&#39;sans-serif&#39;], &#39;font.sans-serif&#39;: [u&#39;Arial&#39;, u&#39;DejaVu Sans&#39;, u&#39;Liberation Sans&#39;, u&#39;Bitstream Vera Sans&#39;, u&#39;sans-serif&#39;], &#39;grid.color&#39;: &#39;.8&#39;, &#39;grid.linestyle&#39;: u&#39;-&#39;, &#39;image.cmap&#39;: u&#39;rocket&#39;, &#39;legend.frameon&#39;: False, &#39;legend.numpoints&#39;: 1, &#39;legend.scatterpoints&#39;: 1, &#39;lines.solid_capstyle&#39;: u&#39;round&#39;, &#39;text.color&#39;: &#39;.15&#39;, &#39;xtick.color&#39;: &#39;.15&#39;, &#39;xtick.direction&#39;: u&#39;out&#39;, &#39;xtick.major.size&#39;: 0.0, &#39;xtick.minor.size&#39;: 0.0, &#39;ytick.color&#39;: &#39;.15&#39;, &#39;ytick.direction&#39;: u&#39;out&#39;, &#39;ytick.major.size&#39;: 0.0, &#39;ytick.minor.size&#39;: 0.0}然后，你可以设置这些参数的不同版本了。 sns.set_style(&quot;darkgrid&quot;, {&quot;axes.facecolor&quot;: &quot;.9&quot;}) sinplot() 绘图元素比例有一套的参数可以控制绘图元素的比例。首先，让我们通过set()重置默认的参数： sns.set()有四个预置的环境，按大小从小到大排列分别为：paper, notebook, talk, poster。其中，notebook 是默认的。 sns.set_context(&quot;paper&quot;) sinplot() sns.set_context(&quot;talk&quot;) sinplot() sns.set_context(&quot;poster&quot;) sinplot() 你可以通过使用这些名字中的一个调用set_context()来设置参数，并且你可以通过提供一个字典参数值来覆盖参数。当改变环境时，你也可以独立的去缩放字体元素的大小。 sns.set_context(&quot;notebook&quot;, font_scale=1.5, rc={&quot;lines.linewidth&quot;: 2.5}) sinplot() 同样的，你可以通过嵌入with语句临时的控制绘图的比例。 总结介绍了 Seaborn 的 5 中绘图风格 移除轴脊柱 临时设置绘图风格 覆盖 Seaborn 风格元素 绘图元素比例缩放 下一节将会介绍颜色风格的使用。 关注微信公众号 Python 数据科学，获取 120G 人工智能 学习资料。]]></content>
      <categories>
        <category>Python Packages</category>
      </categories>
      <tags>
        <tag>seaborn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据可视化Seaborn从零开始学习教程（三） 数据分布可视化篇]]></title>
    <url>%2F2019%2F07%2F09%2FPythonPackages%2Fseaborn%2F%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%20Seaborn%20%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89%20%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AF%87%2F</url>
    <content type="text"><![CDATA[本文转载自数据可视化Seaborn从零开始学习教程（三） 数据分布可视化篇 Seaborn 学习大纲seaborn的学习内容主要包含以下几个部分： 风格管理 绘图风格设置 颜色风格设置 绘图方法 数据集的分布可视化 分类数据可视化 线性关系可视化 结构网格 数据识别网格绘图 本次将主要介绍数据集的分布可视化的使用。 数据集分布可视化当处理一个数据集的时候，我们经常会想要先看看特征变量是如何分布的。这会让我们对数据特征有个很好的初始认识，同时也会影响后续数据分析以及特征工程的方法。本篇将会介绍如何使用 seaborn 的一些工具来检测单变量和双变量分布情况。 首先还是先导入需要的模块和数据集。 %matplotlib inline import numpy as np import pandas as pd from scipy import stats, integrate import matplotlib.pyplot as plt import seaborn as sns sns.set(color_codes=True) np.random.seed(sum(map(ord, &quot;distributions&quot;))) 注意：这里的数据集是随机产生的分布数据，由 numpy 生成，数据类型是 ndarray。当然，pandas 的 Series 数据类型也是可以使用的，比如我们经常需要从 DataFrame 表中提取某一特征（某一列）来查看分布情况。 绘制单变量分布在 seaborn 中，快速观察单变量分布的最方便的方法就是使用 distplot() 函数。默认会使用柱状图 (histogram) 来绘制，并提供一个适配的核密度估计(KDE)。 x = np.random.normal(size=100) sns.distplot(x); 直方图（histograms直方图是比较常见的，并且在 matplotlib 中已经存在了 hist 函数。直方图在横坐标的数据值范围内均等分的形成一定数量的数据段（bins），并在每个数据段内用矩形条（bars）显示 y 轴观察数量的方式，完成了对的数据分布的可视化展示。 为了说明这个，我们可以移除 kde plot，然后添加 rug plot（在每个观察点上的垂直小标签）。当然，你也可以使用 rug plot 自带的 rugplot() 函数，但是也同样可以在 distplot 中实现： sns.distplot(x, kde=False, rug=True); 当绘制直方图时，你最需要确定的参数是矩形条的数目以及如何放置它们。distplot()使用了一个简单的规则推测出默认情况下最合适的数量，但是或多或少的对 bins 数量进行一些尝试也许能找出数据的其它特征： sns.distplot(x, bins=20, kde=False, rug=True); 核密度估计（Kernel density estimation）核密度估计可能不被大家所熟悉，但它对于绘制分布的形状是一个非常有用的工具。就像直方图那样，KDE plots 会在一个轴上通过高度沿着其它轴将观察的密度编码。 sns.distplot(x, hist=False, rug=True); 绘制 KDE 比绘制直方图需要更多的计算。它的计算过程是这样的，每个观察点首先都被以这个点为中心的正态分布曲线所替代。 x = np.random.normal(0, 1, size=30) bandwidth = 1.06 * x.std() * x.size ** (-1 / 5.) support = np.linspace(-4, 4, 200) kernels = [] for x_i in x: kernel = stats.norm(x_i, bandwidth).pdf(support) kernels.append(kernel) plt.plot(support, kernel, color=&quot;r&quot;) sns.rugplot(x, color=&quot;.2&quot;, linewidth=3); 然后，这些替代的曲线进行加和，并计算出在每个点的密度值。最终生成的曲线被归一化，以使得曲线下面包围的面积是 1。 density = np.sum(kernels, axis=0) density /= integrate.trapz(density, support) plt.plot(support, density); 我们可以看到，如果我们使用 kdeplot() 函数，我们可以得到相同的曲线。这个函数实际上也被 distplot() 所使用，但是如果你就只想要密度估计，那么 kdeplot() 会提供一个直接的接口更简单的操作其它选项。 sns.kdeplot(x, shade=True); KDE 的带宽参数（bw）控制着密度估计曲线的宽窄形状，有点类似直方图中的 bins 参数的作用。它对应着我们上面绘制的 KDE 的宽度。默认情况下，函数会按照一个通用的参考规则来估算出一个合适的值，但是尝试更大或者更小也可能会有帮助： sns.kdeplot(x) sns.kdeplot(x, bw=.2, label=&quot;bw: 0.2&quot;) sns.kdeplot(x, bw=2, label=&quot;bw: 2&quot;) plt.legend(); 如上所述，高斯 KDE 过程的意味着估计延续了数据集中最大和最小的值。 可以通过cut参数来控制绘制曲线的极值值的距离; 然而，这只影响曲线的绘制方式，而不是曲线如何拟合： sns.kdeplot(x, shade=True, cut=0) sns.rugplot(x); 拟合参数分布你也可以使用distplot()将参数分布拟合到数据集，并可视化地评估其与观察数据的对应程度： x = np.random.gamma(6, size=200) sns.distplot(x, kde=False, fit=stats.gamma); 绘制双变量分布对于双变量分布的可视化也是非常有用的。在 seaborn 中最简单的方法就是使用 joinplot() 函数，它能够创建一个多面板图形来展示两个变量之间的联合关系，以及每个轴上单变量的分布情况。 mean, cov = [0, 1], [(1, .5), (.5, 1)] data = np.random.multivariate_normal(mean, cov, 200) df = pd.DataFrame(data, columns=[&quot;x&quot;, &quot;y&quot;])Scatterplots双变量分布最熟悉的可视化方法无疑是散点图了，在散点图中每个观察结果以 x 轴和 y 轴值所对应的点展示。你可以用 matplotlib 的 plt.scatter 函数来绘制一个散点图，它也是jointplot()函数显示的默认方式。 sns.jointplot(x=&quot;x&quot;, y=&quot;y&quot;, data=df) Hexbin plots直方图 histogram 的双变量类似图被称为 “hexbin” 图，因为它展示了落在六角形箱内的观测量。这种绘图对于相对大的数据集效果最好。它可以通过 matplotlib 的 plt.hexbin 函数使用，也可以作为 jointplot 的一种类型参数使用。它使用白色背景的时候视觉效果最好。 x, y = np.random.multivariate_normal(mean, cov, 1000).T with sns.axes_style(&quot;white&quot;): sns.jointplot(x=x, y=y, kind=&quot;hex&quot;, color=&quot;k&quot;); Kernel density estimation还使用上面描述的核密度估计过程来可视化双变量分布。在 seaborn 中，这种绘图以等高线图展示，并且可以作为 jointplot()的一种类型参数使用。 sns.jointplot(x=&quot;x&quot;, y=&quot;y&quot;, data=df, kind=&quot;kde&quot;); 你也可以用 kdeplot 函数来绘制一个二维的核密度图形。这可以将这种绘图绘制到一个特定的（可能已经存在的）matplotlib 轴上，而jointplot()函数只能管理自己： f, ax = plt.subplots(figsize=(6, 6)) sns.kdeplot(df.x, df.y, ax=ax) sns.rugplot(df.x, color=&quot;g&quot;, ax=ax) sns.rugplot(df.y, vertical=True, ax=ax); 如果你希望让双变量密度看起来更连续，您可以简单地增加 n_levels 参数增加轮廓级数： f, ax = plt.subplots(figsize=(6, 6)) cmap = sns.cubehelix_palette(as_cmap=True, dark=0, light=1, reverse=True) sns.kdeplot(df.x, df.y, cmap=cmap, n_levels=60, shade=True); jointplot()函数使用JointGrid来管理图形。为了获得更多的灵活性，您可能需要直接使用JointGrid绘制图形。jointplot()在绘制后返回 JointGrid 对象，你可以用它来添加更多层或调整可视化的其他方面： g = sns.jointplot(x=&quot;x&quot;, y=&quot;y&quot;, data=df, kind=&quot;kde&quot;, color=&quot;m&quot;) g.plot_joint(plt.scatter, c=&quot;w&quot;, s=30, linewidth=1, marker=&quot;+&quot;) g.ax_joint.collections[0].set_alpha(0) g.set_axis_labels(&quot;$X$&quot;, &quot;$Y$&quot;); 可视化数据集成对关系为了绘制数据集中多个成对的双变量，你可以使用 pairplot() 函数。这创建了一个轴矩阵，并展示了在一个 DataFrame 中每对列的关系。默认情况下，它也绘制每个变量在对角轴上的单变量。 iris = sns.load_dataset(&quot;iris&quot;) sns.pairplot(iris); 就像 joinplot() 和 JoinGrid 之间的关系，pairplot() 函数建立在 PairGrid 对象之上，直接使用可以更灵活。 g = sns.PairGrid(iris) g.map_diag(sns.kdeplot) g.map_offdiag(sns.kdeplot, cmap=&quot;Blues_d&quot;, n_levels=6); /Users/mwaskom/anaconda/lib/python2.7/site-packages/matplotlib/axes/_axes.py:545: UserWarning: No labelled objects found. Use label=&#39;...&#39; kwarg on individual plots. warnings.warn(&quot;No labelled objects found. &quot; 参考：http://seaborn.pydata.org/tut… 关注微信公众号 Python 数据科学，获取 120G 人工智能 学习资料。]]></content>
      <categories>
        <category>Python Packages</category>
      </categories>
      <tags>
        <tag>seaborn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据可视化Seaborn从零开始学习教程（四） 分类数据可视化篇]]></title>
    <url>%2F2019%2F07%2F09%2FPythonPackages%2Fseaborn%2F%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%20Seaborn%20%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89%20%E5%88%86%E7%B1%BB%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AF%87%2F</url>
    <content type="text"><![CDATA[本文转载自数据可视化Seaborn从零开始学习教程（四） 分类数据可视化篇 Seaborn 学习大纲seaborn的学习内容主要包含以下几个部分： 风格管理 绘图风格设置 颜色风格设置 绘图方法 数据集的分布可视化 分类数据可视化 线性关系可视化 结构网格 数据识别网格绘图 本次将主要介绍分类数据可视化的使用。 分类数据可视化数据集中的数据类型有很多种，除了连续的特征变量之外，最常见的就是类目型的数据类型了，常见的比如人的性别，学历，爱好等。这些数据类型都不能用连续的变量来表示，而是用分类的数据来表示。 seaborn针对分类型的数据有专门的可视化函数，这些函数可大致分为三种： 分类数据散点图： swarmplot(), stripplot() 分类数据的分布图： boxplot(), violinplot() 分类数据的统计估算图 ： barplot(), pointplot() 这三类函数可有特点，可以从各个方面展示分类数据的可视化效果，下面我们一一介绍。首先的首先还是先导入需要的模块和数据集。 %matplotlib inline import numpy as np import pandas as pd import matplotlib as mpl import matplotlib.pyplot as plt import seaborn as sns sns.set(style=&quot;whitegrid&quot;, color_codes=True) np.random.seed(sum(map(ord, &quot;categorical&quot;))) titanic = sns.load_dataset(&quot;titanic&quot;) tips = sns.load_dataset(&quot;tips&quot;) iris = sns.load_dataset(&quot;iris&quot;)分类数据散点图在分类数据的基础上展示定量数据的最简单函数就是 stripplot()。 sns.stripplot(x=&quot;day&quot;, y=&quot;total_bill&quot;, data=tips); 这看上去类似散点图，但不同的是，横坐标是分类的数据，只不过一些数据点上会互相重叠，不便于观察。所以一个简单的解决办法是加入jitter参数，调整横坐标位置。 sns.stripplot(x=&quot;day&quot;, y=&quot;total_bill&quot;, data=tips, jitter=True); 当然，还有一个不同的方法就是使用 swarmplot() 函数，这个函数的好处就是所有的点都不会重叠，这样可以很清晰的观察到数据的分布。 sns.swarmplot(x=&quot;day&quot;, y=&quot;total_bill&quot;, data=tips); 在这基础上，也可以通过 hue 参数加入另一个嵌套的分类变量，而且嵌套的分类变量可以以不同的颜色区别，十分方便。 sns.swarmplot(x=&quot;day&quot;, y=&quot;total_bill&quot;, hue=&quot;sex&quot;, data=tips); 通常情况下，seaborn 还会尝试推断出分类变量的顺序。如果你的数据是 pandas 的分类数据类型，那么就是使用默认的分类数据顺序，如果是其他的数据类型，字符串类型的类别将按照它们在 DataFrame 中显示的顺序进行绘制，但是数组类别将被排序： sns.swarmplot(x=&quot;size&quot;, y=&quot;total_bill&quot;, data=tips); 有时候将分类变量放在垂直轴上是非常有用的（当类别名称相对较长或有很多类别时，这一点特别有用）。 可以使用 orient 关键字强制定向，但通常可以互换 x 和 y 的变量的数据类型来完成： sns.swarmplot(x=&quot;total_bill&quot;, y=&quot;day&quot;, hue=&quot;time&quot;, data=tips); 分类数据分布图虽然分类的散点图很有用，但有时候想要快速查看各分类下的数据分布就不是很直观了。为此，第二种函数解决了这个问题。 箱型图通过箱型图可以很直观的观察到数据的四分位分布（1/4 分位，中位数，3/4 分位，以及四分位距），这种可视化对于在机器学习的预处理阶段（尤其是发现数据异常离散值）十分有效。 sns.boxplot(x=&quot;day&quot;, y=&quot;total_bill&quot;, hue=&quot;time&quot;, data=tips); 对于箱型图来说，使用 hue 参数的假设是这个变量嵌套在 x 或者 y 轴内。所以默认的情况下，hue 变量的不同类型值会保持偏置状态（两类或几类数据共同在 x 轴数据类型的一个类中），就像上面那个图所示。但是如果 hue 所使用的变量不是嵌套的，那么你可以使用 dodge 参数来禁止这个默认的偏置状态。 tips[&quot;weekend&quot;] = tips[&quot;day&quot;].isin([&quot;Sat&quot;, &quot;Sun&quot;]) sns.boxplot(x=&quot;day&quot;, y=&quot;total_bill&quot;, hue=&quot;weekend&quot;, data=tips, dodge=False); 提琴图另一种不同的方法是 violinplot() 函数，它结合了箱体图和分布教程中描述的核心密度估计过程： sns.violinplot(x=&quot;total_bill&quot;, y=&quot;day&quot;, hue=&quot;time&quot;, data=tips); 这种方法使用核密度估计来更好地描述值的分布。此外，小提琴内还显示了箱体四分位数和四分位距。由于小提琴使用 KDE，还有一些其他可以调整的参数，相对于简单的 boxplot 增加了一些复杂性： sns.violinplot(x=&quot;total_bill&quot;, y=&quot;day&quot;, hue=&quot;time&quot;, data=tips, bw=.1, scale=&quot;count&quot;, scale_hue=False); 当 hue 的嵌套类型只有两类的时候，也可以使用 split 参数将小提琴分割： sns.violinplot(x=&quot;day&quot;, y=&quot;total_bill&quot;, hue=&quot;sex&quot;, data=tips, split=True); 在提琴图内，也可以使用 inner 参数以横线的形式来展示每个观察点的分布，来代替箱型的整体分布： sns.violinplot(x=&quot;day&quot;, y=&quot;total_bill&quot;, hue=&quot;sex&quot;, data=tips, split=True, inner=&quot;stick&quot;, palette=&quot;Set3&quot;); 还有一点比较好的是，可以将 swarmplot()，violinplot()，或 boxplot() 混合使用，这样可以结合多种绘图的特点展示更完美的效果。 sns.violinplot(x=&quot;day&quot;, y=&quot;total_bill&quot;, data=tips, inner=None) sns.swarmplot(x=&quot;day&quot;, y=&quot;total_bill&quot;, data=tips, color=&quot;w&quot;, alpha=.5); 分类数据统计估计图有时候，我们不想展示分类数据下的分布，而是想展示每一类的集中趋势。seaborn 有两个主要的方法来展示这个，并且这些函数 api 与上面函数的用法是一样的。条形图我们最熟悉的方式就是使用一个条形图。 在 Seaborn 中 barplot() 函数会在整个数据集上显示估计，默认情况下使用均值进行估计。 当在每个类别中有多个类别时（使用了 hue），它可以使用引导来计算估计的置信区间，并使用误差条来表示置信区间： sns.barplot(x=&quot;sex&quot;, y=&quot;survived&quot;, hue=&quot;class&quot;, data=titanic); 条形图的特殊情况是当您想要显示每个类别的数量，而不是计算统计量。这有点类似于一个分类而不是定量变量的直方图。在 Seaborn 中，使用 countplot() 函数很轻易的完成： sns.countplot(x=&quot;deck&quot;, data=titanic, palette=&quot;Greens_d&quot;); 如果将要计数的变量移动到 y 轴上，那么条形就会横过来显示： sns.countplot(y=&quot;deck&quot;, hue=&quot;class&quot;, data=titanic, palette=&quot;Greens_d&quot;); 点图 pointplot() 函数提供了估计可视化的另一种风格。该函数会用高度估计值对数据进行描述，而不是显示一个完整的条形，它只绘制点估计和置信区间。另外，点图连接相同 hue 类别的点，比如 male 中的蓝色会连接 female 中的蓝色。这使得很容易看出主要关系如何随着第二个变量的变化而变化，因为你的眼睛可以很好地辨别斜率的差异： sns.pointplot(x=&quot;sex&quot;, y=&quot;survived&quot;, hue=&quot;class&quot;, data=titanic); 为了使能够更好的显示，可以使用不同的标记和线条样式来展示不同 hue 类别的层次: sns.pointplot(x=&quot;class&quot;, y=&quot;survived&quot;, hue=&quot;sex&quot;, data=titanic, palette={&quot;male&quot;: &quot;g&quot;, &quot;female&quot;: &quot;m&quot;}, markers=[&quot;^&quot;, &quot;o&quot;], linestyles=[&quot;-&quot;, &quot;--&quot;]); 绘制 “宽格式” 数据虽然使用 “长格式” 或“整洁”数据是优选的，但是这些函数也可以应用于各种格式的 “宽格式” 数据，包括 pandas DataFrame 或二维 numpy 数组阵列。这些对象应该直接传递给数据参数： sns.boxplot(data=iris, orient=&quot;h&quot;); 此外，这些函数也接受 Pandas 或 numpy 对象的向量，而不仅仅是 DataFrame 中的变量： sns.violinplot(x=iris.species, y=iris.sepal_length); 为了控制由上述函数制作的图形的大小和形状，你必须使用 matplotlib 命令自己设置图形。 当然，这也意味着这些图块可以和其他种类的图块一起在一个多面板的绘制中共存： f, ax = plt.subplots(figsize=(7, 3)) sns.countplot(y=&quot;deck&quot;, data=titanic, color=&quot;c&quot;); 绘制多层面板分类图正如我们上面提到的，有两种方法可以在 Seaborn 中绘制分类图。与回归图中的二元性相似，您可以使用上面介绍的函数，也可以使用更高级别的函数 factorplot()，将这些函数与 FacetGrid() 相结合，通过这个图形的更大的结构来增加展示其他类别的能力。 默认情况下，factorplot() 产生一个 pairplot()： sns.factorplot(x=&quot;day&quot;, y=&quot;total_bill&quot;, hue=&quot;smoker&quot;, data=tips); 但是，kind 参数可以让你选择以上讨论的任何种类的图： sns.factorplot(x=&quot;day&quot;, y=&quot;total_bill&quot;, hue=&quot;smoker&quot;, data=tips, kind=&quot;bar&quot;); 使用 factorplot() 的主要优点是可以很容易使用 “facet” 绘制多面图，展示更多其他分类变量： sns.factorplot(x=&quot;day&quot;, y=&quot;total_bill&quot;, hue=&quot;smoker&quot;, col=&quot;time&quot;, data=tips, kind=&quot;swarm&quot;); 任何一种图形都可以画出来。由于 FacetGrid 的工作原理，要更改图形的大小和形状，需要指定适用于每个图的 size 和 aspect 参数： sns.factorplot(x=&quot;time&quot;, y=&quot;total_bill&quot;, hue=&quot;smoker&quot;, col=&quot;day&quot;, data=tips, kind=&quot;box&quot;, size=4, aspect=.5); 你也可以直接使用 boxplot() 和 FacetGrid 来制作这个图。但是，必须特别注意确保每个图的分类变量的顺序需要被强制，或者是使用具有 Categorical 数据类型的数据或通过命令和 hue_order。 sns.factorplot(x=&quot;time&quot;, y=&quot;total_bill&quot;, hue=&quot;smoker&quot;,hue_order=[&quot;No&quot;,&quot;Yes&quot;] ,col=&quot;day&quot;, data=tips, kind=&quot;box&quot;, size=4, aspect=.5, palette=&quot;Set3&quot;); 由于广义 API 函数的存在，分类数据也可以很容易应用于其他更复杂的上下文。 例如，它们可以轻松地与 PairGrid 结合，以显示多个不同变量之间的分类关系： g = sns.PairGrid(tips, x_vars=[&quot;smoker&quot;, &quot;time&quot;, &quot;sex&quot;], y_vars=[&quot;total_bill&quot;, &quot;tip&quot;], aspect=.75, size=3.5) g.map(sns.violinplot, palette=&quot;pastel&quot;); 参考：http://seaborn.pydata.org/tut… 关注微信公众号 Python 数据科学，获取 120G 人工智能 学习资料。]]></content>
      <categories>
        <category>Python Packages</category>
      </categories>
      <tags>
        <tag>seaborn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据可视化Seaborn从零开始学习教程（二） 颜色调控篇]]></title>
    <url>%2F2019%2F07%2F09%2FPythonPackages%2Fseaborn%2F%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%20Seaborn%20%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89%20%E9%A2%9C%E8%89%B2%E8%B0%83%E6%8E%A7%E7%AF%87%2F</url>
    <content type="text"><![CDATA[本文转载自数据可视化Seaborn从零开始学习教程（二） 颜色调控篇 Seaborn 学习大纲seaborn的学习内容主要包含以下几个部分： 风格管理 绘图风格设置 颜色风格设置 绘图方法 数据集的分布可视化 分类数据可视化 线性关系可视化 结构网格 数据识别网格绘图 本次将主要介绍颜色调控的使用。 颜色风格设置在Seaborn的使用中，是可以针对数据类型而选择合适的颜色，并且使用选择的颜色进行可视化，节省了大量的可视化的颜色调整工作。 还是一样，在介绍如何使用颜色外观设置之前，我们引入所需要的模块。 %matplotlib inline import numpy as np import seaborn as sns import matplotlib.pyplot as plt sns.set(rc={&quot;figure.figsize&quot;: (6, 6)}) np.random.seed(sum(map(ord, &quot;palettes&quot;)))下面所有操作均在 Jupyter notebook 中执行，如果对这个软件还不熟悉的朋友可以参考：Jupyter notebook 快速入门教程 建立调色板对于不连续的外观颜色设置而言，最重要的函数恐怕要属color_palette了。这个函数拥有许多方法，让你可以随心所欲的可以生成各种颜色。并且，它可以被任何有palette参数的函数在内部进行使用（palette的中文意思是 “调色板”）。 关于这个函数有几个点需要知道一下： color_palette函数可以接受任何seaborn或者matplotlib颜色表中颜色名称（除了jet），也可以接受任何有效的matplotlib形式的颜色列表（比如RGB元组，hex颜色代码，或者HTML颜色名称）。 这个函数的返回值总是一个由 RGB 元组组成的列表，无参数调用color_palette函数则会返回当前默认的色环的列表。 还有一个相应的函数，是set_palette，它接受与color_palette一样的参数，并会对所有的绘图的默认色环进行设置。当然，你也可以在with语句中使用color_palette来临时的改变默认颜色。 通常，在不知道数据特点的情况下，要找出并知道哪组颜色对一组数据是最好的有点不太现实。因此，我们将分为多种方式来使用color_palette函数和其它的 seaborn paletee 函数。 有三种通用的color palette可以使用，它们分别是：qualitative，sequential，diverging。 1. 分类色板（quanlitative）Qualitative调色板，也可以说成是 类型 调色板，因为它对于分类数据的显示很有帮助。当你想要区别 不连续的且内在没有顺序关系的 数据时，这个方式是最好的。 当导入seaborn时，默认的色环就被改变成一组包含 6 种颜色的调色板，它使用了标准的matplolib色环，为了让绘图变得更好看一些。 current_palette = sns.color_palette() sns.palplot(current_palette) 有 6 种不同的默认主题，它们分别是：deep，muted，pastel，birght，dark，colorblind。 themes = [&#39;deep&#39;, &#39;muted&#39;, &#39;pastel&#39;, &#39;bright&#39;, &#39;dark&#39;, &#39;colorblind&#39;] for theme in themes: current_palette = sns.color_palette(theme) sns.palplot(current_palette) 使用色圈系统默认的 6 种颜色看上去真不错，但是如果我们想要超过 6 种颜色呢？ 当你有超过 6 种类型的数据要区分时，最简单的方法就是 在一个色圈空间内使用均匀分布的颜色。这也是当需要使用更多颜色时大多数seaborn函数的默认方式。 最常用的方法就是使用 hls 色空间，它是一种简单的RGB值的转换。 sns.palplot(sns.color_palette(&quot;hls&quot;, 8)) 除此之外，还有一个 hls_palette 函数，它可以让你控制 hls 颜色的亮度和饱和度。 sns.palplot(sns.hls_palette(8, l=.3, s=.8)) 然而，由于人类视觉系统工作的原因，根据 RGB 颜色产生的平均视觉强度的颜色，从视觉上看起来并不是相同的强度。如果你观察仔细，就会察觉到，黄色和绿色会更亮一些，而蓝色则相对暗一些。因此，如果你想用hls系统达到一致性的效果，就会出现上面的问题。 为了修补这个问题，seaborn给hls系统提供了一个接口，可以让操作者简单容易的选择均匀分布，且亮度和饱和度看上去明显一致的色调。 sns.palplot(sns.color_palette(&quot;husl&quot;, 8)) 同样与之对应的，也有个husl_palette函数提供更灵活的操作。 使用分类 Color Brewer 调色板另外一种对分类数据比较友好的调色板来自Color Brewer工具。在matplotlib中也存在这些颜色表，但是它们并没有被合适的处理。在seaborn中，当你想要分类的 Color Brewer 调色板的时候，你总是可以得到不连续颜色，但是这也意味着在某一点上，这些颜色将会开始循环。 Color Brewer 网站中的一个很好的特点就是它提供了一个色盲安全指导。色盲颜色有很多种 http://en.wikipedia.org/wiki/Color_blindness，但是最常见的当属辨别绿色和红色。如果可以避免使用红色和绿色来对绘图元素上色，那么对于一些色盲人群将会是一个很好的消息。 下面两组颜色就是使用红色和绿色组合，这可能并不是最好的选择。 sns.palplot(sns.color_palette(&quot;Paired&quot;)) sns.palplot(sns.color_palette(&quot;Set2&quot;, 10)) 为了避免这些组合，我们需要从Color Brewer库中进行选择调色，有一个专门的 choose_colorbrewer_palette 函数可以实现这个功能。这个函数需要在 IPython notebook 中使用，因为 notebook 是一个交互式的工具，可以让你浏览各种选择并且调节参数。 sns_tpye = [&quot;qualitative&quot;, &quot;sequential&quot;, &quot;diverging&quot;] for elem in sns_type: sns.choose_colorbrewer_palette(elem) n：调节颜色的个数； desat：调节明暗和饱和度； 当然，您可能只想使用一组您特别喜欢的颜色。因为 color_palette() 接受一个颜色列表，这很容易做到。 flatui = [&quot;#9b59b6&quot;, &quot;#3498db&quot;, &quot;#95a5a6&quot;, &quot;#e74c3c&quot;, &quot;#34495e&quot;, &quot;#2ecc71&quot;] sns.palplot(sns.color_palette(flatui)) 使用 xkcd 颜色来命名颜色在众多的努力帮助下，xkcd 完成了随机的 RGB 颜色的命名。一共生成了 954 个颜色 http://xkcd.com/color/rgb/，并可可以随时通过xkcd_rgb字典调用。 plt.plot([0, 1], [0, 1], sns.xkcd_rgb[&quot;pale red&quot;], lw=3) plt.plot([0, 1], [0, 2], sns.xkcd_rgb[&quot;medium green&quot;], lw=3) plt.plot([0, 1], [0, 3], sns.xkcd_rgb[&quot;denim blue&quot;], lw=3); 如果想要从 xkcd_rgb 字典中单独的抽取出一些颜色，你也可以将一组选择好的颜色放到 xkcd_palette 函数中。 colors = [&quot;windows blue&quot;, &quot;amber&quot;, &quot;greyish&quot;, &quot;faded green&quot;, &quot;dusty purple&quot;] sns.palplot(sns.xkcd_palette(colors)) 2. 连续色板（sequential）调色板的第二大类被成为 “顺序”，这种调色板对于有从低（无意义）到高（有意义）范围过度的数据非常适合。尽管有些时候你可能想要在连续色板中使用不连续颜色，但是更通用的情况下是连续色板会作为颜色表在 kdeplot() 或者 corrplot() 或是一些 matplotlib 的函数中使用。 对于连续的数据，最好是使用那些在色调上有相对细微变化的调色板，同时在亮度和饱和度上有很大的变化。这种方法将自然地将数据中相对重要的部分成为关注点。 Color Brewer 的字典中就有一组很好的调色板。它们是以在调色板中的主导颜色 (或颜色) 命名的。 sns.palplot(sns.color_palette(&quot;Blues&quot;)) 就像在 matplotlib 中一样，如果您想要翻转渐变，您可以在面板名称中添加一个_r后缀。 sns.palplot(sns.color_palette(&quot;BuGn_r&quot;)) seaborn 还增加了一个允许创建没有动态范围的 “dark” 面板。如果你想按顺序画线或点，这可能是有用的，因为颜色鲜艳的线可能很难区分。 类似的，这种暗处理的颜色，需要在面板名称中添加一个_d后缀。 sns.palplot(sns.color_palette(&quot;GnBu_d&quot;)) 注意，你可能想使用 choose_colorbrewer_palette() 函数取绘制各种不同的选项。如果你想返回一个变量当做颜色映射传入 seaborn 或 matplotlib 的函数中，可以设置 as_cmap 参数为True。 “cubehelix” 连续调色板cubehelix调色板系统在亮度和色变变化上具有线性上升或下降的特点。这意味着，当颜色表中的信息被转化为黑色和白色或者被一个色盲者看到的时候，它将会被保存下来。 matplotlib 有内建的默认 cubehelix 版本： sns.palplot(sns.color_palette(&quot;cubehelix&quot;, 8)) seaborn 为 cubehelix 系统添加一个接口使得其可以在各种变化中都保持良好的亮度线性梯度。 通过 seaborn 的 cubehelix_palette() 函数返回的调色板与 matplotlib 默认值稍有所不同，它不会在色轮周围旋转或覆盖更广的强度范围。seaborn 还改变了排序使得更重要的值显得更暗： sns.palplot(sns.cubehelix_palette(8)) 其他cubehelix_palette()的参数主要调整色板的视觉。两个重要的选择是：start(值的范围为 03）和rot，或者旋转的次数（-1 和 1 之间） sns.palplot(sns.cubehelix_palette(8, start=.5, rot=-.75)) 你也可以控制断点的亮度和甚至对调结果顺序： sns.palplot(sns.cubehelix_palette(8, start=2, rot=0, dark=0, light=.95, reverse=True)) 默认情况下你只会得到一些像 seaborn 其它调色板一样的颜色列表，但你也可以通过使用as_cmap=True让调色板返回一个可以被传入 seaborn 或 matplotlib 函数的颜色映射对象。 x, y = np.random.multivariate_normal([0, 0], [[1, -.5], [-.5, 1]], size=300).T cmap = sns.cubehelix_palette(light=1, as_cmap=True) sns.kdeplot(x, y, cmap=cmap, shade=True); 与前面一样，也可以在 notebook 中使用choose_cubehelix_palette()来调节参数帮助选择更适合的调色板或颜色映射。如果想让函数返回一个类似hexbin的颜色映射而非一个列表则需要传入as_cmap=True。 定制的连续调色板对于一个更简单的接口定制连续色板，你可以使用 light_palette() 或者 dark_palette() 函数。它们都是单一颜色，并且能产生从亮值或者暗去饱和的值到这个颜色的调色板。伴随着这些函数，也同样有 choose_light_palette 和 choose_dark_palette 两个函数来交互式的调节创建调色板。 sns.palplot(sns.light_palette(&quot;green&quot;)) sns.palplot(sns.dark_palette(&quot;purple&quot;)) sns.palplot(sns.light_palette(&quot;navy&quot;, reverse=True)) 它们也可以创建一个颜色映射对象，而不仅仅是颜色列表。 pal = sns.dark_palette(&quot;palegreen&quot;, as_cmap=True) sns.kdeplot(x, y, cmap=pal); 默认情况下，任何有效的 matplotlib 颜色可以作为输入。另外辅助的解释可以由input参数来控制。目前你可以在 hls 或 husl 空间中提供默认的 rgb 元组，您还可以使用任何有效的 xkcd 颜色的种子。 sns.palplot(sns.light_palette((210, 90, 60), input=&quot;husl&quot;)) sns.palplot(sns.dark_palette(&quot;muted purple&quot;, input=&quot;xkcd&quot;)) 需要注意的是，husl是提供交互的组件的默认 input 空间，这与函数自身默认的并不同，但这在背景下却是更有用的。 3. 离散色板调色板中的第三类被称为 “离散”。这类色板适用于数据特征含有大的低值和大的高值。数据中通常有一个意义明确的中点。例如，如果你想要从某个基线时间点绘制温度变化，最好使用离散的颜色表显示相对降低和相对增加面积的地区。 除了你想满足一个低强度颜色的中点以及用不同起始颜色的两个相对微妙的变化，其实选择离散色板的规则类似于顺序色板。同样重要的是，起始值的亮度和饱和度是相同的。 同样重要的是要强调，应该避免使用红色和绿色，因为大量的潜在观众将无法分辨它们。 同样，Color Brewer 颜色字典里也同时拥有一套精心挑选的离散颜色映射: sns.palplot(sns.color_palette(&quot;BrBG&quot;, 7)) sns.palplot(sns.color_palette(&quot;RdBu_r&quot;, 7)) sns.palplot(sns.color_palette(&quot;coolwarm&quot;, 7)) 定制的离散色板你也可以使用 seaborn 函数 diverging_palette() 为离散的数据创建一个定制的颜色映射。（当然也有一个类似配套的互动工具：choose_diverging_palette()）。该函数使用 husl 颜色系统的离散色板。你需要传递两种色调，并可选择性的设定明度和饱和度的端点。函数将使用 husl 的端点值及由此产生的中间值进行均衡。 sns.palplot(sns.diverging_palette(220, 20, n=7)) sns.palplot(sns.diverging_palette(145, 280, s=85, l=25, n=7))sep 参数控制面板中间区域的两个渐变的宽度。 sns.palplot(sns.diverging_palette(10, 220, sep=80, n=7)) 也可以用中间的色调来选择调色，而不是用亮度。 sns.palplot(sns.diverging_palette(255, 133, l=60, n=7, center=&quot;dark&quot;)) 设置默认的调色板color_palette() 函数有一个名为set_palette()的配套使用函数。 set_palette()。set_palette() 接受与 color_palette() 相同的参数，但是它会更改默认的 matplotlib 参数，以便成为所有的调色板配置。 def sinplot(flip=1): x = np.linspace(0, 14, 100) for i in range(1, 7): plt.plot(x, np.sin(x + i * .5) * (7 - i) * flip) sns.set_palette(&quot;husl&quot;) sinplot() color_palette() 函数也可以在一个 with 块中使用，以达到临时更改调色板的目的。 with sns.color_palette(&quot;PuBuGn_d&quot;): sinplot() 总结 本篇介绍了 seaborn 中的颜色调控方法，提到的一个重要函数是：color_palette()。针对不同的数据类型有三种调色方式： 分类色板（qualitative） 连续色板（sequential） 离散色板（diverging） 其中还提到了 Color Brewer 工具，它可以很好的应用在以上三种调色方式上。 记住还有一个很有用的函数 choose_xxx_paletee()，用于交互式的调试颜色。 还可以通过 set_palette() 函数设置绘图默认参数。 参考：http://seaborn.pydata.org/tut… 关注微信公众号 Python 数据科学，获取 120G 人工智能 学习资料。]]></content>
      <categories>
        <category>Python Packages</category>
      </categories>
      <tags>
        <tag>seaborn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[长短期记忆网络]]></title>
    <url>%2F2019%2F07%2F09%2FDeepLearning%2FRNN%2FLSTM%2FLSTM%2F</url>
    <content type="text"><![CDATA[1 LSTM原理 English version：Understanding LSTM Networks 中文版：如何简单的理解LSTM——其实没有那么复杂 作业部落 好看的图 2 LSTM基础应用 LSTM在MNIST数据集中的运用 3 LSTM实战 # Tensorflow实例：利用LSTM预测股票每日最高价（二） 使用tensorflow的lstm网络进行时间序列预测 基于单变量的LSTM时间序列预测 基于多变量的LSTM时间序列预测 基于LSTM的多步预测 实用LSTM时间预测例子 多层LSTM网络：教你打造股市晴雨表——通过LSTM神经网络预测股市 LSTM英文句子预测问题 lstm时间序列预测程序 4 LSTM相关问题理解 tensorflow中LSTM模型的n_hidden含义 LSTM stateful相关理解 Stateful LSTM in Keras Understanding Stateful LSTM Recurrent Neural Networks in Python with Keras The LSTM networks are stateful. They should be able to learn the whole alphabet sequence, but by default the Keras implementation resets the network state after each training batch. https://stackoverflow.com/questions/43882796/when-does-keras-reset-an-lstm-state https://ahstat.github.io/RNN-Keras-time-series/ Keras之stateful LSTM全面解析+实例测试 LSTM输入层理解 5 LSTM论文及资料rnn和lstm资源收集om/t/rnn-lstm/13587)]]></content>
      <categories>
        <category>LSTM</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LSTM时序预测滞后现象]]></title>
    <url>%2F2019%2F07%2F09%2FDeepLearning%2FRNN%2FLSTM%2FLSTM%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B%E6%BB%9E%E5%90%8E%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在使用LSTM进行时间序列预测时，有时会遇到预测滞后问题，也就是LSTM的预测值滞后于真实值的变化。出现滞后现象的一些文章和可能解释收集如下 用 LSTM 做时间序列预测的一个小例子 时间序列预测—-预测的结果跟实际的时间序列值存在滞后 代码干货 | 基于Keras的LSTM多变量时间序列预测 但如果只用time series数据，你很有可能得到的就是滞后一天的趋势 一个带输出图像的LSTM预测 用LSTM预测时间序列存在延迟现象？ Stackexchange problem Stackoverflow-Delay issue in time series prediction LSTM for time series prediction LSTM Neural Network for Time Series Prediction 知乎问题-Pyhong的答案 https://dashee87.github.io/deep%20learning/python/predicting-cryptocurrency-prices-with-deep-learning/ https://medium.com/@siavash_37715/how-to-predict-bitcoin-and-ethereum-price-with-rnn-lstm-in-keras-a6d8ee8a5109 最全 LSTM 模型在量化交易中的应用汇总（代码+论文） https://www.kaggle.com/pablocastilla/predict-stock-prices-with-lstm useful discussion another discussion another another discussion https://jiasuhui.com/article/3855 知乎问题 延时现象解决 github上的讨论 ResearchGate上的讨论 possible solution randomize training samples in each batch, make sure they are not followed one by one choose or design a better loss function other than MSE extract some features from the input time series manually limit the weight of x_{t-1}, x_{t-2} ght of x_{t-1}, x_{t-2}]]></content>
      <categories>
        <category>LSTM</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TimeDistributedDense()层]]></title>
    <url>%2F2019%2F07%2F09%2FDeepLearning%2FRNN%2FLSTM%2FTimeDistributedDense()%E5%B1%82%2F</url>
    <content type="text"><![CDATA[https://github.com/keras-team/keras/issues/2405 https://github.com/CanePunma/Stock_Price_Prediction_With_RNNs/issues/1 https://stackoverflow.com/questions/42398645/timedistributed-vs-timedistributeddense-keras https://stackoverflow.com/questions/44611006/timedistributeddense-vs-dense-in-keras-same-number-of-parameters https://stackoverflow.com/questions/45631235/importerror-cannot-import-name-timedistributeddense-in-keras https://stackoverflow.com/questions/41947039/keras-rnn-with-lstm-cells-for-predicting-multiple-output-time-series-based-on-mu https://stackoverflow.com/questions/49661708/keras-lstm-multiple-input-multiple-output https://blog.csdn.net/oQiCheng1234567/article/details/73051251 https://github.com/keras-team/keras/issues/1029 keras/issues/1029)]]></content>
      <categories>
        <category>LSTM</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sequence to Sequence(s2s)]]></title>
    <url>%2F2019%2F07%2F09%2FDeepLearning%2FRNN%2FSeq2Seq%2F%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%2F</url>
    <content type="text"><![CDATA[论文 Sequence to Sequence Learning with Neural Networks Learning Phrase Representations using RNN Encoder–Decoder for Statistical Machine Translation Neural Machine Translation By Jointly Learning To Align and Translate 原理 seq2seq学习笔记 漫谈四种神经网络序列解码模型 实践应用 TensorFlow文本摘要生成 - 基于注意力的序列到序列模型 How to Develop an Encoder-Decoder Model for Sequence-to-Sequence Prediction in Keras How to Define an Encoder-Decoder Sequence-to-Sequence Model for Neural Machine Translation in Keras 知乎sequence_to_sequence项目 注意力机制 一文解读NLP中的注意力机制 自然语言处理中的Attention Model：是什么及为什么 NLP中的Attention Model 自然语言处理中的自注意力机制(Self-attention Mechanism) Attention is all you need 详细图解attention is all you need 详细解释加pytorch实现 另一份详细解释 attention is all you need解读 The Transformer – Attention is all you need. pytorch实现 中文资料加pytorch实现 Google官方tensorflow实现 中文资料 Transformer各层图示 ua/p/transformer.html)]]></content>
      <categories>
        <category>sequence to sequence</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
</search>
