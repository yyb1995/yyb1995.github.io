<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Eric_fish&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yyb1995.github.io/"/>
  <updated>2019-10-18T13:52:09.596Z</updated>
  <id>https://yyb1995.github.io/</id>
  
  <author>
    <name>Eric_fish</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://yyb1995.github.io/2019/10/18/Mac/Mac%E6%8A%98%E8%85%BE/"/>
    <id>https://yyb1995.github.io/2019/10/18/Mac/Mac折腾/</id>
    <published>2019-10-18T13:52:09.595Z</published>
    <updated>2019-10-18T13:52:09.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mac折腾记"><a href="#Mac折腾记" class="headerlink" title="Mac折腾记"></a>Mac折腾记</h1><h2 id="一些好用的功能"><a href="#一些好用的功能" class="headerlink" title="一些好用的功能"></a>一些好用的功能</h2><p><a href="https://www.macdaxue.com/force-touch/" target="_blank" rel="noopener">触控板用力点按 Froce torch</a></p><h2 id="系统相关"><a href="#系统相关" class="headerlink" title="系统相关"></a>系统相关</h2><h3 id="修改账户名称"><a href="#修改账户名称" class="headerlink" title="修改账户名称"></a>修改账户名称</h3><p>在账户相关设置中，有账户名称和全名两个设置。如果想要修改账户名称，需要新建一个管理员账户，然后退出当前账户，在另一个管理员账户中修改账户名称。如果想修改账户全名，需要重置用户文件夹。</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p><a href="https://www.jianshu.com/p/020f3d02f538" target="_blank" rel="noopener">Mac在bash和zsh配置环境变量的几种方法</a></p><p>这里需要注意的是在配置用户环境变量时，<code>~/.bashrc</code>对应bash的用户环境变量。如果已经把bash改成了zsh，需要在<code>~/.zshrc</code>中设置。</p><h3 id="bash-gt-iterms2"><a href="#bash-gt-iterms2" class="headerlink" title="bash-&gt;iterms2"></a>bash-&gt;iterms2</h3><p><a href="https://www.jianshu.com/p/9c3439cc3bdb" target="_blank" rel="noopener">iTerm2 + Oh My Zsh 打造舒适终端体验</a></p><p>我的一些配置：</p><pre><code class="text">iterms Theme：Draculafont: 18pt Roboto Mono for PowerlineHotkey: Double click Command</code></pre><h3 id="替换Command和Ctrl"><a href="#替换Command和Ctrl" class="headerlink" title="替换Command和Ctrl"></a>替换<code>Command</code>和<code>Ctrl</code></h3><p>系统偏好设置-&gt;键盘-&gt;修饰键</p><h3 id="Finder标题显示文件夹全称"><a href="#Finder标题显示文件夹全称" class="headerlink" title="Finder标题显示文件夹全称"></a>Finder标题显示文件夹全称</h3><p><code>defaults write com.apple.finder _FXShowPosixPathInTitle -bool YES</code></p><h2 id="常用软件"><a href="#常用软件" class="headerlink" title="常用软件"></a>常用软件</h2><h3 id="MAC软件网站"><a href="#MAC软件网站" class="headerlink" title="MAC软件网站"></a>MAC软件网站</h3><p><a href="https://www.xxmac.com/" target="_blank" rel="noopener">xxmac</a></p><p><a href="https://xclient.info/" target="_blank" rel="noopener">xclient</a></p><p><a href="https://www.macbl.com/" target="_blank" rel="noopener">MacBL</a></p><h3 id="软件卸载工具"><a href="#软件卸载工具" class="headerlink" title="软件卸载工具"></a>软件卸载工具</h3><p><a href="https://segmentfault.com/a/1190000005035742" target="_blank" rel="noopener">好用的软件卸载工具</a></p><h3 id="Pycharm"><a href="#Pycharm" class="headerlink" title="Pycharm"></a>Pycharm</h3><p><a href="https://zhile.io/2018/08/17/jetbrains-license-server-crack.html" target="_blank" rel="noopener">安装Pycharm及破解</a></p><h3 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h3><p><a href="https://www.anaconda.com/distribution/" target="_blank" rel="noopener">Anaconda官网</a></p><p>将Anaconda加入环境变量：在<code>~/.bashrc</code>或<code>~./zshrc</code>中加入<code>export PATH=&quot;/Users/binbin/anaconda3/bin:$PATH&quot;</code></p><h3 id="多电脑共享键鼠Synergy"><a href="#多电脑共享键鼠Synergy" class="headerlink" title="多电脑共享键鼠Synergy"></a>多电脑共享键鼠Synergy</h3><blockquote><p><a href="https://pan.baidu.com/s/1PV_aY2BdgqmeFI5vLsEBXA" target="_blank" rel="noopener">度娘网盘</a></p><p>提取码：sk6h</p></blockquote><p>需要注意的：</p><ol><li><p>在第一次使用时需要去掉<code>编辑-&gt;设置-&gt;Use SSL Encryption</code>的勾，然后删除<code>~/Library/Synergy/SSL</code>文件夹</p></li><li><p>要写清楚主机和从机在局域网中的名称</p></li><li><p>如果从机是Mac，可以把Super和Ctrl键进行替换</p></li><li><p>如果出现不能复制粘贴的情况，可以重启Synergy</p></li><li><p>如果出现已连接但不能移动鼠标的情况，可以在主机端把从机清除再添加一次</p></li></ol><h3 id="Mactex"><a href="#Mactex" class="headerlink" title="Mactex"></a>Mactex</h3><p><a href="http://www.tug.org/mactex/" target="_blank" rel="noopener">MacTex</a></p><h3 id="Dash"><a href="#Dash" class="headerlink" title="Dash"></a>Dash</h3><p><a href="https://kapeli.com/dash" target="_blank" rel="noopener">安装</a><br><a href="https://kakarot.net/cgi-bin/dash-macos-license" target="_blank" rel="noopener">破解</a><br><a href="https://github.com/Kapeli/feeds" target="_blank" rel="noopener">DocSet下载</a>。下载后存放到<code>/Users/name/Library/Application Support/Dash/</code>中对应位置</p><h3 id="网速显示"><a href="#网速显示" class="headerlink" title="网速显示"></a>网速显示</h3><p><a href="https://github.com/yujitach/MenuMeters" target="_blank" rel="noopener">MenuMesters</a></p><h3 id="在目录下打开shell"><a href="#在目录下打开shell" class="headerlink" title="在目录下打开shell"></a>在目录下打开shell</h3><p><a href="https://zipzapmac.com/Go2Shell" target="_blank" rel="noopener">go2Shell</a></p><h3 id="视频播放器"><a href="#视频播放器" class="headerlink" title="视频播放器"></a>视频播放器</h3><p><a href="https://iina.io/" target="_blank" rel="noopener">IINA</a></p><h3 id="brew-amp-git"><a href="#brew-amp-git" class="headerlink" title="brew &amp; git"></a>brew &amp; git</h3><ul><li>安装Homebrew</li></ul><p><a href="https://brew.sh/" target="_blank" rel="noopener">https://brew.sh/</a></p><ul><li>安装git</li></ul><pre><code>brew install gitbrew link git --overwrite</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Mac折腾记&quot;&gt;&lt;a href=&quot;#Mac折腾记&quot; class=&quot;headerlink&quot; title=&quot;Mac折腾记&quot;&gt;&lt;/a&gt;Mac折腾记&lt;/h1&gt;&lt;h2 id=&quot;一些好用的功能&quot;&gt;&lt;a href=&quot;#一些好用的功能&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Pytorch常用tensor操作</title>
    <link href="https://yyb1995.github.io/2019/10/18/Pytorch/Pytorch%E4%B8%AD%E5%B8%B8%E7%94%A8tensor%E6%93%8D%E4%BD%9C/"/>
    <id>https://yyb1995.github.io/2019/10/18/Pytorch/Pytorch中常用tensor操作/</id>
    <published>2019-10-18T07:14:38.928Z</published>
    <updated>2019-10-18T07:14:38.929Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-torch-cat"><a href="#1-torch-cat" class="headerlink" title="1 torch.cat"></a>1 torch.cat</h2><p>cat指的是对多个Tensor在<strong>原有某一维度</strong>进行拼接，拼接的结果是Tensor的总维数不变，其中用于拼接的那一维等于各分量维数之和。示例：</p><pre><code class="python">x = torch.rand(2, 3)y = torch.rand(4, 3)z = torch.cat((x, y), 0)</code></pre><p>即x和y沿着axis=0的维度进行拼接，得到的结果是一个(6*3)的Tensor<br>此外，还有如下用法：</p><ol><li><code>torch.cat((x, x), 0)</code></li><li><code>torch.cat([torch.rand(3, 4), torch.rand(5, 4)], dim=0)</code> </li></ol><h2 id="2-torch-chunk"><a href="#2-torch-chunk" class="headerlink" title="2 torch.chunk"></a>2 torch.chunk</h2><p><code>torch.chunk(tensor, chunks, dim=0)</code><br>chunk可以看成cat的逆操作，即将一个矩阵沿着某一维分割开。chunks为分割的份数， dim为分割的维度。例子：</p><pre><code class="python">x = torch.zeros(2, 3, 4)y = torch.chunk(x, 3, 1)</code></pre><p>得到的y是一个tuple，每一个的维度为(2, 1, 4)<br>还可使用Tensor.chunks(chunks, dim=0)效果与上相同。</p><h2 id="3-torch-stack"><a href="#3-torch-stack" class="headerlink" title="3 torch.stack"></a>3 torch.stack</h2><p>stack指的是在<strong>新的维度上</strong>进行拼接，这个操作会增加维度。示例：</p><pre><code class="python">x = torch.ones(1, 3)y = torch.ones(1, 3)z1 = torch.stack((x, y), 0)z2 = torch.stack((x, y), 1)z3 = torch.stack((x, y), 2)</code></pre><p>输出维数规律：除拼接的维数外别的维数保持不变，拼接的维数等于输入个数之和。则上述三个输出的维数分别为：<br>z1:(2, 1, 3), z2:(1, 2, 3), z3:(1, 3, 2)。<br><strong>注意：</strong> torch.stack的输入tensor的维数必须一致，这样才能保证在能够在新的维度进行拼接操作。</p><h2 id="4-torch-transpose"><a href="#4-torch-transpose" class="headerlink" title="4 torch.transpose"></a>4 torch.transpose</h2><p>transpose指的是将Tensor的某两个维度进行交换。示例：</p><pre><code class="python">x = torch.zeros(2, 3)y = torch.transpose(x, 0, 1)</code></pre><h2 id="5-permute-amp-reshape"><a href="#5-permute-amp-reshape" class="headerlink" title="5 permute &amp; reshape"></a>5 permute &amp; reshape</h2><p>permute是适合于多维度的维数交换。使用方法：输入希望产生的维度即可。例子：</p><pre><code class="python">x = torch.zeros(2, 3, 4)y = x.permute(2, 1, 0)</code></pre><p>输出y的维度为:(4, 3, 2)</p><p>reshape和permute功能类似，不过reshape一般用于连续维度的改变，如</p><pre><code class="python">x = torch.zeros(2, 3, 4)y = x.reshape(2, 6, 2)</code></pre><p>如果用于reshape的维度不是连续的，会出现数据改变的情况。</p><h2 id="6-squeeze"><a href="#6-squeeze" class="headerlink" title="6 squeeze"></a>6 squeeze</h2><p>squeeze是将某一个维度为1的维去除。使用方法：x.squeeze()。<br>例子：</p><pre><code class="python">x = torch.zeros(3, 1, 2)y = x.squeeze(1)</code></pre><p>得到的y的维度为(3, 2)。如果选择的维数不为1，那么得到的结果的维数与原Tensor的维数一致</p><h2 id="7-unsqueeze"><a href="#7-unsqueeze" class="headerlink" title="7 unsqueeze"></a>7 unsqueeze</h2><p>unsqueeze是增加一个维度，维度位置为dim。使用方法：a.unsqueeze(dim)。<br>例子：</p><pre><code class="python">x = torch.zeros(3, 2)y = x.unsqueeze(2)</code></pre><p>得到的y的维数为：(3, 2, 1)<br>use repeat – this will copy each vector 28 times.</p><p>X = torch.randn(100, 700)<br>X = X.unsqueeze(2).repeat(1, 1, 28)</p><h2 id="8-torch-masked-fill"><a href="#8-torch-masked-fill" class="headerlink" title="8 torch.masked_fill"></a>8 torch.masked_fill</h2><p>masked_fill将一个tensor中为1的元素用指定的值填充。例如：</p><pre><code class="python">a = torch.ones(3, 3)</code></pre><h2 id="9-torch-view"><a href="#9-torch-view" class="headerlink" title="9 torch.view"></a>9 torch.view</h2><p>view将一个tensor变换维度，但其中的数值保持不变</p><h2 id="10-torch-bmm"><a href="#10-torch-bmm" class="headerlink" title="10 torch.bmm"></a>10 torch.bmm</h2><p>bmm即batch_matmul，作用是不考虑batch维度将两个矩阵相乘。</p><pre><code class="python">a = torch.ones(128, 4, 3)b = torch.ones(128, 3, 10)result = torch.bmm(a, b)print(result.shape)&gt;&gt;&gt; (128, 4, 10)</code></pre><h2 id="11-expand-amp-repeat"><a href="#11-expand-amp-repeat" class="headerlink" title="11 expand&amp;repeat"></a>11 expand&amp;repeat</h2><p>expand和repeat都用于扩展Tensor的维度。<strong>使用前提：原矩阵的维度和扩展后矩阵的维度一致。因此通常先进行squeeze(dim)或unsqueeze(dim)操作</strong>。expand的输入参数是扩展后Tensor的维度，repeat的输入参数是扩展后Tensor相对于原Tensor扩展的倍数。<strong>此外，注意expand仅限于对张量中维数为1的维度的扩展，否则会报类型不匹配错误。</strong> 例如：</p><pre><code class="python">a = torch.Tensor([1, 2, 3])# 最终维数为(3, 5)，相当于第一维不变，第二维扩展5次b = a.unsqueeze(1).expand(3, 5)# 在第一维扩展1次，在第二维扩展5次c = a.unsqueeze(1).repeat(1, 5)# output:tensor([[1., 1., 1., 1., 1.],        [2., 2., 2., 2., 2.],        [3., 3., 3., 3., 3.]])# RuntimeError: The expanded size of the tensor (6) must match the existing size (3) at non-singleton dimension 2.  Target sizes: [1, 4, 6].  Tensor sizes: [1, 2, 3]a.expand(1, 4, 6)</code></pre><p>expand不会复制数组内存，节省空间。repeat会复制所有数据</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-torch-cat&quot;&gt;&lt;a href=&quot;#1-torch-cat&quot; class=&quot;headerlink&quot; title=&quot;1 torch.cat&quot;&gt;&lt;/a&gt;1 torch.cat&lt;/h2&gt;&lt;p&gt;cat指的是对多个Tensor在&lt;strong&gt;原有某一维度&lt;/st
      
    
    </summary>
    
      <category term="Pytorch" scheme="https://yyb1995.github.io/categories/Pytorch/"/>
    
    
      <category term="Pytorch" scheme="https://yyb1995.github.io/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>numpy</title>
    <link href="https://yyb1995.github.io/2019/10/18/PythonPackages/numpy/"/>
    <id>https://yyb1995.github.io/2019/10/18/PythonPackages/numpy/</id>
    <published>2019-10-18T07:14:38.927Z</published>
    <updated>2019-10-18T07:14:38.927Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-导入numpy"><a href="#1-导入numpy" class="headerlink" title="1 导入numpy"></a>1 导入numpy</h2><p>常用代码：<code>import numpy as np</code>或<code>from numpy import *</code>。建议使用第一种。使用第一种时要在numpy函数前加上<code>np.xxx</code>，如·<code>np.array</code></p><h2 id="2-矩阵的创建"><a href="#2-矩阵的创建" class="headerlink" title="2 矩阵的创建"></a>2 矩阵的创建</h2><p>常用代码:</p><ol><li>创建数组<br><code>np.array([[1,2,3]])</code>创建一个1*3的numpy数组</li><li>创建全1矩阵<br><code>np.ones([a,b])</code>创建一个a*b的矩阵，元素全为1</li></ol><p><strong><em>注意：np.ones和np.zeros的参数是一维向量，需要使用[]，而np.random.rand不需要使用[]</em></strong></p><ol start="3"><li>创建全0矩阵<br><code>np.zeros([a,b])</code>创建一个a*b的矩阵，元素全为0</li><li>创建对角矩阵<br><code>np.diag([a,b,c])</code>创建一个对角线元素为a,b,c的矩阵<br><code>np.diag([[a,b,c],[d,e,f],[g,h,i]])</code>创建一个1*3向量，元素为矩阵对角线元素</li></ol><h2 id="3-矩阵的运算"><a href="#3-矩阵的运算" class="headerlink" title="3 矩阵的运算"></a>3 矩阵的运算</h2><ol><li><p>计算向量间的欧氏距离</p><pre><code class="python">a1 = np.array([[1,2],[2,3]])a2 = np.array([[2,0],[2,1]])dist = np.linalg.norm(a1 - a2)print(dist)</code></pre></li><li><p>一维数组的转置<br><code>np.transpose([a])</code></p></li><li><p>矩阵的排序<br><code>np.sort(a, axis=-1, kind=&#39;quicksort&#39;, order=None)</code><br>返回排序好的矩阵，a为原矩阵，axis为排序方向，axis = 0为纵轴排序，axis = 1位横轴排序</p></li><li><p>垂直合并矩阵<br><code>np.vstack((a,b))</code><br>将a,b矩阵垂直合并</p></li><li><p>水平合并矩阵<br><code>np.hstack((a,b))</code><br>将a,b矩阵水平合并</p></li><li><p>按矩阵某行排序<br><code>data = data[:,data[2].argsort()]</code><br>按第3行从小到大排序</p></li><li><p>按矩阵某列排序<br><code>data = data[data[:,2].argsort()]</code><br>按第3列从小到大排序</p></li><li><p>矩阵的乘法<br><code>np.dot(a,b)</code></p></li><li><p>多矩阵乘法<br><code>np.linalg.multi_dot([a,b,c])</code></p></li><li><p>矩阵的加法<br><code>np.sum(a)</code><br><code>np.sum(a,axis = 0)  #每列相加</code><br><code>np.sum(a,axis = 1)  #每行相加</code><br>axis代表相加后消失的维数</p></li><li><p>矩阵的删除<br><code>np.delete(X,0,axis=0)</code><br>删除矩阵第一行</p></li><li><p>行向量转列向量<br><code>a.shape = (3,1)</code></p></li><li><p>矩阵的随机化<br><code>np.random.shuffle(matrix)</code><br>沿着第一维进行重新排列。如果是二维数据，那么就按行进行重新排列</p></li><li><p>去除nan值<br><code>x = x[~np.isnan(x)]</code><br><code>np.nanmean(np.array([1, 2, 3, np.nan])</code></p></li><li><p>统计矩阵不重复的行或列<br><code>unq, cnt = np.unique(a, return_counts=True, axis=0)</code><br><code>return counts</code>表示返回不重复行/列的数目，<code>axis=0</code>表示从行的方向统计。</p></li><li><p>矩阵的重叠<br>在numpy中，矩阵的重叠有两种： np.tile()和np.repeat()。np.tile()是将整个矩阵进行重叠，np.repeat()是将矩阵中的每个元素进行重叠。</p><pre><code class="python">a = np.array([[1, 2, 3], [4, 5, 6]])b = np.tile(a, (2, 1))c = np.repeat(a, 2, axis=0)&gt;&gt;&gt; barray([[1, 2, 3],   [2, 3, 4],   [1, 2, 3],   [2, 3, 4]])&gt;&gt;&gt; carray([[1, 2, 3],   [1, 2, 3],   [2, 3, 4],   [2, 3, 4]])</code></pre></li><li><p>使用元组索引数组<br>可以使用元组对数组进行索引，即<code>a[(2, 3)]</code>。如果是其他类型的，可以使用<code>tuple()</code>进行转换。</p></li></ol><h2 id="4-数据的产生"><a href="#4-数据的产生" class="headerlink" title="4 数据的产生"></a>4 数据的产生</h2><ol><li>正态分布数据<br><code>numpy.random.normal(loc, scale, size)</code><br>loc：float<br> 此概率分布的均值（对应着整个分布的中心centre）<br>scale：float<br> 此概率分布的标准差（对应于分布的宽度，scale越大越矮胖，scale越小，越瘦高）<br>size：int or tuple of ints<br> 输出的shape，默认为None，只输出一个值</li><li>随机分布数据<br><code>numpy.random.rand(a,b)</code>创建一个维数为a*b，数值在[0,1)的随机矩阵</li><li>标准正态分布数据中随机抽取<br><code>numpy.random.randn(a,b)</code>创建一个维数为a*b，数值取值为标准正态分布中随机取样本点</li><li>产生不重复随机数组<br><code>random.sample(a,b)</code>在a数组的范围内随机产生b个不重复的随机数</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-导入numpy&quot;&gt;&lt;a href=&quot;#1-导入numpy&quot; class=&quot;headerlink&quot; title=&quot;1 导入numpy&quot;&gt;&lt;/a&gt;1 导入numpy&lt;/h2&gt;&lt;p&gt;常用代码：&lt;code&gt;import numpy as np&lt;/code&gt;或&lt;code
      
    
    </summary>
    
      <category term="Python Packages" scheme="https://yyb1995.github.io/categories/Python-Packages/"/>
    
    
      <category term="numpy" scheme="https://yyb1995.github.io/tags/numpy/"/>
    
  </entry>
  
  <entry>
    <title>Python常见问题和技巧</title>
    <link href="https://yyb1995.github.io/2019/10/18/Python/Python%E6%8A%80%E5%B7%A7/"/>
    <id>https://yyb1995.github.io/2019/10/18/Python/Python技巧/</id>
    <published>2019-10-18T07:14:38.926Z</published>
    <updated>2019-10-18T07:14:38.927Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模块修改后再次载入无变化"><a href="#模块修改后再次载入无变化" class="headerlink" title="模块修改后再次载入无变化"></a>模块修改后再次载入无变化</h2><pre><code class="python">import importlibimportlib.reload(PackageName)%load_ext autoreload%autoreload 2</code></pre><h2 id="python数据类型set"><a href="#python数据类型set" class="headerlink" title="python数据类型set"></a>python数据类型set</h2><p>set是一种无序集合。常见的方法有：</p><ol><li>创建集合<br><code>a = set(&#39;python&#39;)</code></li><li>向集合中传入一个元素并拆分<br><code>a.update(&#39;java&#39;)</code></li><li>删除集合中元素<br><code>a.remove(&#39;p&#39;)</code></li><li>不同集合之间的关系<br><img src="http://www.iplaypython.com/uploads/allimg/131215/2-131215203406215.jpg" alt></li></ol><h2 id="利用列表生成字典"><a href="#利用列表生成字典" class="headerlink" title="利用列表生成字典"></a>利用列表生成字典</h2><pre><code class="python">a = [1, 2, 3]b = [4, 5, 6]dict1 = dict(zip(a, b))</code></pre><h2 id="python-排序"><a href="#python-排序" class="headerlink" title="python 排序"></a>python 排序</h2><p><code>sorted([1, 2, 3, 5, 3])</code></p><h2 id="python中的队列"><a href="#python中的队列" class="headerlink" title="python中的队列"></a>python中的队列</h2><pre><code>from collections import dequequeue = deque([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])queue.append(&#39;e&#39;)queue.popleft()</code></pre><h2 id="python数组按某列排序"><a href="#python数组按某列排序" class="headerlink" title="python数组按某列排序"></a>python数组按某列排序</h2><p><code>data[data[:,2].argsort()]</code><br>数组按第三列排序</p><h2 id="python-字典转变量"><a href="#python-字典转变量" class="headerlink" title="python 字典转变量"></a>python 字典转变量</h2><p><code>globals().update(dict)</code><br>例如： {foo: bar} -&gt; foo = bar</p><h2 id="Google注释规范"><a href="#Google注释规范" class="headerlink" title="Google注释规范"></a>Google注释规范</h2><pre><code class="python">def fetch_bigtable_rows(big_table, keys, other_silly_variable=None):    &quot;&quot;&quot;Fetches rows from a Bigtable.    Retrieves rows pertaining to the given keys from the Table instance    represented by big_table.  Silly things may happen if    other_silly_variable is not None.    Args:        big_table: An open Bigtable Table instance.        keys: A sequence of strings representing the key of each table row            to fetch.        other_silly_variable: Another optional variable, that has a much            longer name than the other args, and which does nothing.    Returns:        A dict mapping keys to the corresponding table row data        fetched. Each row is represented as a tuple of strings. For        example:        {&#39;Serak&#39;: (&#39;Rigel VII&#39;, &#39;Preparer&#39;),         &#39;Zim&#39;: (&#39;Irk&#39;, &#39;Invader&#39;),         &#39;Lrrr&#39;: (&#39;Omicron Persei 8&#39;, &#39;Emperor&#39;)}        If a key from the keys argument is missing from the dictionary,        then that row was not found in the table.    Raises:        IOError: An error occurred accessing the bigtable.Table object.    &quot;&quot;&quot;    pass</code></pre><p><strong>注意：</strong> 函数功能注释与参数说明之间应该空一行</p><h2 id="map、reduce和filter"><a href="#map、reduce和filter" class="headerlink" title="map、reduce和filter"></a>map、reduce和filter</h2><p>map用于将一个函数映射到后面给出的变量列表中，reduce用于将一个函数依次映射到后面的相邻变量中，reduce用于筛选列表中符合某个函数条件的值</p><pre><code class="python">map(lambda x: x ** 2, range(1, 10))from functools import reducereduce(lambda x, y: x + y, range(1, 11))filter(lambda x: x % 2, range(1, 11))</code></pre><h2 id="号的使用"><a href="#号的使用" class="headerlink" title="*号的使用"></a>*号的使用</h2><p>*号可用在函数的输入参数前，用于将输入参数解包以匹配函数的形参，也可用于把一个函数的多个返回值拆开使用</p><pre><code class="python"># Example 1def print_(a, b, c):    print(a)    print(b)    print(c)a = [&#39;ap&#39;, &#39;ba&#39;, &#39;or&#39;]print(*a)# Example 2def a():    return 1, 2, 3print(&#39;{} {} {}&#39;.format(*a()))</code></pre><h2 id="Python数组拷贝"><a href="#Python数组拷贝" class="headerlink" title="Python数组拷贝"></a>Python数组拷贝</h2><p>在进行Python的数组拷贝时，有时会用到切片操作。下面是一个例子：</p><pre><code class="python">dec_seq = torch.rand(3, 4, 5)dec_input = dec_seq[:, :-1]dec_output = dec_seq[:, 1:]</code></pre><p>实际上dec_input和dec_output只是对dec_seq的一个引用，并不是对对象的一个完整复制。当dec_seq的值改变时，dec_input和dec_output的值也会随之改变。因此，dec_input和dec_output更像是指向dec_seq一部分的指针。如果想对原数组进行完整的拷贝，应该使用copy模块中的copy和deepcopy。</p><ol><li>copy.copy 浅拷贝 只拷贝父对象，不会拷贝对象的内部的子对象。</li><li>copy.deepcopy 深拷贝 拷贝对象及其子对象<br>例子：<pre><code class="python">&gt;&gt;&gt; import copy&gt;&gt;&gt; a = [1,2,3,4,[&#39;a&#39;,&#39;b&#39;]]  #原始对象</code></pre></li></ol><blockquote><blockquote><blockquote><p>b = a  #赋值，传对象的引用</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>c = copy.copy(a)</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>d = copy.deepcopy(a)</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>a.append(5)<br>a[4].append(‘c’)</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>print ‘a=’,a<br>a= [1, 2, 3, 4, [‘a’, ‘b’, ‘c’], 5]<br>print ‘b=’,b<br>b= [1, 2, 3, 4, [‘a’, ‘b’, ‘c’], 5]<br>print ‘c=’,c<br>c= [1, 2, 3, 4, [‘a’, ‘b’, ‘c’]]<br>print ‘d=’,d<br>d= [1, 2, 3, 4, [‘a’, ‘b’]]</p><pre><code></code></pre></blockquote></blockquote></blockquote><h2 id="Python的异常处理机制"><a href="#Python的异常处理机制" class="headerlink" title="Python的异常处理机制"></a>Python的异常处理机制</h2><p>python有两种机制可以触发异常：</p><ol><li><p>try-except-else-finally<br>程序尝试执行try下的语句，如果触发异常就跳到相应的except语句，如果没有错误就跳到else语句。finally语句是无论是否发生错误都会执行。</p><pre><code class="python">try:&lt;语句&gt;        #尝试执行except &lt;异常类型1&gt;：&lt;语句&gt;        #如果在try部份引发了&#39;name&#39;异常except &lt;异常类型2&gt;，&lt;数据&gt;:&lt;语句&gt;        #如果引发了&#39;name&#39;异常，获得附加的数据else:&lt;语句&gt;        #正常执行finally:&lt;语句&gt;        #无论是否触发异常都执行的语句</code></pre></li><li><p>if-raise<br>程序尝试判断if语句下是否成立，如果成立，抛出raise下的error。</p><pre><code class="python">if expression: raise Exception</code></pre></li><li><p>自定义Error类型<br>需要自定义异常类型时，需要继承<code>Exception</code>类</p><pre><code class="python">class SomeCustomException(Exception): pass</code></pre></li><li><p>warnings模块<br>warnings.warn()函数用于生成警告信息。格式为：</p><pre><code class="python">if expression: warnings.warn(&#39;Warning message&#39;, WarningType)</code></pre><p>其中WarningType可以是Python模块中的warning，<a href="https://docs.python.org/3/library/warnings.html" target="_blank" rel="noopener">具体目录</a></p></li></ol><h2 id="Python-filter-函数"><a href="#Python-filter-函数" class="headerlink" title="Python filter()函数"></a>Python filter()函数</h2><p><code>filter(function, iterable)</code></p><p>filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。</p><p>该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。</p><p>使用方法：</p><pre><code class="python">filter1 = filter(lambda x: x &gt; 0, [-1, 0, 1, 5])filter1.next()</code></pre><h2 id="对于None的判断"><a href="#对于None的判断" class="headerlink" title="对于None的判断"></a>对于None的判断</h2><p>在 if判断中，None，False，空字符串，0，空列表，空字典，空元组都会被判断成False。因此在使用if not x判断是否为None时，需要排除其余可能的影响。因此，建议的判断方式为：if x is not None</p><h2 id="字符串join-方法"><a href="#字符串join-方法" class="headerlink" title="字符串join()方法"></a>字符串join()方法</h2><p>Python join()方法用于将序列中的元素以指定的字符连接生成一个新的字符串。str.join(sequence)即用str来连接sequence<br><code>a = &#39;&#39;.join(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;)</code></p><h2 id="响应键盘终止"><a href="#响应键盘终止" class="headerlink" title="响应键盘终止"></a>响应键盘终止</h2><pre><code class="python">except KeyboardInterrupt:    print(&#39;Interrupt&#39;)</code></pre><h2 id="字符串不转义"><a href="#字符串不转义" class="headerlink" title="字符串不转义"></a>字符串不转义</h2><p>在使用正则表达式时，通常不希望表示转义字符，方法是在字符串前加上<code>r</code>，如<code>r&#39;[]\&#39;</code>。</p><h2 id="heapq模块及其应用"><a href="#heapq模块及其应用" class="headerlink" title="heapq模块及其应用"></a>heapq模块及其应用</h2><p>Python中的heapq模块提供了基于堆的优先排序算法。堆可以看成完全二叉树，父节点的值永远比子节点小。常用的方法有</p><ol><li><code>heappush</code>把元素放入堆</li><li><code>heappop</code>返回堆中最小的元素</li><li><code>heappushpop</code>把元素放入堆的同时返回最小的元素</li><li><code>heapify</code>在线性时间内把一个列表转化为堆。注意，这个操作是把原列表直接转化为堆而不是创建一个新的堆</li><li><code>nlargest</code>返回堆中最大的k个元素</li><li><code>nsmallest</code>返回堆中最小的k个元素。<code>nlargest</code>和<code>nsmallest</code>通常用于在一个含有较多元素的列表中找出少数最值，<code>max()</code>和<code>min</code>通常用于找出最大/最小值，如果需要找的最值较多，推荐把列表进行排序后使用切片查找。</li><li><code>merge</code>用于将多个<code>iterable</code>对象进行归并排序。返回一个<code>generator</code>用于生成排序结果。<pre><code class="python">import heapqlist1 = [1, 5, 9, 2, 4]dict1 = [{&#39;a&#39;: 2}, {&#39;a&#39;: 3}, {&#39;a&#39;: 8}]heapq.nlargest(2, list1)heapq.nsmallest(4, list1)heapq.nlargest(2, dict1, key=lambda x: x[&#39;a&#39;])</code></pre></li></ol><h2 id="统计列表中各元素出现的次数"><a href="#统计列表中各元素出现的次数" class="headerlink" title="统计列表中各元素出现的次数"></a>统计列表中各元素出现的次数</h2><pre><code class="python">from Collections import Countera = [1, 2, 3, 2, 4, 2]counter = Counter(a)count_list = dict(counter)print(counter.most_common(3))</code></pre><h2 id="isinstance-方法"><a href="#isinstance-方法" class="headerlink" title="isinstance()方法"></a>isinstance()方法</h2><p>Python中<code>isinstance(object, classinfo)</code>方法用于判断一个对象是否是一个已知的类型，与<code>type()</code>类似。它们的区别在于</p><blockquote><p>type() 不会认为子类是一种父类类型，不考虑继承关系。</p><p>isinstance() 会认为子类是一种父类类型，考虑继承关系。</p><p>如果要判断两个类型是否相同推荐使用 isinstance()。</p></blockquote><p>对于classinfo的选择，可以是<br><code>int</code>，<code>float</code>，<code>bool</code>，<code>complex</code>，<code>str</code>，<code>list</code>，<code>dict</code>，<code>set</code>，<code>tuple</code>。</p><h2 id="global-和-nonlocal"><a href="#global-和-nonlocal" class="headerlink" title="global 和 nonlocal"></a>global 和 nonlocal</h2><p>global用于声明全局变量。如果在函数内部修改函数外的变量，需要在函数中声明全局变量。</p><pre><code class="python">foo = 0def bar():    global foo    foo += 1</code></pre><p>nonlocal用于声明在内层函数中使用的变量。</p><pre><code class="python">def foo1():    bar = 0    def foo2():        nonlocal bar        bar += 1        return bar    return foo2()</code></pre><h1 id="测试程序运行时间"><a href="#测试程序运行时间" class="headerlink" title="测试程序运行时间"></a>测试程序运行时间</h1><p>可以使用<code>time</code>或<code>timeit</code>模块测试程序的运行时间</p><pre><code class="python">def foo(param):    passimport time start = time.time()foo()end = time.time()print(end - start)from timeit import timeitprint(timeit(&#39;foo(x)&#39;, setup=&#39;from __main__ import foo&#39;, globals={&#39;x&#39;: param}), number=1)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;模块修改后再次载入无变化&quot;&gt;&lt;a href=&quot;#模块修改后再次载入无变化&quot; class=&quot;headerlink&quot; title=&quot;模块修改后再次载入无变化&quot;&gt;&lt;/a&gt;模块修改后再次载入无变化&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import 
      
    
    </summary>
    
      <category term="Python" scheme="https://yyb1995.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://yyb1995.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Git常用命令</title>
    <link href="https://yyb1995.github.io/2019/10/18/Git/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://yyb1995.github.io/2019/10/18/Git/Git常用命令/</id>
    <published>2019-10-18T07:14:38.924Z</published>
    <updated>2019-10-18T07:14:38.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="提交一个工程到github"><a href="#提交一个工程到github" class="headerlink" title="提交一个工程到github"></a><a href="https://blog.csdn.net/codingEMIPark/article/details/78016588" target="_blank" rel="noopener">提交一个工程到github</a></h2><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><ul><li>git config –global user.name xxx</li><li>git config –global user.email <a href="mailto:xxx@xxx.com" target="_blank" rel="noopener">xxx@xxx.com</a></li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li><code>git init</code></li><li><code>git pull origin master</code></li><li><code>git push origin master</code></li><li><code>git add .</code></li><li><code>git add -A</code> 提交所有改变（包括删除）</li><li><code>git commit -m &#39;commit_content&#39;</code></li><li><code>git checkout filename</code></li><li><code>git clone xx</code></li><li><code>git clone xx --depth=1</code> 只拷贝最近一次的提交</li></ul><h2 id="在coding-net中添加项目的流程"><a href="#在coding-net中添加项目的流程" class="headerlink" title="在coding.net中添加项目的流程"></a>在coding.net中添加项目的流程</h2><pre><code>1. 将～/.ssh中的public key加入coding.net的设置中2. `git init`3. `git add .`4. `git commit -m &#39;content&#39;`5. `git remote add origin gitaddress`6. `git push origin master`</code></pre><h2 id="创建分支和转换的流程"><a href="#创建分支和转换的流程" class="headerlink" title="创建分支和转换的流程"></a>创建分支和转换的流程</h2><pre><code>1. 创建分支：`git branch &lt;name&gt;`2. 切换分支：`git checkout &lt;name&gt;`3. 创建加切换分支：`git checkout -b &lt;name&gt;`4. 删除本地分支：`git branch -d &lt;branch_name&gt;`</code></pre><h2 id="创建多个远程仓库并上传不同分支"><a href="#创建多个远程仓库并上传不同分支" class="headerlink" title="创建多个远程仓库并上传不同分支"></a>创建多个远程仓库并上传不同分支</h2><pre><code>1. 创建多个远程仓库：`git remote add &lt;name&gt; &lt;address&gt;`. 注意：远程仓库名不能于origin相同2. 上传不同分支到远程仓库： `git push &lt;remote_name&gt; &lt;local name&gt;`3. 删除远程仓库中的分支：`git push &lt;remote_name&gt; --delete &lt;branch_name&gt;`.注意，在github上删除master分支前要先到设置更改默认分支.</code></pre><h2 id="查看git的状态"><a href="#查看git的状态" class="headerlink" title="查看git的状态"></a>查看git的状态</h2><p><code>git status</code></p><h2 id="查看文件修改状态"><a href="#查看文件修改状态" class="headerlink" title="查看文件修改状态"></a>查看文件修改状态</h2><p><code>git diff (filename)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;提交一个工程到github&quot;&gt;&lt;a href=&quot;#提交一个工程到github&quot; class=&quot;headerlink&quot; title=&quot;提交一个工程到github&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://blog.csdn.net/codingEMIPark/ar
      
    
    </summary>
    
      <category term="Git" scheme="https://yyb1995.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://yyb1995.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch知识点学习</title>
    <link href="https://yyb1995.github.io/2019/10/18/Pytorch/Pytorch%E5%AD%A6%E4%B9%A0/"/>
    <id>https://yyb1995.github.io/2019/10/18/Pytorch/Pytorch学习/</id>
    <published>2019-10-18T07:11:06.082Z</published>
    <updated>2019-10-18T07:11:06.084Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-torch-nn和torch-nn-functional中神经网络层的区别"><a href="#1-torch-nn和torch-nn-functional中神经网络层的区别" class="headerlink" title="1 torch.nn和torch.nn.functional中神经网络层的区别"></a>1 torch.nn和torch.nn.functional中神经网络层的区别</h2><p>torch.nn中的层是类，torch.nn.functional中的层是函数。torch.nn中的forward()方法是调用torch.nn.functional实现。因此两者从原理上等价。torch.nn一般用于较复杂层的实现，torch.nn.functional一般用于简单层的实现</p><h2 id="2-Pytorch的层建立方式"><a href="#2-Pytorch的层建立方式" class="headerlink" title="2 Pytorch的层建立方式"></a>2 Pytorch的层建立方式</h2><ol><li><p>nn.Sequential().add_module(layer)</p><pre><code class="python">net1 = nn.Sequential()net1.add_module(&#39;conv&#39;, nn.Conv2d(3, 3, 3))net1.add_module(&#39;batchnorm&#39;, nn.BatchNorm2d(3))net1.add_module(&#39;activation_layer&#39;, nn.ReLU())</code></pre></li><li><p>nn.Sequential(layer)</p><pre><code class="python">net2 = nn.Sequential( nn.Conv2d(3, 3, 3), nn.BatchNorm2d(3), nn.ReLU() )</code></pre></li><li><p>nn.Sequential(OrderedDict([(multi layername, layer)]))</p><pre><code class="python">from collections import OrderedDictnet3 = nn.Sequential(OrderedDict([ (&#39;conv&#39;, nn.Conv2d(3, 3, 3)), (&#39;batchnorm&#39;, nn.BatchNorm2d(3)), (&#39;activation_layer&#39;, nn.ReLU())]))</code></pre></li></ol><pre><code>4. nn.ModuleList([layers])```pythonmodel1 = nn.ModuleList(    nn.Linear(10, 1) for _ in range(3))</code></pre><h2 id="3-Pytorch自定义层的编写"><a href="#3-Pytorch自定义层的编写" class="headerlink" title="3 Pytorch自定义层的编写"></a>3 Pytorch自定义层的编写</h2><p>下面是一个典型的Pytorch自定义层的实现方法</p><pre><code class="python">class ScaledDotProductAttention(nn.Module):    &quot;&quot;&quot; Scaled Dot-Product Attention &quot;&quot;&quot;    def __init__(self, temperature, attn_dropout=0.1):        &quot;&quot;&quot;        :param temperature: scale parameter in the equation            out = Q * K.T / temperature * V. Default is \sqrt d_k        :param attn_dropout: dropout rate in the self-attention            layer        &quot;&quot;&quot;        super(ScaledDotProductAttention, self).__init__()        self.temperature = temperature        self.dropout = nn.Dropout(attn_dropout)        self.softmax = nn.Softmax(dim=2)    def forward(self, q, k, v, mask=None):        &quot;&quot;&quot;        Calculate self-attention output        :param q: size: (batch_size, max_seq_len or input_len, d_k)        :param k: same as q        :param v: size: (batch_size, max_seq_len or input_len, d_k)        :param mask:        :return:        &quot;&quot;&quot;        attn = torch.bmm(q, k.transpose(1, 2))        attn = attn / self.temperature        if mask is not None:            attn = attn.masked_fill(mask, -np.inf)        attn = self.softmax(attn)        attn = self.dropout(attn)        output = torch.bmm(attn, v)        return output, attn</code></pre><p>在<code>self.__init__()</code>函数中，完成对层中要使用的Tensor和调用的层的产生和初始化。初始化可以直接写在<code>__init__()</code>方法中，也可以单独创建一个<code>self.reset_parameters()</code>方法，在<code>__init__()</code>方法中调用。初始化可以自定义，也可以使用<code>torch.nn.init</code>中提供的初始化方法。在该方法中调用的层只是对层的声明，并不是调用。</p><p>在<code>self.forward()</code>方法中，完成对调用该层时完成的功能的编写。层的输出写在return行。</p><h2 id="4-Pytorch中常见的层"><a href="#4-Pytorch中常见的层" class="headerlink" title="4 Pytorch中常见的层"></a>4 Pytorch中常见的层</h2><ol><li><p>LayerNorm<br>LayerNorm层是对数据的最后一维进行归一化。多用在深层RNN中。</p></li><li><p>Conv1d</p><pre><code class="python">Conv1dclass torch.nn.Conv1d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True)</code></pre><p>in_channels是输入数据第二维，out_channels是输出数据第二维，kernel_size是卷积占的列数。<br>输入：shape为(a, b, c)的Tensor。Conv1d在最后一维做卷积，卷积核的维数是(in_channels, out_channels, kernel_size)。输出的第二维是out_channels，说明用out_channels个不同的卷积做运算，输出第三维是c - kernel_size + 1,表示共卷积的次数。</p><pre><code class="python"># 一个Conv1d的例子m = nn.Conv1d(16, 33, 3, stride=2)input = torch.randn(20, 16, 50)output = m(input)print(output.shape)print(m.weight.shape)</code></pre><p>输出为torch.Size([20, 33, 48])和torch.Size([33, 16, 3])。原理为：Conv1d只在最后一维做卷积。第二维由in_channels变为out_channels，说明共有out_channels组卷积核，1组in_channels个，卷积核宽度为3，每个卷积核分别与输入数据第二维中的一行做卷积。</p></li><li><p>Conv2d</p><pre><code class="python">CLASS torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True)# 一个Conv2d的例子：m = nn.Conv2d(16, 33, (3, 4))input = torch.randn(20, 16, 50, 100)output = m(input)print(output.size)print(m.weight.size)</code></pre><p>输出为torch.Size([16, 33, 48, 97])和torch.Size([33, 16, 3, 4])。原理为：Conv2d的in_channels和out_channels与Conv1d保持一致，不同的是kernel_size可以是两维的，也就是同时对input的最后两维进行卷积。其他部分与Conv1d相同。因此由Conv1d不难推出Conv2d的维数变换规律。</p></li></ol><h2 id="5-Pytorch中的数据处理"><a href="#5-Pytorch中的数据处理" class="headerlink" title="5 Pytorch中的数据处理"></a>5 Pytorch中的数据处理</h2><p>reference:<a href="https://zhuanlan.zhihu.com/p/30934236" target="_blank" rel="noopener">Pytorch数据读取(Dataset, DataLoader, DataLoaderIter)</a></p><h3 id="5-1-torch-utils-data-Dataset"><a href="#5-1-torch-utils-data-Dataset" class="headerlink" title="5.1 torch.utils.data.Dataset"></a>5.1 <code>torch.utils.data.Dataset</code></h3><p>reference: <a href="http://pytorch.apachecn.org/cn/docs/0.3.0/data.html?highlight=dataloader#torch.utils.data.Dataset" target="_blank" rel="noopener">Pytorch cn doc</a><br>Dataset是一个抽象类，用于将数据封装成Dataset类。它是一个抽象类。在具体使用时需要继承Dataset类并实现其中的2个方法：</p><ul><li><code>__getitem__(self, index)</code><br> 用于决定每次如何取数据。比如对于形如(batch_size, input_length)的数据，每次读取第index行数据</li><li><code>__len__()</code><br> 用于获取数据的长度</li></ul><pre><code class="python">class DealDataset(Dataset):    &quot;&quot;&quot;        下载数据、初始5. Pytorch中的数据处理数据，都可以在这里完成    &quot;&quot;&quot;    def __init__(self):        xy = np.loadtxt(&#39;../dataSet/diabetes.csv.gz&#39;, delimiter=&#39;,&#39;, dtype=np.float32) # 使用numpy读取数据        self.x_data = torch.from_numpy(xy[:, 0:-1])        self.y_data = torch.from_numpy(xy[:, [-1]])        self.len = xy.shape[0]    def __getitem__(self, index):        return self.x_data[index], self.y_data[index]    def __len__(self):        return self.len</code></pre><h3 id="5-2-torch-utils-data-DataLoader"><a href="#5-2-torch-utils-data-DataLoader" class="headerlink" title="5.2 torch.utils.data.DataLoader"></a>5.2 <code>torch.utils.data.DataLoader</code></h3><p>reference:<a href="http://pytorch.apachecn.org/cn/docs/0.3.0/data.html?highlight=dataloader#torch.utils.data.DataLoader" target="_blank" rel="noopener">Pytorch cn doc</a></p><p>用于定义从Dataset中读取数据的方式，包括batch_size, shuffle等</p><pre><code class="python税务总局发票">class torch.utils.data.DataLoader(dataset, batch_size=1, shuffle=False, sampler=None, batch_sampler=None, num_workers=0, collate_fn=&lt;function default_collate at 0x4316c08&gt;, pin_memory=False, drop_last=False)</code></pre><p>主要参数：</p><ul><li>dataset: dataset对象</li><li>batch_size: 每个 batch 加载多少个样本 (默认值: 1)</li><li>shuffle: 设置为 True 时, 会在每个 epoch 重新打乱数据 (默认值: False).</li></ul><pre><code class="python">train_loader = DataLoader(dataset=dealDataset, batch_size=32, shuffle=True)</code></pre><h3 id="5-3-训练过程"><a href="#5-3-训练过程" class="headerlink" title="5.3 训练过程"></a>5.3 训练过程</h3><pre><code class="python">for epoch in epochs:    for i, batch in enumerate(train_loader):    print(&#39;the {}th batch: {}&#39;.format(i, batch))</code></pre><p><strong>注意:</strong>如果在dataloader中定义了多个返回值，那么在训练过程中每个batch都是一个list，使用batch[i]或者(train, test)来调用每个batch中的参数</p><h2 id="6-Pytorch中的数据类型及相互转换"><a href="#6-Pytorch中的数据类型及相互转换" class="headerlink" title="6 Pytorch中的数据类型及相互转换"></a>6 Pytorch中的数据类型及相互转换</h2><p>Pytorch中dtype是tensor的一个属性，使用<code>tensor.dtype</code>获取一个张量的数据类型。主要包括以下几类：</p><table><thead><tr><th>Data type</th><th>dtype</th><th>Tensor types</th></tr></thead><tbody><tr><td>32-bit floating point</td><td><code>torch.float32</code> or <code>torch.float</code></td><td><code>torch.*.FloatTensor</code></td></tr><tr><td>64-bit floating point</td><td><code>torch.float64</code> or <code>torch.double</code></td><td><code>torch.*.DoubleTensor</code></td></tr><tr><td>16-bit floating point</td><td><code>torch.float16</code> or <code>torch.half</code></td><td><code>torch.*.HalfTensor</code></td></tr><tr><td>8-bit integer (unsigned)</td><td><code>torch.uint8</code></td><td><code>torch.*.ByteTensor</code></td></tr><tr><td>8-bit integer (signed)</td><td><code>torch.int8</code></td><td><code>torch.*.CharTensor</code></td></tr><tr><td>16-bit integer (signed)</td><td><code>torch.int16</code> or <code>torch.short</code></td><td><code>torch.*.ShortTensor</code></td></tr><tr><td>32-bit integer (signed)</td><td><code>torch.int32</code> or <code>torch.int</code></td><td><code>torch.*.IntTensor</code></td></tr><tr><td>64-bit integer (signed)</td><td><code>torch.int64</code> or <code>torch.long</code></td><td><code>torch.*.LongTensor</code></td></tr></tbody></table><p>数据类型的查看：数据类型之间的转换使用<code>Tensor.long()</code>或<code>dtype=torch.long</code>实现。转换函数有：<code>long(), int(), double(), float(), byte()</code></p><p><strong>注意：</strong> </p><ol><li>Pytorch中的一些层对输入的tensor类型有要求。如Embedding层要求输入的tensor为<code>torch.long</code>类型。</li><li>如果Pytorch的数据来源是numpy，要十分注意numpy和pytorch的数据类型匹配。在numpy中，默认数据类型是<code>float</code>，但<code>float</code>与<code>np.float64</code>等价；在pytorch中，整数默认数据类型是<code>torch.long</code>，小数默认数据类型是<code>torch.float</code>，但<code>float</code>与<code>torch.float32</code>等价。也就是说，如果不加转换地使用<code>torch.from_numpy</code>，numpy中的数组将会被转换成pytorch中的<code>torch.double</code>类型。数据类型的不匹配将造成网络无法正确搭建。解决方法：在numpy端将数据转换为<code>np.float32</code>类型，即<code>.astype(np.float32)</code><pre><code class="python">a = np.sin([i for i in range(10)]).astype(np.float)print(a.dtype)</code></pre></li></ol><h2 id="7-Pytorch中的数据运算位置及相互转换"><a href="#7-Pytorch中的数据运算位置及相互转换" class="headerlink" title="7 Pytorch中的数据运算位置及相互转换"></a>7 Pytorch中的数据运算位置及相互转换</h2><p>Pytorch中device是tensor的一个属性，使用<code>tensor.device</code>获取一个张量的运算位置。</p><ul><li>从cpu转换到gpu：<code>tensor.to(&#39;cuda&#39;)</code>或<code>tensor.cuda()</code></li><li>从gpu转换到cpu：<code>tensor.to(&#39;cpu&#39;)</code>或<code>tensor.cpu()</code></li></ul><p>此外，还要注意tensor和numpy数组之间的转换只能在cpu上完成。即要先使用<code>tensor.to(&#39;cpu&#39;)</code>后才能使用<code>tensor.numpy()</code></p><h2 id="8-Pytorch展示模型结构"><a href="#8-Pytorch展示模型结构" class="headerlink" title="8 Pytorch展示模型结构"></a>8 Pytorch展示模型结构</h2><ol><li>展示模型所有层：<code>print(modelname)</code></li><li>展示模型所有参数：<code>print(list(model.named_parameters()))</code></li></ol><h2 id="9-Pytorch学习率调整"><a href="#9-Pytorch学习率调整" class="headerlink" title="9 Pytorch学习率调整"></a>9 Pytorch学习率调整</h2><p>使用的类：torch.optim.lr_scheduler。这个类的optimizer为常用的优化方法。如果使用scheduler，则在训练过程中只需写scheduler.step()而不需写optimizer.step()。</p><p>常用的学习率调整方法：</p><ol><li><p><code>torch.optim.lr_scheduler.StepLR(optimizer, step_size, gamma=0.1, last_epoch=-1)</code> </p><p>每过step_size将learning_rate调整为gamma * learning_rate.</p></li><li><p><code>torch.optim.lr_scheduler.MultiStepLR(optimizer, milestones, gamma=0.1, last_epoch=-1)</code></p><p>每到milestones中包含的训练次数时把learning_rate调整为gamma * learning_rate.</p><p>milestones:包含迭代次数的列表，必须递增。</p></li><li><p><code>torch.optim.lr_scheduler.ReduceLROnPlateau(optimizer, mode=&#39;min&#39;, factor=0.1, patience=10, verbose=False, threshold=0.0001, threshold_mode=&#39;rel&#39;, cooldown=0, min_lr=0, eps=1e-08)</code></p><p>学习率递减函数。当模型性能不再提升时将学习率减少。</p><p>mode: ‘min’或’max’。在’min’模式下，衡量标准不再下降时学习率减小。</p><p>factor: 学习率更新系数</p><p>patience: 学习率更新前指标不再下降/上升的迭代次数</p><p>verbose: 每次更新学习率时是否打印信息</p></li></ol><h2 id="10-Pytorch设置随机数种子"><a href="#10-Pytorch设置随机数种子" class="headerlink" title="10 Pytorch设置随机数种子"></a>10 Pytorch设置随机数种子</h2><pre><code class="python">torch.manual_seed(args.seed)torch.cuda.manual_seed(args.seed)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-torch-nn和torch-nn-functional中神经网络层的区别&quot;&gt;&lt;a href=&quot;#1-torch-nn和torch-nn-functional中神经网络层的区别&quot; class=&quot;headerlink&quot; title=&quot;1 torch.nn和tor
      
    
    </summary>
    
      <category term="Pytorch" scheme="https://yyb1995.github.io/categories/Pytorch/"/>
    
    
      <category term="Pytorch" scheme="https://yyb1995.github.io/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://yyb1995.github.io/2019/10/17/Git/Git%E5%AD%A6%E4%B9%A0/"/>
    <id>https://yyb1995.github.io/2019/10/17/Git/Git学习/</id>
    <published>2019-10-17T13:49:43.994Z</published>
    <updated>2019-10-18T15:00:34.667Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git学习"><a href="#Git学习" class="headerlink" title="Git学习"></a>Git学习</h1><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>Git是由Linux之父使用C语言开发的一个分布式版本控制系统。分布式版本控制系统的特点是没有中央服务器，每一个人的电脑上都有一个完整的版本库。</p><h2 id="Git安装与全局配置"><a href="#Git安装与全局配置" class="headerlink" title="Git安装与全局配置"></a>Git安装与全局配置</h2><p>在Windows系统下可以从官网下载Git安装包。在Mac系统下已经自带Git，如果需要安装更新版本，可以使用homebrew。</p><p>在安装完成后，可以进行全局用户名和电子邮件设置</p><pre><code class="git">git config --global user.name &#39;name&#39;git config --global user.email &#39;123@example.com&#39;</code></pre><p>如果忘记已经设置的用户名和电子邮件，可以使用以下命令查看</p><pre><code class="git">git config --global user.namegit config --global user.email</code></pre><p>如果文件夹名称中有中文，会出现乱码情况。可以使用<br><code>git config --global core.quotepath false</code></p><p>在Mac下git默认语言为中文，如果想改为中文，可以在<code>~/.zshrc</code>中加入<br><code>export LC_ALL=en_US.UTF-8</code></p><h2 id="创建一个仓库"><a href="#创建一个仓库" class="headerlink" title="创建一个仓库"></a>创建一个仓库</h2><p><code>git init</code></p><h2 id="把文件添加到仓库"><a href="#把文件添加到仓库" class="headerlink" title="把文件添加到仓库"></a>把文件添加到仓库</h2><p><code>git add filename</code></p><h2 id="对本次操作进行说明"><a href="#对本次操作进行说明" class="headerlink" title="对本次操作进行说明"></a>对本次操作进行说明</h2><p><code>git commit -m &#39;add a file&#39;</code></p><h2 id="查看仓库当前状态"><a href="#查看仓库当前状态" class="headerlink" title="查看仓库当前状态"></a>查看仓库当前状态</h2><p><code>git status</code></p><h2 id="查看具体文件修改的内容"><a href="#查看具体文件修改的内容" class="headerlink" title="查看具体文件修改的内容"></a>查看具体文件修改的内容</h2><p><code>git diff filename</code></p><h2 id="查看版本历史记录"><a href="#查看版本历史记录" class="headerlink" title="查看版本历史记录"></a>查看版本历史记录</h2><ul><li><p>完整显示<br><code>git log</code></p></li><li><p>单行显示<br><code>git log --pretty=oneline</code></p></li></ul><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><ul><li><p>回退一个版本<br><code>git reset --hard HEAD^</code></p></li><li><p>回退n个版本<br><code>git reset --hard HEAD~n</code></p></li><li><p>根据版本号回退版本(不需写完整版本号)<br><code>git reset --hard 1234a</code></p></li><li><p>误操作时查看命令历史和版本号<br><code>git reflog</code></p></li></ul><h2 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h2><p>在Git中，平时工作的文件夹称为工作区，<code>.git</code>目录中存放的称为版本库。在版本库中存在一个暂存区。<code>git add</code>可以把文件放入暂存区。<code>git commit</code>可以把暂存区的改动提交到新的分支。如果对文件进行了多次修改，只有经过了<code>git add</code>的改动才会被暂存区记录，否则不会被记录。</p><h2 id="丢弃某个文件的修改-还原文件"><a href="#丢弃某个文件的修改-还原文件" class="headerlink" title="丢弃某个文件的修改(还原文件)"></a>丢弃某个文件的修改(还原文件)</h2><ul><li>这个修改没有经过<code>git add</code>加入暂存区</li></ul><p><code>git checkout -- file</code></p><ul><li>这个修改已经经过<code>git add</code>加入暂存区<pre><code class="git">git reset --hard HEAD~git checkout -- file</code></pre></li></ul><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><ul><li>删除没有经过<code>git add</code>的文件</li></ul><p><code>rm file</code></p><ul><li>删除已经经过<code>git add</code>的文件</li></ul><pre><code class="git">rm filegit rm file</code></pre><h2 id="本地仓库与远程仓库的结合"><a href="#本地仓库与远程仓库的结合" class="headerlink" title="本地仓库与远程仓库的结合"></a>本地仓库与远程仓库的结合</h2><ul><li>把一个本地仓库与远程仓库关联</li></ul><p><code>git remote add origin git@github.com:xxx.git</code></p><p>其中<code>origin</code>表示远程仓库名。</p><ul><li>把本地仓库的内容推送到远程仓库</li></ul><p><code>git push -u origin master</code></p><ul><li>把远程仓库的内容拷贝到本地仓库<br><code>git clone git@github.com:xxx.git</code></li></ul><h2 id="git分支"><a href="#git分支" class="headerlink" title="git分支"></a>git分支</h2><ul><li>创建一个分支并切换到该分支</li></ul><p><code>git checkout -b dev</code></p><p><code>git switch -c dev</code></p><ul><li>创建一个分支</li></ul><p><code>git branch dev</code></p><ul><li>删除一个分支</li></ul><p><code>git branch -d dev</code></p><ul><li>切换到dev分支</li></ul><p><code>git checkout dev</code></p><p><code>git switch dev</code></p><ul><li>查看所有分支</li></ul><p><code>git branch</code></p><ul><li>把a分支合并到b分支</li></ul><pre><code class="git">git checkout bgit merge a</code></pre><ul><li>非快速合并模式<br><code>git merge --no-ff -m &#39;merge with no-diff&#39; dev</code></li></ul><h2 id="保存和恢复当前没提交的工作"><a href="#保存和恢复当前没提交的工作" class="headerlink" title="保存和恢复当前没提交的工作"></a>保存和恢复当前没提交的工作</h2><ul><li><p>保存暂存区的工作<br><code>git stash</code></p></li><li><p>恢复暂存区的工作并删除临时存储内容<br><code>git stash pop</code></p></li></ul><h2 id="把特定修改复制到当前分支"><a href="#把特定修改复制到当前分支" class="headerlink" title="把特定修改复制到当前分支"></a>把特定修改复制到当前分支</h2><p><code>git cherry-pick 1234ab</code></p><h2 id="查看远程地址"><a href="#查看远程地址" class="headerlink" title="查看远程地址"></a>查看远程地址</h2><ul><li><p>简略查看<br><code>git remote</code></p></li><li><p>详细查看<br><code>git remote -v</code></p></li></ul><h2 id="给特定的提交打标签"><a href="#给特定的提交打标签" class="headerlink" title="给特定的提交打标签"></a>给特定的提交打标签</h2><ul><li>给当前HEAD打标签</li></ul><p><code>git tag tagname</code></p><ul><li><p>给某个特定分支打标签<br><code>git tag tagname commit-id</code></p></li><li><p>给标签加上说明文字<br><code>git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb</code></p></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/897271968352576" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/896043488029600</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Git学习&quot;&gt;&lt;a href=&quot;#Git学习&quot; class=&quot;headerlink&quot; title=&quot;Git学习&quot;&gt;&lt;/a&gt;Git学习&lt;/h1&gt;&lt;h2 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>json</title>
    <link href="https://yyb1995.github.io/2019/10/02/PythonPackages/json/"/>
    <id>https://yyb1995.github.io/2019/10/02/PythonPackages/json/</id>
    <published>2019-10-02T07:27:53.407Z</published>
    <updated>2019-10-02T08:20:21.227Z</updated>
    
    <content type="html"><![CDATA[<p>python中的json模块用于python对象与json对象的转换及json文件的读写。</p><h2 id="json-dump"><a href="#json-dump" class="headerlink" title="json.dump"></a><code>json.dump</code></h2><p>这个函数主要用于把对象转成str类型并写入json文件。</p><pre><code class="python">import jsondict1 = {&#39;a&#39;: 1}with open(&#39;a.json&#39;, &#39;w&#39;) as f:    json.dump(dict1, f)</code></pre><h2 id="json-load"><a href="#json-load" class="headerlink" title="json.load"></a><code>json.load</code></h2><p>这个函数主要用于从json文件中读取数据并转成python中对应的对象。</p><pre><code class="python">import jsonwith open(&quot;a.json&quot;, &quot;r&quot;) as f:    dict1 = json.load(f)    print(dict1)</code></pre><h2 id="json-dumps"><a href="#json-dumps" class="headerlink" title="json.dumps"></a><code>json.dumps</code></h2><p>这个函数主要用于把python中的对象转成json格式的str，因为如果直接将dict类型的数据写入json文件中会发生报错，因此在将数据写入时需要用到该函数。可以传入indent=2参数，结构更清晰。如果对象中有中文，可以传入ensure_ascii=False参数确保显示正确。</p><pre><code class="python">import jsondict1 = {&quot;name&quot;: &quot;tom&quot;}str1 = json.dumps(dict1)print(type(str1))with open(&#39;a.json&#39;, &#39;w&#39;) as f:    f.write(str1)</code></pre><h2 id="json-loads"><a href="#json-loads" class="headerlink" title="json.loads"></a><code>json.loads</code></h2><p>这个函数主要用于把json形式的str转化为python对象。</p><pre><code class="python">with open(&#39;a.json&#39;, &#39;r&#39;) as f:    str1 = f.read()dict1 = json.loads(str1)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;python中的json模块用于python对象与json对象的转换及json文件的读写。&lt;/p&gt;
&lt;h2 id=&quot;json-dump&quot;&gt;&lt;a href=&quot;#json-dump&quot; class=&quot;headerlink&quot; title=&quot;json.dump&quot;&gt;&lt;/a&gt;&lt;code&gt;
      
    
    </summary>
    
      <category term="Python Packages" scheme="https://yyb1995.github.io/categories/Python-Packages/"/>
    
    
  </entry>
  
  <entry>
    <title>python中的正则表达式——re模块</title>
    <link href="https://yyb1995.github.io/2019/09/30/PythonPackages/re/"/>
    <id>https://yyb1995.github.io/2019/09/30/PythonPackages/re/</id>
    <published>2019-09-30T03:30:51.664Z</published>
    <updated>2019-10-02T02:11:32.580Z</updated>
    
    <content type="html"><![CDATA[<p>参考教程：<a href="https://www.runoob.com/python/python-reg-expressions.html" target="_blank" rel="noopener">https://www.runoob.com/python/python-reg-expressions.html</a></p><p>一些有用的技巧：</p><ol><li><code>(?P&lt;tag\d&gt;)</code>。这种表示方式可以为搜索结果分组。在获取结果时可以使用<code>result.group(&#39;tag&#39;)</code>。通常用于<code>re.search()</code>和`re.match(</li><li><code>re.S</code>表示把<code>.</code>认为是<code>(.|\n)</code>，也就是<code>.</code>包含换行符。<code>re.I</code>表示忽略大小写。</li><li><code>re.findall()</code>返回一个列表，列表中每个元素表示一个匹配。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考教程：&lt;a href=&quot;https://www.runoob.com/python/python-reg-expressions.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.runoob.com/python/pyt
      
    
    </summary>
    
      <category term="Python" scheme="https://yyb1995.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>正则表达式学习和查询网站</title>
    <link href="https://yyb1995.github.io/2019/07/09/Regex/%E5%B8%B8%E7%94%A8%E6%9F%A5%E8%AF%A2%E7%BD%91%E7%AB%99/"/>
    <id>https://yyb1995.github.io/2019/07/09/Regex/常用查询网站/</id>
    <published>2019-07-09T03:07:19.624Z</published>
    <updated>2019-07-09T03:07:19.624Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正则表达式学习和查询网站"><a href="#正则表达式学习和查询网站" class="headerlink" title="正则表达式学习和查询网站"></a>正则表达式学习和查询网站</h2><ol><li><a href="https://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="noopener">正则表达式30分钟入门教程</a></li><li><a href="http://tool.oschina.net/uploads/apidocs/jquery/regexp.html" target="_blank" rel="noopener">正则表达式手册</a></li><li><a href="https://docs.microsoft.com/zh-cn/dotnet/standard/base-types/regular-expression-language-quick-reference" target="_blank" rel="noopener">正则表达式快速参考</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;正则表达式学习和查询网站&quot;&gt;&lt;a href=&quot;#正则表达式学习和查询网站&quot; class=&quot;headerlink&quot; title=&quot;正则表达式学习和查询网站&quot;&gt;&lt;/a&gt;正则表达式学习和查询网站&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://deercha
      
    
    </summary>
    
      <category term="Regex" scheme="https://yyb1995.github.io/categories/Regex/"/>
    
    
      <category term="正则表达式" scheme="https://yyb1995.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式一些知识点</title>
    <link href="https://yyb1995.github.io/2019/07/09/Regex/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://yyb1995.github.io/2019/07/09/Regex/常用正则表达式/</id>
    <published>2019-07-09T03:07:19.624Z</published>
    <updated>2019-07-09T03:07:19.624Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-括号的区别"><a href="#1-括号的区别" class="headerlink" title="1 括号的区别"></a>1 括号的区别</h2><ul><li><p>小括号()：匹配小括号内的字符串，可以是一个，也可以是多个，常跟“|”（或）符号搭配使用，是多选结构的。<strong>通俗的说小括号匹配的是具体的字符</strong><br>示例1：string name = “way2014”;  regex：(way|zgw)  result：结果是可以匹配出way的，因为是多选结构，小括号是匹配字符串的<br>示例2：string text = “123456789”;  regex：(0-9)　result：结果是什么都匹配不到的，它只匹配字符串”0-9”而不是匹配数字, [0-9]这个字符组才是匹配0-9的数字</p></li><li><p>中括号[]：匹配字符组内的字符，比如咱们常用的[0-9a-zA-Z.*?!]等，在[]内的字符都是字符，不是元字符，比如“0-9”、“a-z”这中间的“-”就是连接符号，表示范围的元字符，如果写成[-!?*(]这样的话，就是普通字符。<strong>通俗的说中括号匹配的是元字符</strong><br>示例1： string text = “1234567890”;  regex：[0-9]  result：结果是可以匹配出字符串text内的任意数字了，像上边的【或符号“|”在字符组内就是一个普通字符】<br>示例2：string text = “a|e|s|v”;  regex：[a|e|s]  result：结果就是匹配字符a、e、|三个字符，这个跟(a|e|s)有区别的，区别就是(a|e|s)匹配的是a、e、s三个字符的随意一个，三个中的任意一个，这是的|是元字符</p></li><li><p>大括号{}：匹配次数，匹配在它之前表达式匹配出来的元素出现的次数，{n}出现n次、{n,}匹配最少出现n次、{n,m}匹配最少出现n次，最多出现m次</p></li></ul><h2 id="2-替换一部分内容"><a href="#2-替换一部分内容" class="headerlink" title="2 替换一部分内容"></a>2 替换一部分内容</h2><p>在替换正则表达式内容时，有时需要保持一部分内容不变。具体做法是：将需要保留的部分用小括号括起来，在修改后的表达式中使用<code>$1</code>,<code>$2</code>…引用。<code>$0</code>表示整个匹配项。如：<br>把trim(ABC)替换成trim(replace(ABC,char(9),’    ‘)，正则表达式为：<br><code>trim\(([^).]*)\)</code>替换成<code>trim\(replace\($1,char\(9\),&#39;    &#39;\)</code><br>place($1,char(9),’    ‘)`</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-括号的区别&quot;&gt;&lt;a href=&quot;#1-括号的区别&quot; class=&quot;headerlink&quot; title=&quot;1 括号的区别&quot;&gt;&lt;/a&gt;1 括号的区别&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;小括号()：匹配小括号内的字符串，可以是一个，也可以是多个，常跟“|”（或）符号搭
      
    
    </summary>
    
      <category term="Regex" scheme="https://yyb1995.github.io/categories/Regex/"/>
    
    
      <category term="正则表达式" scheme="https://yyb1995.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch使用过程中遇到的问题</title>
    <link href="https://yyb1995.github.io/2019/07/09/Pytorch/Pytorch%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://yyb1995.github.io/2019/07/09/Pytorch/Pytorch遇到的问题/</id>
    <published>2019-07-09T03:07:19.623Z</published>
    <updated>2019-07-09T03:07:19.623Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-tensor-to-device-和module-to-device"><a href="#1-tensor-to-device-和module-to-device" class="headerlink" title="1 tensor.to(device)和module.to(device)"></a>1 <code>tensor.to(device)</code>和<code>module.to(device)</code></h2><p><code>tensor.to(device)</code>不是inplace operation。因此在给一个tensor指定device时需要用：<code>tensor1 = tensor1.to(device)</code>。而<code>Module.to(device)</code>是inplace operation，因此直接使用<code>Module.to(device)</code>即可。</p><h2 id="2-Numpy和Tensor的数据转换"><a href="#2-Numpy和Tensor的数据转换" class="headerlink" title="2 Numpy和Tensor的数据转换"></a>2 Numpy和Tensor的数据转换</h2><p>在将Numpy的数据转化为Tensor时，需要注意一个问题。Numpy中默认浮点类型是<code>np.float64</code>，Pytorch中默认浮点类型是<code>torch.float32</code>。直接使用<code>torch.tensor(array)</code>得到的会是<code>torch.double</code>类型的数据。如果想得到<code>torch.float</code>类型的数据，需要对Numpy数据进行类型转换：<code>array = array.astype(np.float32)</code></p><h2 id="3-‘bool-value-of-Tensor-with-more-than-one-value-is-ambiguous’"><a href="#3-‘bool-value-of-Tensor-with-more-than-one-value-is-ambiguous’" class="headerlink" title="3 ‘bool value of Tensor with more than one value is ambiguous’"></a>3 ‘bool value of Tensor with more than one value is ambiguous’</h2><p>这种情况可能是损失函数声明时没有加括号。即应该是<code>loss_function=nn.MSELoss()</code>而不是<code>loss_function=nn.MSELoss</code></p><h2 id="4-Dataloader的数据格式"><a href="#4-Dataloader的数据格式" class="headerlink" title="4 Dataloader的数据格式"></a>4 Dataloader的数据格式</h2><p>在使用Dataloader导入训练数据时，会使用<code>for batch in dataloader</code>，<code>batch</code>实际上是一个包含所有data的列表。即使只有一组数据，也必须使用<code>batch[0]</code>对数据进行提取。</p><h2 id="5-在训练过程中loss不下降"><a href="#5-在训练过程中loss不下降" class="headerlink" title="5 在训练过程中loss不下降"></a>5 在训练过程中loss不下降</h2><p>一种可能原因是在计算<code>loss = torch.nn.functional.mseloss(output, real)</code>时，output和real的维数不完全一致。</p><h2 id="6-matplotlib和pytorch同时导入报错"><a href="#6-matplotlib和pytorch同时导入报错" class="headerlink" title="6 matplotlib和pytorch同时导入报错"></a>6 matplotlib和pytorch同时导入报错</h2><p>在同时导入matplotlib和pytorch.optim时报错：<code>Process finished with exit code -1073740791 (0xC0000409)</code>。解决方法：先导入pytorch再导入matplotlib，如下：</p><pre><code class="python">import torch.optim as optimport matplotlib.pyplot as plt</code></pre><h2 id="7-Pytorch显存不足"><a href="#7-Pytorch显存不足" class="headerlink" title="7 Pytorch显存不足"></a>7 Pytorch显存不足</h2><p>在使用Pytorch时，有时可能遇到显存不足的问题。即<code>RuntimeError: CUDA out of memory. Tried to allocate 11.88 MiB (GPU 0; 6.00 GiB total capacity; 4.52 GiB already allocated; 11.60 MiB free; 758.50 KiB cached)</code>。出现这种问题的原因可能是在保存结果时将过大的张量保存在GPU中，导致GPU存储空间不足。解决方法：检查所有存储在GPU中的张量，将其中一些较大的用<code>tensor.to(&#39;cpu&#39;)</code>转到内存中储存。</p><p>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-tensor-to-device-和module-to-device&quot;&gt;&lt;a href=&quot;#1-tensor-to-device-和module-to-device&quot; class=&quot;headerlink&quot; title=&quot;1 tensor.to(device)和
      
    
    </summary>
    
      <category term="Pytorch" scheme="https://yyb1995.github.io/categories/Pytorch/"/>
    
    
      <category term="Pytorch" scheme="https://yyb1995.github.io/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch入门</title>
    <link href="https://yyb1995.github.io/2019/07/09/Pytorch/Pytorch%E5%85%A5%E9%97%A8/"/>
    <id>https://yyb1995.github.io/2019/07/09/Pytorch/Pytorch入门/</id>
    <published>2019-07-09T03:07:19.622Z</published>
    <updated>2019-07-09T03:07:19.622Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Pytorch教程"><a href="#1-Pytorch教程" class="headerlink" title="1 Pytorch教程"></a>1 Pytorch教程</h2><ol><li><a href="http://pytorch.apachecn.org/cn/docs/0.3.0/" target="_blank" rel="noopener">Pytorch中文文档</a></li><li><a href="https://pytorch.org/docs/stable/index.html" target="_blank" rel="noopener">Pytorch英文文档</a></li><li><a href="http://pytorch.org/tutorials/beginner/deep_learning_60min_blitz.html" target="_blank" rel="noopener">英文版：http://pytorch.org/tutorials/beginner/deep_learning_60min_blitz.html</a></li><li><a href="https://www.jianshu.com/p/889dbc684622" target="_blank" rel="noopener">中文版：https://www.jianshu.com/p/889dbc684622</a></li><li><a href="https://zhuanlan.zhihu.com/p/28475866" target="_blank" rel="noopener">Pytorch github项目整理</a></li></ol><h2 id="2-Pytorch安装"><a href="#2-Pytorch安装" class="headerlink" title="2 Pytorch安装"></a>2 Pytorch安装</h2><ol><li>建议使用Anaconda安装。清华大学anaconda pytorch地址： <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Pytorch教程&quot;&gt;&lt;a href=&quot;#1-Pytorch教程&quot; class=&quot;headerlink&quot; title=&quot;1 Pytorch教程&quot;&gt;&lt;/a&gt;1 Pytorch教程&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://pytorch.apac
      
    
    </summary>
    
      <category term="Pytorch" scheme="https://yyb1995.github.io/categories/Pytorch/"/>
    
    
      <category term="Pytorch" scheme="https://yyb1995.github.io/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>数据可视化Seaborn从零开始学习教程（四） 分类数据可视化篇</title>
    <link href="https://yyb1995.github.io/2019/07/09/PythonPackages/seaborn/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%20Seaborn%20%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89%20%E5%88%86%E7%B1%BB%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AF%87/"/>
    <id>https://yyb1995.github.io/2019/07/09/PythonPackages/seaborn/数据可视化 Seaborn 从零开始学习教程（四） 分类数据可视化篇/</id>
    <published>2019-07-09T03:07:19.621Z</published>
    <updated>2019-07-09T03:07:19.621Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自<a href="https://segmentfault.com/a/1190000015310299" target="_blank" rel="noopener">数据可视化Seaborn从零开始学习教程（四） 分类数据可视化篇</a></p></blockquote><h2 id="Seaborn-学习大纲"><a href="#Seaborn-学习大纲" class="headerlink" title="Seaborn 学习大纲"></a>Seaborn 学习大纲</h2><p><code>seaborn</code>的学习内容主要包含以下几个部分：</p><ol><li><p><strong>风格管理</strong></p><ul><li>绘图风格设置</li><li>颜色风格设置</li></ul></li><li><p><strong>绘图方法</strong></p><ul><li>数据集的分布可视化</li><li>分类数据可视化</li><li>线性关系可视化</li></ul></li><li><p><strong>结构网格</strong></p><ul><li>数据识别网格绘图</li></ul></li></ol><p>本次将主要介绍分类数据可视化的使用。</p><h2 id="分类数据可视化"><a href="#分类数据可视化" class="headerlink" title="分类数据可视化"></a>分类数据可视化</h2><p>数据集中的数据类型有很多种，除了连续的特征变量之外，最常见的就是类目型的数据类型了，常见的比如人的性别，学历，爱好等。这些数据类型都不能用连续的变量来表示，而是用分类的数据来表示。</p><p><code>seaborn</code>针对分类型的数据有专门的可视化函数，这些函数可大致分为三种：</p><ul><li><strong>分类数据散点图：</strong> swarmplot(), stripplot()</li><li><strong>分类数据的分布图：</strong> boxplot(), violinplot()</li><li><strong>分类数据的统计估算图 ：</strong> barplot(), pointplot()</li></ul><p>这三类函数可有特点，可以从各个方面展示分类数据的可视化效果，下面我们一一介绍。<br>首先的首先还是先导入需要的模块和数据集。</p><pre><code>%matplotlib inlineimport numpy as npimport pandas as pdimport matplotlib as mplimport matplotlib.pyplot as pltimport seaborn as snssns.set(style=&quot;whitegrid&quot;, color_codes=True)np.random.seed(sum(map(ord, &quot;categorical&quot;)))titanic = sns.load_dataset(&quot;titanic&quot;)tips = sns.load_dataset(&quot;tips&quot;)iris = sns.load_dataset(&quot;iris&quot;)</code></pre><h4 id="分类数据散点图"><a href="#分类数据散点图" class="headerlink" title="分类数据散点图"></a>分类数据散点图</h4><p>在分类数据的基础上展示定量数据的最简单函数就是 stripplot()。</p><pre><code>sns.stripplot(x=&quot;day&quot;, y=&quot;total_bill&quot;, data=tips);</code></pre><p><img src="https://segmentfault.com/img/bVbco27?w=571&h=342" alt></p><p>这看上去类似散点图，但不同的是，横坐标是分类的数据，只不过一些数据点上会互相重叠，不便于观察。所以一个简单的解决办法是加入<code>jitter</code>参数，调整横坐标位置。</p><pre><code>sns.stripplot(x=&quot;day&quot;, y=&quot;total_bill&quot;, data=tips, jitter=True);</code></pre><p><img src="https://segmentfault.com/img/bVbco3a?w=563&h=346" alt></p><p>当然，还有一个不同的方法就是使用 swarmplot() 函数，这个函数的好处就是所有的点都不会重叠，这样可以很清晰的观察到数据的分布。</p><pre><code>sns.swarmplot(x=&quot;day&quot;, y=&quot;total_bill&quot;, data=tips);</code></pre><p><img src="https://segmentfault.com/img/bVbco3b?w=559&h=346" alt></p><p>在这基础上，也可以通过 hue 参数加入另一个嵌套的分类变量，而且嵌套的分类变量可以以不同的颜色区别，十分方便。</p><pre><code>sns.swarmplot(x=&quot;day&quot;, y=&quot;total_bill&quot;, hue=&quot;sex&quot;, data=tips);</code></pre><p><img src="https://segmentfault.com/img/bVbco3d?w=563&h=344" alt></p><p>通常情况下，seaborn 还会尝试推断出分类变量的顺序。如果你的数据是 pandas 的分类数据类型，那么就是使用默认的分类数据顺序，如果是其他的数据类型，字符串类型的类别将按照它们在 DataFrame 中显示的顺序进行绘制，但是数组类别将被排序：</p><pre><code>sns.swarmplot(x=&quot;size&quot;, y=&quot;total_bill&quot;, data=tips);</code></pre><p><img src="https://segmentfault.com/img/bVbco3f?w=563&h=351" alt></p><p>有时候将分类变量放在垂直轴上是非常有用的（当类别名称相对较长或有很多类别时，这一点特别有用）。 可以使用 orient 关键字强制定向，但通常可以互换 x 和 y 的变量的数据类型来完成：</p><pre><code>sns.swarmplot(x=&quot;total_bill&quot;, y=&quot;day&quot;, hue=&quot;time&quot;, data=tips);</code></pre><p><img src="https://segmentfault.com/img/bVbco3g?w=589&h=351" alt></p><h4 id="分类数据分布图"><a href="#分类数据分布图" class="headerlink" title="分类数据分布图"></a>分类数据分布图</h4><p>虽然分类的散点图很有用，但有时候想要快速查看各分类下的数据分布就不是很直观了。为此，第二种函数解决了这个问题。</p><p><strong>箱型图</strong><br>通过箱型图可以很直观的观察到数据的四分位分布（1/4 分位，中位数，3/4 分位，以及四分位距），这种可视化对于在机器学习的预处理阶段（尤其是发现数据异常离散值）十分有效。</p><pre><code>sns.boxplot(x=&quot;day&quot;, y=&quot;total_bill&quot;, hue=&quot;time&quot;, data=tips);</code></pre><p><img src="https://segmentfault.com/img/bVbco3j?w=561&h=348" alt></p><p>对于箱型图来说，使用 hue 参数的假设是这个变量嵌套在 x 或者 y 轴内。所以默认的情况下，hue 变量的不同类型值会保持偏置状态（两类或几类数据共同在 x 轴数据类型的一个类中），就像上面那个图所示。但是如果 hue 所使用的变量不是嵌套的，那么你可以使用 dodge 参数来禁止这个默认的偏置状态。</p><pre><code>tips[&quot;weekend&quot;] = tips[&quot;day&quot;].isin([&quot;Sat&quot;, &quot;Sun&quot;])sns.boxplot(x=&quot;day&quot;, y=&quot;total_bill&quot;, hue=&quot;weekend&quot;, data=tips, dodge=False);</code></pre><p><img src="https://segmentfault.com/img/bVbco3k?w=563&h=350" alt></p><p><strong>提琴图</strong><br>另一种不同的方法是 violinplot() 函数，它结合了箱体图和分布教程中描述的核心密度估计过程：</p><pre><code>sns.violinplot(x=&quot;total_bill&quot;, y=&quot;day&quot;, hue=&quot;time&quot;, data=tips);</code></pre><p><img src="https://segmentfault.com/img/bVbco3p?w=559&h=344" alt></p><p>这种方法使用核密度估计来更好地描述值的分布。此外，小提琴内还显示了箱体四分位数和四分位距。由于小提琴使用 KDE，还有一些其他可以调整的参数，相对于简单的 boxplot 增加了一些复杂性：</p><pre><code>sns.violinplot(x=&quot;total_bill&quot;, y=&quot;day&quot;, hue=&quot;time&quot;, data=tips,               bw=.1, scale=&quot;count&quot;, scale_hue=False);</code></pre><p><img src="https://segmentfault.com/img/bVbco3q?w=552&h=348" alt></p><p>当 hue 的嵌套类型只有两类的时候，也可以使用 split 参数将小提琴分割：</p><pre><code>sns.violinplot(x=&quot;day&quot;, y=&quot;total_bill&quot;, hue=&quot;sex&quot;, data=tips, split=True);</code></pre><p><img src="https://segmentfault.com/img/bVbco3r?w=543&h=349" alt></p><p>在提琴图内，也可以使用 inner 参数以横线的形式来展示每个观察点的分布，来代替箱型的整体分布：</p><pre><code>sns.violinplot(x=&quot;day&quot;, y=&quot;total_bill&quot;, hue=&quot;sex&quot;, data=tips,               split=True, inner=&quot;stick&quot;, palette=&quot;Set3&quot;);</code></pre><p><img src="https://segmentfault.com/img/bVbco3s?w=543&h=350" alt></p><p>还有一点比较好的是，可以将 swarmplot()，violinplot()，或 boxplot() 混合使用，这样可以结合多种绘图的特点展示更完美的效果。</p><pre><code>sns.violinplot(x=&quot;day&quot;, y=&quot;total_bill&quot;, data=tips, inner=None)sns.swarmplot(x=&quot;day&quot;, y=&quot;total_bill&quot;, data=tips, color=&quot;w&quot;, alpha=.5);</code></pre><p><img src="https://segmentfault.com/img/bVbco3u?w=548&h=354" alt></p><h4 id="分类数据统计估计图"><a href="#分类数据统计估计图" class="headerlink" title="分类数据统计估计图"></a>分类数据统计估计图</h4><p>有时候，我们不想展示分类数据下的分布，而是想展示每一类的集中趋势。seaborn 有两个主要的方法来展示这个，并且这些函数 api 与上面函数的用法是一样的。<br><strong>条形图</strong><br>我们最熟悉的方式就是使用一个条形图。 在 Seaborn 中 barplot() 函数会在整个数据集上显示估计，默认情况下使用均值进行估计。 当在每个类别中有多个类别时（使用了 hue），它可以使用引导来计算估计的置信区间，并使用误差条来表示置信区间：</p><pre><code>sns.barplot(x=&quot;sex&quot;, y=&quot;survived&quot;, hue=&quot;class&quot;, data=titanic);</code></pre><p><img src="https://segmentfault.com/img/bVbco3w?w=569&h=345" alt></p><p>条形图的特殊情况是当您想要显示每个类别的数量，而不是计算统计量。这有点类似于一个分类而不是定量变量的直方图。在 Seaborn 中，使用 countplot() 函数很轻易的完成：</p><pre><code>sns.countplot(x=&quot;deck&quot;, data=titanic, palette=&quot;Greens_d&quot;);</code></pre><p><img src="https://segmentfault.com/img/bVbco3x?w=546&h=345" alt></p><p>如果将要计数的变量移动到 y 轴上，那么条形就会横过来显示：</p><pre><code>sns.countplot(y=&quot;deck&quot;, hue=&quot;class&quot;, data=titanic, palette=&quot;Greens_d&quot;);</code></pre><p><img src="https://segmentfault.com/img/bVbco3B?w=552&h=355" alt></p><p><strong>点图</strong></p><p>pointplot() 函数提供了估计可视化的另一种风格。该函数会用高度估计值对数据进行描述，而不是显示一个完整的条形，它只绘制点估计和置信区间。另外，点图连接相同 hue 类别的点，比如 male 中的蓝色会连接 female 中的蓝色。这使得很容易看出主要关系如何随着第二个变量的变化而变化，因为你的眼睛可以很好地辨别斜率的差异：</p><pre><code>sns.pointplot(x=&quot;sex&quot;, y=&quot;survived&quot;, hue=&quot;class&quot;, data=titanic);</code></pre><p><img src="https://segmentfault.com/img/bVbco3G?w=553&h=350" alt></p><p>为了使能够更好的显示，可以使用不同的标记和线条样式来展示不同 hue 类别的层次:</p><pre><code>sns.pointplot(x=&quot;class&quot;, y=&quot;survived&quot;, hue=&quot;sex&quot;, data=titanic,              palette={&quot;male&quot;: &quot;g&quot;, &quot;female&quot;: &quot;m&quot;},              markers=[&quot;^&quot;, &quot;o&quot;], linestyles=[&quot;-&quot;, &quot;--&quot;]);</code></pre><p><img src="https://segmentfault.com/img/bVbco3H?w=546&h=352" alt></p><h4 id="绘制-“宽格式”-数据"><a href="#绘制-“宽格式”-数据" class="headerlink" title="绘制 “宽格式” 数据"></a>绘制 “宽格式” 数据</h4><p>虽然使用 “长格式” 或“整洁”数据是优选的，但是这些函数也可以应用于各种格式的 “宽格式” 数据，包括 pandas DataFrame 或二维 numpy 数组阵列。这些对象应该直接传递给数据参数：</p><pre><code>sns.boxplot(data=iris, orient=&quot;h&quot;);</code></pre><p><img src="https://segmentfault.com/img/bVbco3O?w=606&h=334" alt></p><p>此外，这些函数也接受 Pandas 或 numpy 对象的向量，而不仅仅是 DataFrame 中的变量：</p><pre><code>sns.violinplot(x=iris.species, y=iris.sepal_length);</code></pre><p><img src="https://segmentfault.com/img/bVbco3Q?w=557&h=344" alt></p><p>为了控制由上述函数制作的图形的大小和形状，你必须使用 matplotlib 命令自己设置图形。 当然，这也意味着这些图块可以和其他种类的图块一起在一个多面板的绘制中共存：</p><pre><code>f, ax = plt.subplots(figsize=(7, 3))sns.countplot(y=&quot;deck&quot;, data=titanic, color=&quot;c&quot;);</code></pre><p><img src="https://segmentfault.com/img/bVbco3S?w=610&h=281" alt></p><h4 id="绘制多层面板分类图"><a href="#绘制多层面板分类图" class="headerlink" title="绘制多层面板分类图"></a>绘制多层面板分类图</h4><p>正如我们上面提到的，有两种方法可以在 Seaborn 中绘制分类图。与回归图中的二元性相似，您可以使用上面介绍的函数，也可以使用更高级别的函数 factorplot()，将这些函数与 FacetGrid() 相结合，通过这个图形的更大的结构来增加展示其他类别的能力。 默认情况下，factorplot() 产生一个 pairplot()：</p><pre><code>sns.factorplot(x=&quot;day&quot;, y=&quot;total_bill&quot;, hue=&quot;smoker&quot;, data=tips);</code></pre><p><img src="https://segmentfault.com/img/bVbco3T?w=502&h=365" alt></p><p>但是，kind 参数可以让你选择以上讨论的任何种类的图：</p><pre><code>sns.factorplot(x=&quot;day&quot;, y=&quot;total_bill&quot;, hue=&quot;smoker&quot;, data=tips, kind=&quot;bar&quot;);</code></pre><p><img src="https://segmentfault.com/img/bVbco3U?w=501&h=367" alt></p><p>使用 factorplot() 的主要优点是可以很容易使用 “facet” 绘制多面图，展示更多其他分类变量：</p><pre><code>sns.factorplot(x=&quot;day&quot;, y=&quot;total_bill&quot;, hue=&quot;smoker&quot;,               col=&quot;time&quot;, data=tips, kind=&quot;swarm&quot;);</code></pre><p><img src="https://segmentfault.com/img/bVbco3V?w=850&h=370" alt></p><p>任何一种图形都可以画出来。由于 FacetGrid 的工作原理，要更改图形的大小和形状，需要指定适用于每个图的 size 和 aspect 参数：</p><pre><code>sns.factorplot(x=&quot;time&quot;, y=&quot;total_bill&quot;, hue=&quot;smoker&quot;,               col=&quot;day&quot;, data=tips, kind=&quot;box&quot;, size=4, aspect=.5);</code></pre><p><img src="https://segmentfault.com/img/bVbco31?w=863&h=365" alt></p><p>你也可以直接使用 boxplot() 和 FacetGrid 来制作这个图。但是，必须特别注意确保每个图的分类变量的顺序需要被强制，或者是使用具有 Categorical 数据类型的数据或通过命令和 hue_order。</p><pre><code>sns.factorplot(x=&quot;time&quot;, y=&quot;total_bill&quot;, hue=&quot;smoker&quot;,hue_order=[&quot;No&quot;,&quot;Yes&quot;]               ,col=&quot;day&quot;, data=tips, kind=&quot;box&quot;, size=4, aspect=.5,              palette=&quot;Set3&quot;);</code></pre><p><img src="https://segmentfault.com/img/bVbco33?w=581&h=259" alt></p><p>由于广义 API 函数的存在，分类数据也可以很容易应用于其他更复杂的上下文。 例如，它们可以轻松地与 PairGrid 结合，以显示多个不同变量之间的分类关系：</p><pre><code>g = sns.PairGrid(tips,                 x_vars=[&quot;smoker&quot;, &quot;time&quot;, &quot;sex&quot;],                 y_vars=[&quot;total_bill&quot;, &quot;tip&quot;],                 aspect=.75, size=3.5)g.map(sns.violinplot, palette=&quot;pastel&quot;);</code></pre><p><img src="https://segmentfault.com/img/bVbco34?w=540&h=455" alt></p><blockquote><p>参考：<a href="http://seaborn.pydata.org/tutorial.html" target="_blank" rel="noopener">http://seaborn.pydata.org/tut…</a></p></blockquote><hr><p>关注微信公众号 <strong>Python 数据科学</strong>，获取 <code>120G</code> 人工智能 学习资料。</p><p><img src="https://segmentfault.com/img/bV7oO9?w=344&h=344" alt></p><p><img src="https://segmentfault.com/img/bV93KE?w=572&h=367" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文转载自&lt;a href=&quot;https://segmentfault.com/a/1190000015310299&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数据可视化Seaborn从零开始学习教程（四） 分类数据可视化篇&lt;/
      
    
    </summary>
    
      <category term="Python Packages" scheme="https://yyb1995.github.io/categories/Python-Packages/"/>
    
    
      <category term="seaborn" scheme="https://yyb1995.github.io/tags/seaborn/"/>
    
  </entry>
  
  <entry>
    <title>数据可视化Seaborn从零开始学习教程（二） 颜色调控篇</title>
    <link href="https://yyb1995.github.io/2019/07/09/PythonPackages/seaborn/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%20Seaborn%20%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89%20%E9%A2%9C%E8%89%B2%E8%B0%83%E6%8E%A7%E7%AF%87/"/>
    <id>https://yyb1995.github.io/2019/07/09/PythonPackages/seaborn/数据可视化 Seaborn 从零开始学习教程（二） 颜色调控篇/</id>
    <published>2019-07-09T03:07:19.620Z</published>
    <updated>2019-07-09T03:07:19.621Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自<a href="https://segmentfault.com/a/1190000014966210" target="_blank" rel="noopener">数据可视化Seaborn从零开始学习教程（二） 颜色调控篇</a></p></blockquote><h2 id="Seaborn-学习大纲"><a href="#Seaborn-学习大纲" class="headerlink" title="Seaborn 学习大纲"></a>Seaborn 学习大纲</h2><p><code>seaborn</code>的学习内容主要包含以下几个部分：</p><ol><li><p><strong>风格管理</strong></p><ul><li>绘图风格设置</li><li><code>颜色风格设置</code></li></ul></li><li><p><strong>绘图方法</strong></p><ul><li>数据集的分布可视化</li><li>分类数据可视化</li><li>线性关系可视化</li></ul></li><li><p><strong>结构网格</strong></p><ul><li>数据识别网格绘图</li></ul></li></ol><p>本次将主要介绍<code>颜色调控</code>的使用。</p><h2 id="颜色风格设置"><a href="#颜色风格设置" class="headerlink" title="颜色风格设置"></a>颜色风格设置</h2><p>在<code>Seaborn</code>的使用中，是可以针对数据类型而选择合适的颜色，并且使用选择的颜色进行可视化，节省了大量的可视化的颜色调整工作。</p><p>还是一样，在介绍如何使用颜色外观设置之前，我们引入所需要的模块。</p><pre><code>%matplotlib inlineimport numpy as npimport seaborn as snsimport matplotlib.pyplot as pltsns.set(rc={&quot;figure.figsize&quot;: (6, 6)})np.random.seed(sum(map(ord, &quot;palettes&quot;)))</code></pre><p>下面所有操作均在 Jupyter notebook 中执行，如果对这个软件还不熟悉的朋友可以参考：<a href="https://zhuanlan.zhihu.com/p/36764170" target="_blank" rel="noopener">Jupyter notebook 快速入门教程</a></p><h2 id="建立调色板"><a href="#建立调色板" class="headerlink" title="建立调色板"></a>建立调色板</h2><p>对于不连续的外观颜色设置而言，最重要的函数恐怕要属<code>color_palette</code>了。这个函数拥有许多方法，让你可以随心所欲的可以生成各种颜色。并且，它可以被任何有<code>palette</code>参数的函数在内部进行使用（<code>palette</code>的中文意思是 “调色板”）。</p><p>关于这个函数有几个点需要知道一下：</p><ul><li><code>color_palette</code>函数可以接受任何<code>seaborn</code>或者<code>matplotlib</code>颜色表中颜色名称（除了<code>jet</code>），也可以接受任何有效的<code>matplotlib</code>形式的颜色列表（比如<code>RGB</code>元组，<code>hex</code>颜色代码，或者<code>HTML</code>颜色名称）。</li><li>这个函数的返回值总是一个由 RGB 元组组成的列表，无参数调用<code>color_palette</code>函数则会返回当前默认的色环的列表。</li></ul><p><img src="https://segmentfault.com/img/bVbaXrK?w=1055&h=148" alt></p><ul><li>还有一个相应的函数，是<code>set_palette</code>，它接受与<code>color_palette</code>一样的参数，并会对所有的绘图的默认色环进行设置。当然，你也可以在<code>with</code>语句中使用<code>color_palette</code>来临时的改变默认颜色。</li></ul><p>通常，在不知道数据特点的情况下，要找出并知道哪组颜色对一组数据是最好的有点不太现实。因此，我们将分为多种方式来使用<code>color_palette</code>函数和其它的 <code>seaborn paletee</code> 函数。</p><p>有三种通用的<code>color palette</code>可以使用，它们分别是：<strong>qualitative</strong>，<strong>sequential</strong>，<strong>diverging</strong>。</p><h4 id="1-分类色板（quanlitative）"><a href="#1-分类色板（quanlitative）" class="headerlink" title="1. 分类色板（quanlitative）"></a>1. 分类色板（quanlitative）</h4><p><code>Qualitative</code>调色板，也可以说成是 <strong>类型</strong> 调色板，因为它对于分类数据的显示很有帮助。当你想要区别 <em>不连续的且内在没有顺序关系的</em> 数据时，这个方式是最好的。</p><p>当导入<code>seaborn</code>时，默认的色环就被改变成一组包含 6 种颜色的调色板，它使用了标准的<code>matplolib</code>色环，为了让绘图变得更好看一些。</p><pre><code>current_palette = sns.color_palette()sns.palplot(current_palette)</code></pre><p><img src="https://segmentfault.com/img/bVbaXr5?w=665&h=94" alt></p><p>有 6 种不同的默认主题，它们分别是：<strong>deep</strong>，<strong>muted</strong>，<strong>pastel</strong>，<strong>birght</strong>，<strong>dark</strong>，<strong>colorblind</strong>。</p><pre><code>themes = [&#39;deep&#39;, &#39;muted&#39;, &#39;pastel&#39;, &#39;bright&#39;, &#39;dark&#39;, &#39;colorblind&#39;]for theme in themes:    current_palette = sns.color_palette(theme)    sns.palplot(current_palette)</code></pre><p><img src="https://segmentfault.com/img/bVbaXse?w=560&h=340" alt></p><h4 id="使用色圈系统"><a href="#使用色圈系统" class="headerlink" title="使用色圈系统"></a>使用色圈系统</h4><p>默认的 6 种颜色看上去真不错，但是如果我们想要超过 6 种颜色呢？</p><p>当你有超过 6 种类型的数据要区分时，最简单的方法就是 <strong>在一个色圈空间内使用均匀分布的颜色</strong>。这也是当需要使用更多颜色时大多数<code>seaborn</code>函数的默认方式。</p><p>最常用的方法就是使用 <code>hls</code> 色空间，它是一种简单的<code>RGB</code>值的转换。</p><pre><code>sns.palplot(sns.color_palette(&quot;hls&quot;, 8))</code></pre><p><img src="https://segmentfault.com/img/bVbaXss?w=848&h=93" alt></p><p>除此之外，还有一个 <code>hls_palette</code> 函数，它可以让你控制 <code>hls</code> 颜色的亮度和饱和度。</p><pre><code>sns.palplot(sns.hls_palette(8, l=.3, s=.8))</code></pre><p><img src="https://segmentfault.com/img/bVbaXsw?w=853&h=90" alt></p><p>然而，由于人类视觉系统工作的原因，根据 RGB 颜色产生的平均视觉强度的颜色，从视觉上看起来并不是相同的强度。如果你观察仔细，就会察觉到，黄色和绿色会更亮一些，而蓝色则相对暗一些。因此，如果你想用<code>hls</code>系统达到一致性的效果，就会出现上面的问题。</p><p>为了修补这个问题，<code>seaborn</code>给<code>hls</code>系统提供了一个接口，可以让操作者简单容易的选择均匀分布，且亮度和饱和度看上去明显一致的色调。</p><pre><code>sns.palplot(sns.color_palette(&quot;husl&quot;, 8))</code></pre><p><img src="https://segmentfault.com/img/bVbaXsx?w=849&h=93" alt></p><p>同样与之对应的，也有个<code>husl_palette</code>函数提供更灵活的操作。</p><h4 id="使用分类-Color-Brewer-调色板"><a href="#使用分类-Color-Brewer-调色板" class="headerlink" title="使用分类 Color Brewer 调色板"></a>使用分类 Color Brewer 调色板</h4><p>另外一种对分类数据比较友好的调色板来自<code>Color Brewer</code>工具。在<code>matplotlib</code>中也存在这些颜色表，但是它们并没有被合适的处理。在<code>seaborn</code>中，当你想要分类的 <code>Color Brewer</code> 调色板的时候，你总是可以得到不连续颜色，但是这也意味着在某一点上，这些颜色将会开始循环。</p><p><code>Color Brewer</code> 网站中的一个很好的特点就是它提供了一个色盲安全指导。色盲颜色有很多种 <a href="http://en.wikipedia.org/wiki/Color_blindness" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Color_blindness</a>，但是最常见的当属辨别绿色和红色。如果可以避免使用红色和绿色来对绘图元素上色，那么对于一些色盲人群将会是一个很好的消息。</p><p>下面两组颜色就是使用红色和绿色组合，这可能并不是最好的选择。</p><pre><code>sns.palplot(sns.color_palette(&quot;Paired&quot;))</code></pre><p><img src="https://segmentfault.com/img/bVbaXs0?w=763&h=90" alt></p><pre><code>sns.palplot(sns.color_palette(&quot;Set2&quot;, 10))</code></pre><p><img src="https://segmentfault.com/img/bVbaXs2?w=1041&h=86" alt></p><p>为了避免这些组合，我们需要从<code>Color Brewer</code>库中进行选择调色，有一个专门的 <code>choose_colorbrewer_palette</code> 函数可以实现这个功能。这个函数需要在 IPython notebook 中使用，因为 notebook 是一个交互式的工具，可以让你浏览各种选择并且调节参数。</p><pre><code>sns_tpye = [&quot;qualitative&quot;, &quot;sequential&quot;, &quot;diverging&quot;]for elem in sns_type:    sns.choose_colorbrewer_palette(elem)</code></pre><p><img src="https://segmentfault.com/img/bVbaXs9?w=1054&h=413" alt></p><p><img src="https://segmentfault.com/img/bVbaXta?w=1034&h=372" alt></p><p><img src="https://segmentfault.com/img/bVbaXtd?w=1034&h=404" alt></p><ul><li>n：调节颜色的个数；</li><li>desat：调节明暗和饱和度；</li></ul><p>当然，您可能只想使用一组您特别喜欢的颜色。因为 color_palette() 接受一个颜色列表，这很容易做到。</p><pre><code>flatui = [&quot;#9b59b6&quot;, &quot;#3498db&quot;, &quot;#95a5a6&quot;, &quot;#e74c3c&quot;, &quot;#34495e&quot;, &quot;#2ecc71&quot;]sns.palplot(sns.color_palette(flatui))</code></pre><p><img src="https://segmentfault.com/img/bVbaXtm?w=776&h=99" alt></p><h4 id="使用-xkcd-颜色来命名颜色"><a href="#使用-xkcd-颜色来命名颜色" class="headerlink" title="使用 xkcd 颜色来命名颜色"></a>使用 xkcd 颜色来命名颜色</h4><p>在众多的努力帮助下，<code>xkcd</code> 完成了随机的 <code>RGB</code> 颜色的命名。一共生成了 954 个颜色 <a href="http://xkcd.com/color/rgb/" target="_blank" rel="noopener">http://xkcd.com/color/rgb/</a>，并可可以随时通过<code>xkcd_rgb</code>字典调用。</p><pre><code>plt.plot([0, 1], [0, 1], sns.xkcd_rgb[&quot;pale red&quot;], lw=3)plt.plot([0, 1], [0, 2], sns.xkcd_rgb[&quot;medium green&quot;], lw=3)plt.plot([0, 1], [0, 3], sns.xkcd_rgb[&quot;denim blue&quot;], lw=3);</code></pre><p><img src="https://segmentfault.com/img/bVbaXtr?w=628&h=472" alt></p><p>如果想要从 <code>xkcd_rgb</code> 字典中单独的抽取出一些颜色，你也可以将一组选择好的颜色放到 <code>xkcd_palette</code> 函数中。</p><pre><code>colors = [&quot;windows blue&quot;, &quot;amber&quot;, &quot;greyish&quot;, &quot;faded green&quot;, &quot;dusty purple&quot;]sns.palplot(sns.xkcd_palette(colors))</code></pre><p><img src="https://segmentfault.com/img/bVbaXtF?w=657&h=103" alt></p><h4 id="2-连续色板（sequential）"><a href="#2-连续色板（sequential）" class="headerlink" title="2. 连续色板（sequential）"></a>2. 连续色板（sequential）</h4><p>调色板的第二大类被成为 “顺序”，这种调色板对于有从低（无意义）到高（有意义）范围过度的数据非常适合。尽管有些时候你可能想要在连续色板中使用不连续颜色，但是更通用的情况下是连续色板会作为颜色表在 <code>kdeplot()</code> 或者 <code>corrplot()</code> 或是一些 matplotlib 的函数中使用。</p><p>对于连续的数据，最好是使用那些在色调上有相对细微变化的调色板，同时在亮度和饱和度上有很大的变化。这种方法将自然地将数据中相对重要的部分成为关注点。</p><p><code>Color Brewer</code> 的字典中就有一组很好的调色板。它们是以在调色板中的主导颜色 (或颜色) 命名的。</p><pre><code>sns.palplot(sns.color_palette(&quot;Blues&quot;))</code></pre><p><img src="https://segmentfault.com/img/bVbaXul?w=849&h=94" alt></p><p>就像在 matplotlib 中一样，如果您想要翻转渐变，您可以在面板名称中添加一个<code>_r</code>后缀。</p><pre><code>sns.palplot(sns.color_palette(&quot;BuGn_r&quot;))</code></pre><p><img src="https://segmentfault.com/img/bVbaXum?w=800&h=92" alt></p><p>seaborn 还增加了一个允许创建没有动态范围的 “dark” 面板。如果你想按顺序画线或点，这可能是有用的，因为颜色鲜艳的线可能很难区分。</p><p>类似的，这种暗处理的颜色，需要在面板名称中添加一个<code>_d</code>后缀。</p><pre><code>sns.palplot(sns.color_palette(&quot;GnBu_d&quot;))</code></pre><p><img src="https://segmentfault.com/img/bVbaXuq?w=748&h=96" alt></p><p>注意，你可能想使用 <code>choose_colorbrewer_palette()</code> 函数取绘制各种不同的选项。如果你想返回一个变量当做颜色映射传入 seaborn 或 matplotlib 的函数中，可以设置 <code>as_cmap</code> 参数为<code>True</code>。</p><h4 id="“cubehelix”-连续调色板"><a href="#“cubehelix”-连续调色板" class="headerlink" title="“cubehelix” 连续调色板"></a>“cubehelix” 连续调色板</h4><p><code>cubehelix</code>调色板系统在亮度和色变变化上具有线性上升或下降的特点。这意味着，当颜色表中的信息被转化为黑色和白色或者被一个色盲者看到的时候，它将会被保存下来。</p><p>matplotlib 有内建的默认 cubehelix 版本：</p><pre><code>sns.palplot(sns.color_palette(&quot;cubehelix&quot;, 8))</code></pre><p><img src="https://segmentfault.com/img/bVbaXuw?w=913&h=96" alt></p><p>seaborn 为 cubehelix 系统添加一个接口使得其可以在各种变化中都保持良好的亮度线性梯度。</p><p>通过 seaborn 的 cubehelix_palette() 函数返回的调色板与 matplotlib 默认值稍有所不同，它不会在色轮周围旋转或覆盖更广的强度范围。seaborn 还改变了排序使得更重要的值显得更暗：</p><pre><code>sns.palplot(sns.cubehelix_palette(8))</code></pre><p><img src="https://segmentfault.com/img/bVbaXuH?w=930&h=92" alt></p><p>其他<code>cubehelix_palette()</code>的参数主要调整色板的视觉。两个重要的选择是：<code>start</code>(值的范围为 03）和<code>rot</code>，或者旋转的次数（-1 和 1 之间）</p><pre><code>sns.palplot(sns.cubehelix_palette(8, start=.5, rot=-.75))</code></pre><p><img src="https://segmentfault.com/img/bVbaXuI?w=934&h=91" alt></p><p>你也可以控制断点的亮度和甚至对调结果顺序：</p><pre><code>sns.palplot(sns.cubehelix_palette(8, start=2, rot=0, dark=0, light=.95, reverse=True))</code></pre><p><img src="https://segmentfault.com/img/bVbaXuZ?w=930&h=89" alt></p><p>默认情况下你只会得到一些像 seaborn 其它调色板一样的颜色列表，但你也可以通过使用<code>as_cmap=True</code>让调色板返回一个可以被传入 seaborn 或 matplotlib 函数的颜色映射对象。</p><pre><code>x, y = np.random.multivariate_normal([0, 0], [[1, -.5], [-.5, 1]], size=300).Tcmap = sns.cubehelix_palette(light=1, as_cmap=True)sns.kdeplot(x, y, cmap=cmap, shade=True);</code></pre><p><img src="https://segmentfault.com/img/bVbaXu5?w=490&h=469" alt></p><p>与前面一样，也可以在 notebook 中使用<code>choose_cubehelix_palette()</code>来调节参数帮助选择更适合的调色板或颜色映射。如果想让函数返回一个类似<code>hexbin</code>的颜色映射而非一个列表则需要传入<code>as_cmap=True</code>。</p><h4 id="定制的连续调色板"><a href="#定制的连续调色板" class="headerlink" title="定制的连续调色板"></a>定制的连续调色板</h4><p>对于一个更简单的接口定制连续色板，你可以使用 light_palette() 或者 dark_palette() 函数。它们都是单一颜色，并且能产生从亮值或者暗去饱和的值到这个颜色的调色板。伴随着这些函数，也同样有 <code>choose_light_palette</code> 和 <code>choose_dark_palette</code> 两个函数来交互式的调节创建调色板。</p><pre><code>sns.palplot(sns.light_palette(&quot;green&quot;))</code></pre><p><img src="https://segmentfault.com/img/bVbaXvj?w=735&h=87" alt></p><pre><code>sns.palplot(sns.dark_palette(&quot;purple&quot;))</code></pre><p><img src="https://segmentfault.com/img/bVbaXvs?w=807&h=93" alt></p><pre><code>sns.palplot(sns.light_palette(&quot;navy&quot;, reverse=True))</code></pre><p><img src="https://segmentfault.com/img/bVbaXvv?w=790&h=93" alt></p><p>它们也可以创建一个颜色映射对象，而不仅仅是颜色列表。</p><pre><code>pal = sns.dark_palette(&quot;palegreen&quot;, as_cmap=True)sns.kdeplot(x, y, cmap=pal);</code></pre><p><img src="https://segmentfault.com/img/bVbaXvQ?w=489&h=475" alt></p><p>默认情况下，任何有效的 matplotlib 颜色可以作为输入。另外辅助的解释可以由<code>input</code>参数来控制。目前你可以在 hls 或 husl 空间中提供默认的 rgb 元组，您还可以使用任何有效的 xkcd 颜色的种子。</p><pre><code>sns.palplot(sns.light_palette((210, 90, 60), input=&quot;husl&quot;))</code></pre><p><img src="https://segmentfault.com/img/bVbaXvS?w=778&h=84" alt></p><pre><code>sns.palplot(sns.dark_palette(&quot;muted purple&quot;, input=&quot;xkcd&quot;))</code></pre><p><img src="https://segmentfault.com/img/bVbaXvY?w=791&h=90" alt></p><p>需要注意的是，<code>husl</code>是提供交互的组件的默认 input 空间，这与函数自身默认的并不同，但这在背景下却是更有用的。</p><h4 id="3-离散色板"><a href="#3-离散色板" class="headerlink" title="3. 离散色板"></a>3. 离散色板</h4><p>调色板中的第三类被称为 <strong>“离散”</strong>。这类色板适用于数据特征含有大的低值和大的高值。数据中通常有一个意义明确的中点。例如，如果你想要从某个基线时间点绘制温度变化，最好使用离散的颜色表显示相对降低和相对增加面积的地区。</p><p>除了你想满足一个低强度颜色的中点以及用不同起始颜色的两个相对微妙的变化，其实选择离散色板的规则类似于顺序色板。同样重要的是，起始值的亮度和饱和度是相同的。</p><p>同样重要的是要强调，应该避免使用红色和绿色，因为大量的潜在观众将无法分辨它们。</p><p>同样，Color Brewer 颜色字典里也同时拥有一套精心挑选的离散颜色映射:</p><pre><code>sns.palplot(sns.color_palette(&quot;BrBG&quot;, 7))</code></pre><p><img src="https://segmentfault.com/img/bVbaXv6?w=842&h=88" alt></p><pre><code>sns.palplot(sns.color_palette(&quot;RdBu_r&quot;, 7))</code></pre><p><img src="https://segmentfault.com/img/bVbaXv8?w=833&h=93" alt></p><pre><code>sns.palplot(sns.color_palette(&quot;coolwarm&quot;, 7))</code></pre><p><img src="https://segmentfault.com/img/bVbaXv9?w=820&h=92" alt></p><h4 id="定制的离散色板"><a href="#定制的离散色板" class="headerlink" title="定制的离散色板"></a>定制的离散色板</h4><p>你也可以使用 seaborn 函数 <code>diverging_palette()</code> 为离散的数据创建一个定制的颜色映射。（当然也有一个类似配套的互动工具：<code>choose_diverging_palette()</code>）。该函数使用 husl 颜色系统的离散色板。你需要传递两种色调，并可选择性的设定明度和饱和度的端点。函数将使用 husl 的端点值及由此产生的中间值进行均衡。</p><pre><code>sns.palplot(sns.diverging_palette(220, 20, n=7))</code></pre><p><img src="https://segmentfault.com/img/bVbaXwh?w=804&h=86" alt></p><pre><code>sns.palplot(sns.diverging_palette(145, 280, s=85, l=25, n=7))</code></pre><p><img src="https://segmentfault.com/img/bVbaXwA?w=821&h=88" alt><br>sep 参数控制面板中间区域的两个渐变的宽度。</p><pre><code>sns.palplot(sns.diverging_palette(10, 220, sep=80, n=7))</code></pre><p><img src="https://segmentfault.com/img/bVbaXwF?w=865&h=93" alt></p><p>也可以用中间的色调来选择调色，而不是用亮度。</p><pre><code>sns.palplot(sns.diverging_palette(255, 133, l=60, n=7, center=&quot;dark&quot;))</code></pre><p><img src="https://segmentfault.com/img/bVbaXxH?w=832&h=90" alt></p><h4 id="设置默认的调色板"><a href="#设置默认的调色板" class="headerlink" title="设置默认的调色板"></a>设置默认的调色板</h4><p><code>color_palette()</code> 函数有一个名为<code>set_palette()</code>的配套使用函数。 set_palette()。set_palette() 接受与 color_palette() 相同的参数，但是它会更改默认的 matplotlib 参数，以便成为所有的调色板配置。</p><pre><code>def sinplot(flip=1):    x = np.linspace(0, 14, 100)    for i in range(1, 7):        plt.plot(x, np.sin(x + i * .5) * (7 - i) * flip)sns.set_palette(&quot;husl&quot;)sinplot()</code></pre><p><img src="https://segmentfault.com/img/bVbaXxK?w=622&h=471" alt></p><p>color_palette() 函数也可以在一个 with 块中使用，以达到临时更改调色板的目的。</p><pre><code>with sns.color_palette(&quot;PuBuGn_d&quot;):    sinplot()</code></pre><p><img src="https://segmentfault.com/img/bVbaXxS?w=652&h=472" alt></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>本篇介绍了 seaborn 中的颜色调控方法，提到的一个重要函数是：color_palette()。针对不同的数据类型有三种调色方式：</p><ul><li>分类色板（qualitative）</li><li>连续色板（sequential）</li><li>离散色板（diverging）</li></ul></li><li><p>其中还提到了 Color Brewer 工具，它可以很好的应用在以上三种调色方式上。</p></li><li><p>记住还有一个很有用的函数 choose_xxx_paletee()，用于交互式的调试颜色。</p></li><li><p>还可以通过 set_palette() 函数设置绘图默认参数。</p></li></ul><blockquote><p>参考：<a href="http://seaborn.pydata.org/tutorial.html" target="_blank" rel="noopener">http://seaborn.pydata.org/tut…</a></p></blockquote><hr><p>关注微信公众号 <strong>Python 数据科学</strong>，获取 <code>120G</code> 人工智能 学习资料。</p><p><img src="https://segmentfault.com/img/bV7oO9?w=344&h=344" alt><br><img src="https://segmentfault.com/img/bV93KE?w=572&h=367" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文转载自&lt;a href=&quot;https://segmentfault.com/a/1190000014966210&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数据可视化Seaborn从零开始学习教程（二） 颜色调控篇&lt;/a&gt;&lt;
      
    
    </summary>
    
      <category term="Python Packages" scheme="https://yyb1995.github.io/categories/Python-Packages/"/>
    
    
      <category term="seaborn" scheme="https://yyb1995.github.io/tags/seaborn/"/>
    
  </entry>
  
  <entry>
    <title>数据可视化Seaborn从零开始学习教程（一） 风格选择</title>
    <link href="https://yyb1995.github.io/2019/07/09/PythonPackages/seaborn/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%20Seaborn%20%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%20%E9%A3%8E%E6%A0%BC%E9%80%89%E6%8B%A9/"/>
    <id>https://yyb1995.github.io/2019/07/09/PythonPackages/seaborn/数据可视化 Seaborn 从零开始学习教程（一） 风格选择/</id>
    <published>2019-07-09T03:07:19.620Z</published>
    <updated>2019-07-09T03:07:19.620Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自<a href="https://segmentfault.com/a/1190000014915873" target="_blank" rel="noopener">数据可视化Seaborn从零开始学习教程（一） 风格选择</a></p></blockquote><blockquote><p>最近在做几个项目的数据分析，每次用到<code>seaborn</code>进行可视化绘图的时候总是忘记具体操作。虽然<code>seaborn</code>的官方网站已经详细的介绍了使用方法，但是毕竟是英文，而且查找不是很方便。因此博主想从零开始将<code>seaborn</code>学习一遍，做一个总结，也希望供大家使用参考。</p></blockquote><h2 id="Seaborn-简介"><a href="#Seaborn-简介" class="headerlink" title="Seaborn 简介"></a>Seaborn 简介</h2><p><code>seaborn</code>同<code>matplotlib</code>一样，也是 Python 进行数据可视化分析的重要第三方包。但<code>seaborn</code>是在 <code>matplotlib</code>的基础上进行了更高级的 API 封装，使得作图更加容易，图形更加漂亮。</p><p>博主并不认为<code>seaborn</code>可以替代<code>matplotlib</code>。虽然<code>seaborn</code>可以满足大部分情况下的数据分析需求，但是针对一些特殊情况，还是需要用到<code>matplotlib</code>的。换句话说，<code>matplotlib</code>更加灵活，可定制化，而<code>seaborn</code>像是更高级的封装，使用方便快捷。</p><p>应该把<code>seaborn</code>视为<code>matplotlib</code>的补充，而不是替代物。</p><h2 id="Seaborn-学习内容"><a href="#Seaborn-学习内容" class="headerlink" title="Seaborn 学习内容"></a>Seaborn 学习内容</h2><p><code>seaborn</code>的学习内容主要包含以下几个部分：</p><ol><li><p><strong>风格管理</strong></p><ul><li>绘图风格设置</li><li>颜色风格设置</li></ul></li><li><p><strong>绘图方法</strong></p><ul><li>数据集的分布可视化</li><li>分类数据可视化</li><li>线性关系可视化</li></ul></li><li><p><strong>结构网格</strong></p><ul><li>数据识别网格绘图</li></ul></li></ol><p>本次将主要介绍风格管理的使用。</p><h2 id="风格管理-绘图风格设置"><a href="#风格管理-绘图风格设置" class="headerlink" title="风格管理 - 绘图风格设置"></a>风格管理 - 绘图风格设置</h2><p>除了各种绘图方式外，图形的美观程度可能是我们最关心的了。将它放到第一部分，因为风格设置是一些通用性的操作，对于各种绘图方法都适用。</p><p>让我们先看一个例子。</p><pre><code>%matplotlib inlineimport numpy as npimport matplotlib as mplimport matplotlib.pyplot as pltimport seaborn as snsnp.random.seed(sum(map(ord, &quot;aesthetics&quot;)))</code></pre><p>我们定义了一个简单的方程来绘制一些偏置的正弦波，用来帮助我们查看不同的图画风格是什么样子的。</p><pre><code>def sinplot(flip=1):    x = np.linspace(0, 14, 100)    for i in range(1, 7):        plt.plot(x, np.sin(x + i * .5) * (7 - i) * flip)</code></pre><p><code>matplotlib</code>默认参数下绘制结果是这样的：</p><pre><code>sinplot()</code></pre><p><img src="https://segmentfault.com/img/bVbaKnO?w=493&h=338" alt></p><p>转换为<code>seaborn</code>默认绘图，可以简单的用<code>set()</code>方法。</p><pre><code>sns.set()sinplot()</code></pre><p><img src="https://segmentfault.com/img/bVbaKnT?w=486&h=330" alt></p><p><code>Seaborn</code> 将 <code>matplotlib</code> 的参数划分为两个独立的组合。第一组是设置绘图的外观风格的，第二组主要将绘图的各种元素按比例缩放的，以至可以嵌入到不同的背景环境中。</p><p>操控这些参数的接口主要有两对方法：</p><ul><li>控制风格：<code>axes_style()</code>, <code>set_style()</code></li><li>缩放绘图：<code>plotting_context()</code>, <code>set_context()</code></li></ul><p>每对方法中的第一个方法（<code>axes_style()</code>, <code>plotting_context()</code>）会返回一组字典参数，而第二个方法（<code>set_style()</code>, <code>set_context()</code>）会设置 matplotlib 的默认参数。</p><h3 id="Seaborn-的五种绘图风格"><a href="#Seaborn-的五种绘图风格" class="headerlink" title="Seaborn 的五种绘图风格"></a>Seaborn 的五种绘图风格</h3><p>有五种<code>seaborn</code>的风格，它们分别是：<strong>darkgrid</strong>, <strong>whitegrid</strong>, <strong>dark</strong>, <strong>white</strong>, <strong>ticks</strong>。它们各自适合不同的应用和个人喜好。默认的主题是 <strong>darkgrid</strong>。</p><pre><code>sns.set_style(&quot;whitegrid&quot;)data = np.random.normal(size=(20, 6)) + np.arange(6) / 2sns.boxplot(data=data);</code></pre><p><img src="https://segmentfault.com/img/bVbaKpk?w=486&h=321" alt></p><pre><code>sns.set_style(&quot;dark&quot;)sinplot()</code></pre><p><img src="https://segmentfault.com/img/bVbaKpw?w=484&h=327" alt></p><pre><code>sns.set_style(&quot;white&quot;)sinplot()</code></pre><p><img src="https://segmentfault.com/img/bVbaKpA?w=481&h=321" alt></p><pre><code>sns.set_style(&quot;ticks&quot;)sinplot()</code></pre><p><img src="https://segmentfault.com/img/bVbaKpG?w=491&h=341" alt></p><h3 id="移除轴脊柱"><a href="#移除轴脊柱" class="headerlink" title="移除轴脊柱"></a>移除轴脊柱</h3><p><strong>white</strong> 和 <strong>ticks</strong> 两个风格都能够移除顶部和右侧的不必要的轴脊柱。通过<code>matplotlib</code>参数是做不到这一点的，但是你可以使用<code>seaborn</code>的<code>despine()</code>方法来移除它们：</p><pre><code>sinplot()sns.despine()</code></pre><p><img src="https://segmentfault.com/img/bVbaKpO?w=495&h=347" alt></p><p>一些绘图也可以针对数据将轴脊柱进行偏置，当然也是通过调用<code>despine()</code>方法来完成。而当刻度没有完全覆盖整个轴的范围时，<code>trim</code>参数可以用来限制已有脊柱的范围。</p><pre><code>f, ax = plt.subplots()sns.violinplot(data=data)sns.despine(offset=10, trim=True);</code></pre><p><img src="https://segmentfault.com/img/bVbaKpS?w=493&h=354" alt></p><p>你也可以通过<code>despine()</code>控制哪个脊柱将被移除。</p><pre><code>sns.set_style(&quot;whitegrid&quot;)sns.boxplot(data=data, palette=&quot;deep&quot;)sns.despine(left=True)</code></pre><p><img src="https://segmentfault.com/img/bVbaKqi?w=491&h=333" alt></p><h3 id="临时设置绘图风格"><a href="#临时设置绘图风格" class="headerlink" title="临时设置绘图风格"></a>临时设置绘图风格</h3><p>虽然来回切换风格很容易，但是你也可以在一个<code>with</code>语句中使用<code>axes_style()</code>方法来临时的设置绘图参数。这也允许你用不同风格的轴来绘图：</p><pre><code>with sns.axes_style(&quot;darkgrid&quot;):    plt.subplot(211)    sinplot()plt.subplot(212)sinplot(-1)</code></pre><p><img src="https://segmentfault.com/img/bVbaKqB?w=482&h=329" alt></p><h3 id="覆盖-seaborn-风格元素"><a href="#覆盖-seaborn-风格元素" class="headerlink" title="覆盖 seaborn 风格元素"></a>覆盖 seaborn 风格元素</h3><p>如果你想定制化<code>seaborn</code>风格，你可以将一个字典参数传递给<code>axes_style()</code>和<code>set_style()</code>的参数<code>rc</code>。而且你只能通过这个方法来覆盖风格定义中的部分参数。</p><p>如果你想要看看这些参数都是些什么，可以调用这个方法，且无参数，这将会返回下面的设置：</p><pre><code>sns.axes_style(){&#39;axes.axisbelow&#39;: True, &#39;axes.edgecolor&#39;: &#39;.8&#39;, &#39;axes.facecolor&#39;: &#39;white&#39;, &#39;axes.grid&#39;: True, &#39;axes.labelcolor&#39;: &#39;.15&#39;, &#39;axes.linewidth&#39;: 1.0, &#39;figure.facecolor&#39;: &#39;white&#39;, &#39;font.family&#39;: [u&#39;sans-serif&#39;], &#39;font.sans-serif&#39;: [u&#39;Arial&#39;,  u&#39;DejaVu Sans&#39;,  u&#39;Liberation Sans&#39;,  u&#39;Bitstream Vera Sans&#39;,  u&#39;sans-serif&#39;], &#39;grid.color&#39;: &#39;.8&#39;, &#39;grid.linestyle&#39;: u&#39;-&#39;, &#39;image.cmap&#39;: u&#39;rocket&#39;, &#39;legend.frameon&#39;: False, &#39;legend.numpoints&#39;: 1, &#39;legend.scatterpoints&#39;: 1, &#39;lines.solid_capstyle&#39;: u&#39;round&#39;, &#39;text.color&#39;: &#39;.15&#39;, &#39;xtick.color&#39;: &#39;.15&#39;, &#39;xtick.direction&#39;: u&#39;out&#39;, &#39;xtick.major.size&#39;: 0.0, &#39;xtick.minor.size&#39;: 0.0, &#39;ytick.color&#39;: &#39;.15&#39;, &#39;ytick.direction&#39;: u&#39;out&#39;, &#39;ytick.major.size&#39;: 0.0, &#39;ytick.minor.size&#39;: 0.0}</code></pre><p>然后，你可以设置这些参数的不同版本了。</p><pre><code>sns.set_style(&quot;darkgrid&quot;, {&quot;axes.facecolor&quot;: &quot;.9&quot;})sinplot()</code></pre><p><img src="https://segmentfault.com/img/bVbaKqJ?w=489&h=332" alt></p><h3 id="绘图元素比例"><a href="#绘图元素比例" class="headerlink" title="绘图元素比例"></a>绘图元素比例</h3><p>有一套的参数可以控制绘图元素的比例。<br>首先，让我们通过<code>set()</code>重置默认的参数：</p><pre><code>sns.set()</code></pre><p>有四个预置的环境，按大小从小到大排列分别为：<strong>paper</strong>, <strong>notebook</strong>, <strong>talk</strong>, <strong>poster</strong>。其中，<strong>notebook</strong> 是默认的。</p><pre><code>sns.set_context(&quot;paper&quot;)sinplot()</code></pre><p><img src="https://segmentfault.com/img/bVbaKq8?w=476&h=319" alt></p><pre><code>sns.set_context(&quot;talk&quot;)sinplot()</code></pre><p><img src="https://segmentfault.com/img/bVbaKrb?w=491&h=326" alt></p><pre><code>sns.set_context(&quot;poster&quot;)sinplot()</code></pre><p><img src="https://segmentfault.com/img/bVbaKrt?w=529&h=339" alt></p><p>你可以通过使用这些名字中的一个调用<code>set_context()</code>来设置参数，并且你可以通过提供一个字典参数值来覆盖参数。当改变环境时，你也可以独立的去缩放字体元素的大小。</p><pre><code>sns.set_context(&quot;notebook&quot;, font_scale=1.5, rc={&quot;lines.linewidth&quot;: 2.5})sinplot()</code></pre><p><img src="https://segmentfault.com/img/bVbaKrz?w=515&h=334" alt></p><p>同样的，你可以通过嵌入<code>with</code>语句临时的控制绘图的比例。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>介绍了 Seaborn 的 5 中绘图风格</p><ul><li>移除轴脊柱</li><li>临时设置绘图风格</li><li>覆盖 Seaborn 风格元素</li><li>绘图元素比例缩放</li></ul><p>下一节将会介绍颜色风格的使用。</p><hr><p>关注微信公众号 <strong>Python 数据科学</strong>，获取 <code>120G</code> 人工智能 学习资料。</p><p><img src="https://segmentfault.com/img/bV7oO9?w=344&h=344" alt></p><p><img src="https://segmentfault.com/img/bV93KE?w=572&h=367" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文转载自&lt;a href=&quot;https://segmentfault.com/a/1190000014915873&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数据可视化Seaborn从零开始学习教程（一） 风格选择&lt;/a&gt;&lt;/
      
    
    </summary>
    
      <category term="Python Packages" scheme="https://yyb1995.github.io/categories/Python-Packages/"/>
    
    
      <category term="seaborn" scheme="https://yyb1995.github.io/tags/seaborn/"/>
    
  </entry>
  
  <entry>
    <title>数据可视化Seaborn从零开始学习教程（三） 数据分布可视化篇</title>
    <link href="https://yyb1995.github.io/2019/07/09/PythonPackages/seaborn/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%20Seaborn%20%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89%20%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AF%87/"/>
    <id>https://yyb1995.github.io/2019/07/09/PythonPackages/seaborn/数据可视化 Seaborn 从零开始学习教程（三） 数据分布可视化篇/</id>
    <published>2019-07-09T03:07:19.620Z</published>
    <updated>2019-07-09T03:07:19.620Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自<a href="https://segmentfault.com/a/1190000015006667" target="_blank" rel="noopener">数据可视化Seaborn从零开始学习教程（三） 数据分布可视化篇</a></p></blockquote><h2 id="Seaborn-学习大纲"><a href="#Seaborn-学习大纲" class="headerlink" title="Seaborn 学习大纲"></a>Seaborn 学习大纲</h2><p><code>seaborn</code>的学习内容主要包含以下几个部分：</p><ol><li><p><strong>风格管理</strong></p><ul><li>绘图风格设置</li><li>颜色风格设置</li></ul></li><li><p><strong>绘图方法</strong></p><ul><li><code>数据集的分布可视化</code></li><li>分类数据可视化</li><li>线性关系可视化</li></ul></li><li><p><strong>结构网格</strong></p><ul><li>数据识别网格绘图</li></ul></li></ol><p>本次将主要介绍<code>数据集的分布可视化</code>的使用。</p><h2 id="数据集分布可视化"><a href="#数据集分布可视化" class="headerlink" title="数据集分布可视化"></a>数据集分布可视化</h2><p>当处理一个数据集的时候，我们经常会想要先看看特征变量是如何分布的。这会让我们对数据特征有个很好的初始认识，同时也会影响后续数据分析以及特征工程的方法。本篇将会介绍如何使用 seaborn 的一些工具来检测单变量和双变量分布情况。</p><p>首先还是先导入需要的模块和数据集。</p><pre><code>%matplotlib inlineimport numpy as npimport pandas as pdfrom scipy import stats, integrateimport matplotlib.pyplot as pltimport seaborn as snssns.set(color_codes=True)np.random.seed(sum(map(ord, &quot;distributions&quot;)))</code></pre><blockquote><p>注意：这里的数据集是随机产生的分布数据，由 numpy 生成，数据类型是 ndarray。当然，pandas 的 Series 数据类型也是可以使用的，比如我们经常需要从 DataFrame 表中提取某一特征（某一列）来查看分布情况。</p></blockquote><h2 id="绘制单变量分布"><a href="#绘制单变量分布" class="headerlink" title="绘制单变量分布"></a>绘制单变量分布</h2><p>在 seaborn 中，快速观察单变量分布的最方便的方法就是使用 <code>distplot()</code> 函数。默认会使用柱状图 (histogram) 来绘制，并提供一个适配的核密度估计(KDE)。</p><pre><code>x = np.random.normal(size=100)sns.distplot(x);</code></pre><p><img src="https://segmentfault.com/img/bVba71r?w=599&h=337" alt></p><h4 id="直方图（histograms"><a href="#直方图（histograms" class="headerlink" title="直方图（histograms"></a>直方图（histograms</h4><p>直方图是比较常见的，并且在 matplotlib 中已经存在了 <code>hist</code> 函数。直方图在横坐标的数据值范围内均等分的形成一定数量的数据段（bins），并在每个数据段内用矩形条（bars）显示 y 轴观察数量的方式，完成了对的数据分布的可视化展示。</p><p>为了说明这个，我们可以移除 kde plot，然后添加 rug plot（在每个观察点上的垂直小标签）。当然，你也可以使用 rug plot 自带的 <code>rugplot()</code> 函数，但是也同样可以在 <code>distplot</code> 中实现：</p><pre><code>sns.distplot(x, kde=False, rug=True);</code></pre><p><img src="https://segmentfault.com/img/bVba71A?w=620&h=334" alt></p><p>当绘制直方图时，你最需要确定的参数是矩形条的数目以及如何放置它们。<code>distplot()</code>使用了一个简单的规则推测出默认情况下最合适的数量，但是或多或少的对 bins 数量进行一些尝试也许能找出数据的其它特征：</p><pre><code>sns.distplot(x, bins=20, kde=False, rug=True);</code></pre><p><img src="https://segmentfault.com/img/bVba71S?w=608&h=333" alt></p><h4 id="核密度估计（Kernel-density-estimation）"><a href="#核密度估计（Kernel-density-estimation）" class="headerlink" title="核密度估计（Kernel density estimation）"></a>核密度估计（Kernel density estimation）</h4><p>核密度估计可能不被大家所熟悉，但它对于绘制分布的形状是一个非常有用的工具。就像直方图那样，KDE plots 会在一个轴上通过高度沿着其它轴将观察的密度编码。</p><pre><code>sns.distplot(x, hist=False, rug=True);</code></pre><p><img src="https://segmentfault.com/img/bVba72q?w=570&h=332" alt></p><p>绘制 KDE 比绘制直方图需要更多的计算。它的计算过程是这样的，每个观察点首先都被以这个点为中心的正态分布曲线所替代。</p><pre><code>x = np.random.normal(0, 1, size=30)bandwidth = 1.06 * x.std() * x.size ** (-1 / 5.)support = np.linspace(-4, 4, 200)kernels = []for x_i in x:    kernel = stats.norm(x_i, bandwidth).pdf(support)    kernels.append(kernel)    plt.plot(support, kernel, color=&quot;r&quot;)sns.rugplot(x, color=&quot;.2&quot;, linewidth=3);</code></pre><p><img src="https://segmentfault.com/img/bVba72x?w=585&h=339" alt></p><p>然后，这些替代的曲线进行加和，并计算出在每个点的密度值。最终生成的曲线被归一化，以使得曲线下面包围的面积是 1。</p><pre><code>density = np.sum(kernels, axis=0)density /= integrate.trapz(density, support)plt.plot(support, density);</code></pre><p><img src="https://segmentfault.com/img/bVba72y?w=577&h=330" alt></p><p>我们可以看到，如果我们使用 <code>kdeplot()</code> 函数，我们可以得到相同的曲线。这个函数实际上也被 <code>distplot()</code> 所使用，但是如果你就只想要密度估计，那么 <code>kdeplot()</code> 会提供一个直接的接口更简单的操作其它选项。</p><pre><code>sns.kdeplot(x, shade=True);</code></pre><p><img src="https://segmentfault.com/img/bVba72B?w=584&h=327" alt></p><p>KDE 的带宽参数（bw）控制着密度估计曲线的宽窄形状，有点类似直方图中的 bins 参数的作用。它对应着我们上面绘制的 KDE 的宽度。默认情况下，函数会按照一个通用的参考规则来估算出一个合适的值，但是尝试更大或者更小也可能会有帮助：</p><pre><code>sns.kdeplot(x)sns.kdeplot(x, bw=.2, label=&quot;bw: 0.2&quot;)sns.kdeplot(x, bw=2, label=&quot;bw: 2&quot;)plt.legend();</code></pre><p><img src="https://segmentfault.com/img/bVba72E?w=588&h=337" alt></p><p>如上所述，高斯 KDE 过程的意味着估计延续了数据集中最大和最小的值。 可以通过<code>cut</code>参数来控制绘制曲线的极值值的距离; 然而，这只影响曲线的绘制方式，而不是曲线如何拟合：</p><pre><code>sns.kdeplot(x, shade=True, cut=0)sns.rugplot(x);</code></pre><p><img src="https://segmentfault.com/img/bVba72J?w=575&h=338" alt></p><h4 id="拟合参数分布"><a href="#拟合参数分布" class="headerlink" title="拟合参数分布"></a>拟合参数分布</h4><p>你也可以使用<code>distplot()</code>将参数分布拟合到数据集，并可视化地评估其与观察数据的对应程度：</p><pre><code>x = np.random.gamma(6, size=200)sns.distplot(x, kde=False, fit=stats.gamma);</code></pre><p><img src="https://segmentfault.com/img/bVba72Q?w=610&h=335" alt></p><h2 id="绘制双变量分布"><a href="#绘制双变量分布" class="headerlink" title="绘制双变量分布"></a>绘制双变量分布</h2><p>对于双变量分布的可视化也是非常有用的。在 seaborn 中最简单的方法就是使用 <code>joinplot()</code> 函数，它能够创建一个多面板图形来展示两个变量之间的联合关系，以及每个轴上单变量的分布情况。</p><pre><code>mean, cov = [0, 1], [(1, .5), (.5, 1)]data = np.random.multivariate_normal(mean, cov, 200)df = pd.DataFrame(data, columns=[&quot;x&quot;, &quot;y&quot;])</code></pre><h4 id="Scatterplots"><a href="#Scatterplots" class="headerlink" title="Scatterplots"></a>Scatterplots</h4><p>双变量分布最熟悉的可视化方法无疑是散点图了，在散点图中每个观察结果以 x 轴和 y 轴值所对应的点展示。你可以用 matplotlib 的 <code>plt.scatter</code> 函数来绘制一个散点图，它也是<code>jointplot()</code>函数显示的默认方式。</p><pre><code>sns.jointplot(x=&quot;x&quot;, y=&quot;y&quot;, data=df)</code></pre><p><img src="https://segmentfault.com/img/bVba73e?w=614&h=553" alt></p><h4 id="Hexbin-plots"><a href="#Hexbin-plots" class="headerlink" title="Hexbin plots"></a>Hexbin plots</h4><p>直方图 <code>histogram</code> 的双变量类似图被称为 “hexbin” 图，因为它展示了落在六角形箱内的观测量。这种绘图对于相对大的数据集效果最好。它可以通过 matplotlib 的 <code>plt.hexbin</code> 函数使用，也可以作为 <code>jointplot</code> 的一种类型参数使用。它使用白色背景的时候视觉效果最好。</p><pre><code>x, y = np.random.multivariate_normal(mean, cov, 1000).Twith sns.axes_style(&quot;white&quot;):    sns.jointplot(x=x, y=y, kind=&quot;hex&quot;, color=&quot;k&quot;);</code></pre><p><img src="https://segmentfault.com/img/bVba73i?w=585&h=563" alt></p><h4 id="Kernel-density-estimation"><a href="#Kernel-density-estimation" class="headerlink" title="Kernel density estimation"></a>Kernel density estimation</h4><p>还使用上面描述的核密度估计过程来可视化双变量分布。在 seaborn 中，这种绘图以等高线图展示，并且可以作为 <code>jointplot()</code>的一种类型参数使用。</p><pre><code>sns.jointplot(x=&quot;x&quot;, y=&quot;y&quot;, data=df, kind=&quot;kde&quot;);</code></pre><p><img src="https://segmentfault.com/img/bVba73o?w=578&h=557" alt></p><p>你也可以用 <code>kdeplot</code> 函数来绘制一个二维的核密度图形。这可以将这种绘图绘制到一个特定的（可能已经存在的）matplotlib 轴上，而<code>jointplot()</code>函数只能管理自己：</p><pre><code>f, ax = plt.subplots(figsize=(6, 6))sns.kdeplot(df.x, df.y, ax=ax)sns.rugplot(df.x, color=&quot;g&quot;, ax=ax)sns.rugplot(df.y, vertical=True, ax=ax);</code></pre><p><img src="https://segmentfault.com/img/bVba73u?w=515&h=503" alt></p><p>如果你希望让双变量密度看起来更连续，您可以简单地增加 n_levels 参数增加轮廓级数：</p><pre><code>f, ax = plt.subplots(figsize=(6, 6))cmap = sns.cubehelix_palette(as_cmap=True, dark=0, light=1, reverse=True)sns.kdeplot(df.x, df.y, cmap=cmap, n_levels=60, shade=True);</code></pre><p><img src="https://segmentfault.com/img/bVba73B?w=537&h=495" alt></p><p><code>jointplot()</code>函数使用<code>JointGrid</code>来管理图形。为了获得更多的灵活性，您可能需要直接使用<code>JointGrid</code>绘制图形。<code>jointplot()</code>在绘制后返回 JointGrid 对象，你可以用它来添加更多层或调整可视化的其他方面：</p><pre><code>g = sns.jointplot(x=&quot;x&quot;, y=&quot;y&quot;, data=df, kind=&quot;kde&quot;, color=&quot;m&quot;)g.plot_joint(plt.scatter, c=&quot;w&quot;, s=30, linewidth=1, marker=&quot;+&quot;)g.ax_joint.collections[0].set_alpha(0)g.set_axis_labels(&quot;$X$&quot;, &quot;$Y$&quot;);</code></pre><p><img src="https://segmentfault.com/img/bVba73H?w=568&h=565" alt></p><h2 id="可视化数据集成对关系"><a href="#可视化数据集成对关系" class="headerlink" title="可视化数据集成对关系"></a>可视化数据集成对关系</h2><p>为了绘制数据集中多个成对的双变量，你可以使用 <code>pairplot()</code> 函数。这创建了一个轴矩阵，并展示了在一个 DataFrame 中每对列的关系。默认情况下，它也绘制每个变量在对角轴上的单变量。</p><pre><code>iris = sns.load_dataset(&quot;iris&quot;)sns.pairplot(iris);</code></pre><p><img src="https://segmentfault.com/img/bVba73I?w=976&h=934" alt></p><p>就像 <code>joinplot()</code> 和 <code>JoinGrid</code> 之间的关系，<code>pairplot()</code> 函数建立在 <code>PairGrid</code> 对象之上，直接使用可以更灵活。</p><pre><code>g = sns.PairGrid(iris)g.map_diag(sns.kdeplot)g.map_offdiag(sns.kdeplot, cmap=&quot;Blues_d&quot;, n_levels=6);/Users/mwaskom/anaconda/lib/python2.7/site-packages/matplotlib/axes/_axes.py:545: UserWarning: No labelled objects found. Use label=&#39;...&#39; kwarg on individual plots.  warnings.warn(&quot;No labelled objects found. &quot;</code></pre><p><img src="https://segmentfault.com/img/bVba73P?w=961&h=932" alt></p><blockquote><p>参考：<a href="http://seaborn.pydata.org/tutorial.html" target="_blank" rel="noopener">http://seaborn.pydata.org/tut…</a></p></blockquote><hr><p>关注微信公众号 <strong>Python 数据科学</strong>，获取 <code>120G</code> 人工智能 学习资料。<br><img src="https://segmentfault.com/img/bV7oO9?w=344&h=344" alt></p><p><img src="https://segmentfault.com/img/bV93KE?w=572&h=367" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文转载自&lt;a href=&quot;https://segmentfault.com/a/1190000015006667&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数据可视化Seaborn从零开始学习教程（三） 数据分布可视化篇&lt;/
      
    
    </summary>
    
      <category term="Python Packages" scheme="https://yyb1995.github.io/categories/Python-Packages/"/>
    
    
      <category term="seaborn" scheme="https://yyb1995.github.io/tags/seaborn/"/>
    
  </entry>
  
  <entry>
    <title>scikit-learn</title>
    <link href="https://yyb1995.github.io/2019/07/09/PythonPackages/scikit-learn/"/>
    <id>https://yyb1995.github.io/2019/07/09/PythonPackages/scikit-learn/</id>
    <published>2019-07-09T03:07:19.619Z</published>
    <updated>2019-07-09T03:07:19.619Z</updated>
    
    <content type="html"><![CDATA[<p>在机器学习和数据挖掘的应用中，scikit-learn是一个功能强大的python包。在数据量不是过大的情况下，可以解决大部分问题。学习使用scikit-learn的过程中，我自己也在补充着机器学习和数据挖掘的知识。这里根据自己学习sklearn的经验，我做一个总结的笔记。另外，我也想把这篇笔记一直更新下去。</p><h1 id="1-scikit-learn基础介绍"><a href="#1-scikit-learn基础介绍" class="headerlink" title="1 scikit-learn基础介绍"></a>1 scikit-learn基础介绍</h1><h2 id="1-1-估计器（Estimator）"><a href="#1-1-估计器（Estimator）" class="headerlink" title="1.1 估计器（Estimator）"></a>1.1 估计器（Estimator）</h2><p>估计器，很多时候可以直接理解成分类器，主要包含两个函数：</p><ul><li>fit()：训练算法，设置内部参数。接收训练集和类别两个参数。</li><li>predict()：预测测试集类别，参数为测试集。</li></ul><p>大多数scikit-learn估计器接收和输出的数据格式均为numpy数组或类似格式。</p><h2 id="1-2-转换器（Transformer）"><a href="#1-2-转换器（Transformer）" class="headerlink" title="1.2 转换器（Transformer）"></a>1.2 转换器（Transformer）</h2><p>转换器用于数据预处理和数据转换，主要是三个方法：</p><ul><li>fit()：训练算法，设置内部参数。</li><li>transform()：数据转换。</li><li>fit_transform()：合并fit和transform两个方法。</li><li>inverse_transform()：将转换后的数据进行逆转换得到原始数据</li></ul><h2 id="1-3-流水线（Pipeline）"><a href="#1-3-流水线（Pipeline）" class="headerlink" title="1.3 流水线（Pipeline）"></a>1.3 流水线（Pipeline）</h2><p><strong>sklearn.pipeline</strong>包</p><h3 id="1-3-1-流水线的功能："><a href="#1-3-1-流水线的功能：" class="headerlink" title="1.3.1 流水线的功能："></a>1.3.1 流水线的功能：</h3><ul><li>跟踪记录各步骤的操作（以方便地重现实验结果）</li><li>对各步骤进行一个封装</li><li>确保代码的复杂程度不至于超出掌控范围</li></ul><h3 id="1-3-2-基本使用方法"><a href="#1-3-2-基本使用方法" class="headerlink" title="1.3.2 基本使用方法"></a>1.3.2 基本使用方法</h3><p>流水线的输入为一连串的数据挖掘步骤，其中最后一步必须是估计器，前几步是转换器。输入的数据集经过转换器的处理后，输出的结果作为下一步的输入。最后，用位于流水线最后一步的估计器对数据进行分类。</p><p>每一步都用元组（ ‘名称’，步骤）来表示。现在来创建流水线。</p><pre><code>scaling_pipeline = Pipeline([  (&#39;scale&#39;, MinMaxScaler()),  (&#39;predict&#39;, KNeighborsClassifier())])</code></pre><h2 id="1-4-预处理"><a href="#1-4-预处理" class="headerlink" title="1.4 预处理"></a>1.4 预处理</h2><p>主要在<strong>sklearn.preprcessing</strong>包下。</p><p><strong>规范化：</strong></p><ul><li><strong>MinMaxScaler</strong> :最大最小值规范化</li><li><strong>Normalizer</strong> :使每条数据各特征值的和为1</li><li><strong>StandardScaler</strong> :为使各特征的均值为0，方差为1</li></ul><p><strong>编码：</strong></p><ul><li><strong>LabelEncoder</strong> ：把字符串类型的数据转化为整型</li><li><strong>OneHotEncoder</strong> ：特征用一个二进制数字来表示</li><li><strong>Binarizer</strong> :为将数值型特征的二值化</li><li><strong>MultiLabelBinarizer</strong>：多标签二值化</li></ul><h2 id="1-5-特征"><a href="#1-5-特征" class="headerlink" title="1.5 特征"></a>1.5 特征</h2><h3 id="1-5-1-特征抽取"><a href="#1-5-1-特征抽取" class="headerlink" title="1.5.1 特征抽取"></a>1.5.1 特征抽取</h3><p>包：<strong>sklearn.feature_extraction</strong></p><p>特征抽取是数据挖掘任务最为重要的一个环节，一般而言，它对最终结果的影响要高过数据挖掘算法本身。只有先把现实用特征表示出来，才能借助数据挖掘的力量找到问题的答案。特征选择的另一个优点在于：降低真实世界的复杂度，模型比现实更容易操纵。</p><p>一般最常使用的特征抽取技术都是高度针对具体领域的，对于特定的领域，如图像处理，在过去一段时间已经开发了各种特征抽取的技术，但这些技术在其他领域的应用却非常有限。</p><ul><li><strong>DictVectorizer</strong>： 将dict类型的list数据，转换成numpy array</li><li><strong>FeatureHasher</strong> ： 特征哈希，相当于一种降维技巧</li><li><strong>image</strong>：图像相关的特征抽取</li><li><strong>text</strong>： 文本相关的特征抽取</li><li><strong>text.CountVectorizer</strong>：将文本转换为每个词出现的个数的向量</li><li><strong>text.TfidfVectorizer</strong>：将文本转换为tfidf值的向量</li><li><strong>text.HashingVectorizer</strong>：文本的特征哈希</li></ul><p><strong>示例</strong></p><p>data.png</p><p>CountVectorize只数出现个数</p><p>count.png</p><p>hash.png</p><p>TfidfVectorizer：个数+归一化（不包括idf）</p><p>tfidf(without idf).png</p><h3 id="1-5-2-特征选择"><a href="#1-5-2-特征选择" class="headerlink" title="1.5.2 特征选择"></a>1.5.2 特征选择</h3><p>包：<strong>sklearn.feature_selection</strong></p><p>特征选择的原因如下：</p><p>(1)降低复杂度</p><p>(2)降低噪音</p><p>(3)增加模型可读性</p><ul><li><strong>VarianceThreshold</strong>： 删除特征值的方差达不到最低标准的特征</li><li><strong>SelectKBest</strong>： 返回<em>k</em>个最佳特征</li><li><strong>SelectPercentile</strong>： 返回表现最佳的前r%个特征</li></ul><p>单个特征和某一类别之间相关性的计算方法有很多。最常用的有卡方检验（χ2）。其他方法还有互信息和信息熵。</p><ul><li><strong>chi2</strong>： 卡方检验（χ2）</li></ul><h2 id="1-6-降维"><a href="#1-6-降维" class="headerlink" title="1.6 降维"></a>1.6 降维</h2><p>包：<strong>sklearn.decomposition</strong></p><ul><li>主成分分析算法（Principal Component Analysis， PCA）的目的是找到能用较少信息描述数据集的特征组合。它意在发现彼此之间没有相关性、能够描述数据集的特征，确切说这些特征的方差跟整体方差没有多大差距，这样的特征也被称为主成分。这也就意味着，借助这种方法，就能通过更少的特征捕获到数据集的大部分信息。</li></ul><h2 id="1-7-组合"><a href="#1-7-组合" class="headerlink" title="1.7 组合"></a>1.7 组合</h2><p>包：*<em>sklearn.ensemble *</em></p><p>组合技术即通过聚集多个分类器的预测来提高分类准确率。</p><p>常用的组合分类器方法：</p><p>(1)通过处理训练数据集。即通过某种抽样分布，对原始数据进行再抽样，得到多个训练集。常用的方法有装袋（bagging）和提升（boosting）。</p><p>(2)通过处理输入特征。即通过选择输入特征的子集形成每个训练集。适用于有大量冗余特征的数据集。随机森林（Random forest）就是一种处理输入特征的组合方法。</p><p>(3)通过处理类标号。适用于多分类的情况，将类标号随机划分成两个不相交的子集，再把问题变为二分类问题，重复构建多次模型，进行分类投票。</p><ul><li><strong>BaggingClassifier</strong>： Bagging分类器组合</li><li><strong>BaggingRegressor</strong>： Bagging回归器组合</li><li><strong>AdaBoostClassifier</strong>： AdaBoost分类器组合</li><li><strong>AdaBoostRegressor</strong>： AdaBoost回归器组合</li><li><strong>GradientBoostingClassifier</strong>：GradientBoosting分类器组合</li><li><strong>GradientBoostingRegressor</strong>： GradientBoosting回归器组合</li><li><strong>ExtraTreeClassifier</strong>：ExtraTree分类器组合</li><li><strong>ExtraTreeRegressor</strong>： ExtraTree回归器组合</li><li><strong>RandomTreeClassifier</strong>：随机森林分类器组合</li><li><strong>RandomTreeRegressor</strong>： 随机森林回归器组合</li></ul><p><strong>使用举例</strong></p><pre><code>AdaBoostClassifier(DecisionTreeClassifier(max_depth=1),algorithm=&quot;SAMME&quot;,n_estimators=200)</code></pre><p><strong>解释</strong><br><strong>装袋（bagging）</strong>：根据均匀概率分布从数据集中重复抽样（有放回），每个自助样本集和原数据集一样大，每个自助样本集含有原数据集大约63%的数据。训练k个分类器，测试样本被指派到得票最高的类。<br><strong>提升（boosting）</strong>：通过给样本设置不同的权值，每轮迭代调整权值。不同的提升算法之间的差别，一般是（1）如何更新样本的权值，（2）如何组合每个分类器的预测。其中Adaboost中，样本权值是增加那些被错误分类的样本的权值，分类器C_i的重要性依赖于它的错误率。</p><p>Boosting主要关注降低偏差，因此Boosting能基于泛化性能相当弱的学习器构建出很强的集成；Bagging主要关注降低方差，因此它在不剪枝的决策树、神经网络等学习器上效用更为明显。偏差指的是算法的期望预测与真实预测之间的偏差程度，反应了模型本身的拟合能力；方差度量了同等大小的训练集的变动导致学习性能的变化，刻画了数据扰动所导致的影响。</p><h3 id="1-7-1-模型评估（度量）"><a href="#1-7-1-模型评估（度量）" class="headerlink" title="1.7.1 模型评估（度量）"></a>1.7.1 模型评估（度量）</h3><p>包：<strong>sklearn.metrics</strong></p><p>sklearn.metrics包含评分方法、性能度量、成对度量和距离计算。<br><strong>分类结果度量</strong></p><p>参数大多是y_true和y_pred。</p><ul><li><strong>accuracy_score</strong>：分类准确度</li><li><strong>condusion_matrix</strong> ：分类混淆矩阵</li><li><strong>classification_report</strong>：分类报告</li><li><strong>precision_recall_fscore_support</strong>：计算精确度、召回率、f、支持率</li><li><strong>jaccard_similarity_score</strong>：计算jcaard相似度</li><li><strong>hamming_loss</strong>：计算汉明损失</li><li><strong>zero_one_loss</strong>：0-1损失</li><li><strong>hinge_loss</strong>：计算hinge损失</li><li><strong>log_loss</strong>：计算log损失</li></ul><p>其中，F1是以<strong>每个类别</strong>为基础进行定义的，包括两个概念：准确率（precision）和召回率（recall）。准确率是指预测结果属于某一类的个体，实际属于该类的比例。召回率是被正确预测为某类的个体，与数据集中该类个体总数的比例。F1是准确率和召回率的调和平均数。</p><p><strong>回归结果度量</strong></p><ul><li><strong>explained_varicance_score</strong>：可解释方差的回归评分函数</li><li><strong>mean_absolute_error</strong>：平均绝对误差</li><li><strong>mean_squared_error</strong>：平均平方误差</li></ul><p><strong>多标签的度量</strong></p><ul><li><strong>coverage_error</strong>：涵盖误差</li><li><strong>label_ranking_average_precision_score</strong>：计算基于排名的平均误差Label ranking average precision (LRAP)</li></ul><p><strong>聚类的度量</strong></p><ul><li><strong>adjusted_mutual_info_score</strong>：调整的互信息评分</li><li><strong>silhouette_score</strong>：所有样本的轮廓系数的平均值</li><li><strong>silhouette_sample</strong>：所有样本的轮廓系数</li></ul><h2 id="1-8-交叉验证"><a href="#1-8-交叉验证" class="headerlink" title="1.8 交叉验证"></a>1.8 交叉验证</h2><p>包：<strong>sklearn.cross_validation</strong></p><ul><li><strong>KFold</strong>：K-Fold交叉验证迭代器。接收元素个数、fold数、是否清洗</li><li><strong>LeaveOneOut</strong>：LeaveOneOut交叉验证迭代器</li><li><strong>LeavePOut</strong>：LeavePOut交叉验证迭代器</li><li><strong>LeaveOneLableOut</strong>：LeaveOneLableOut交叉验证迭代器</li><li><strong>LeavePLabelOut</strong>：LeavePLabelOut交叉验证迭代器</li></ul><p>LeaveOneOut(n) 相当于 KFold(n, n_folds=n) 相当于LeavePOut(n, p=1)。</p><p>LeaveP和LeaveOne差别在于leave的个数，也就是测试集的尺寸。LeavePLabel和LeaveOneLabel差别在于leave的Label的种类的个数。</p><p>LeavePLabel这种设计是针对可能存在第三方的Label，比如我们的数据是一些季度的数据。那么很自然的一个想法就是把1,2,3个季度的数据当做训练集，第4个季度的数据当做测试集。这个时候只要输入每个样本对应的季度Label，就可以实现这样的功能。</p><p>以下是实验代码，尽量自己多实验去理解。</p><pre><code class="python">    #coding=utf-8    import numpy as np    import sklearnfrom sklearn    import cross_validation    X = np.array([[1, 2], [3, 4], [5, 6], [7, 8],[9, 10]])    y = np.array([1, 2, 1, 2, 3])    def show_cross_val(method):          if method == &quot;lolo&quot;:                labels = np.array([&quot;summer&quot;, &quot;winter&quot;, &quot;summer&quot;, &quot;winter&quot;, &quot;spring&quot;])                cv = cross_validation.LeaveOneLabelOut(labels)                elif method == &#39;lplo&#39;:                labels = np.array([&quot;summer&quot;, &quot;winter&quot;, &quot;summer&quot;, &quot;winter&quot;, &quot;spring&quot;])                cv = cross_validation.LeavePLabelOut(labels,p=2)          elif method == &#39;loo&#39;:                cv = cross_validation.LeaveOneOut(n=len(y))          elif method == &#39;lpo&#39;:                cv = cross_validation.LeavePOut(n=len(y),p=3)          for train_index, test_index in cv:                print(&quot;TRAIN:&quot;, train_index, &quot;TEST:&quot;, test_index)                X_train, X_test = X[train_index], X[test_index]                y_train, y_test = y[train_index], y[test_index]                print &quot;X_train: &quot;,X_train                print &quot;y_train: &quot;, y_train                print &quot;X_test: &quot;,X_test                print &quot;y_test: &quot;,y_test    if __name__ == &#39;__main__&#39;:          show_cross_val(&quot;lpo&quot;)</code></pre><p><strong>常用方法</strong></p><ul><li><strong>train_test_split</strong>：分离训练集和测试集（不是K-Fold）</li><li><strong>cross_val_score</strong>：交叉验证评分，可以指认cv为上面的类的实例</li><li><strong>cross_val_predict</strong>：交叉验证的预测。</li></ul><h2 id="1-9-网格搜索"><a href="#1-9-网格搜索" class="headerlink" title="1.9 网格搜索"></a>1.9 网格搜索</h2><p>包：<strong>sklearn.grid_search</strong></p><p>网格搜索最佳参数</p><ul><li><strong>GridSearchCV</strong>：搜索指定参数网格中的最佳参数</li><li><strong>ParameterGrid</strong>：参数网格</li><li><strong>ParameterSampler</strong>：用给定分布生成参数的生成器</li><li><strong>RandomizedSearchCV</strong>：超参的随机搜索</li></ul><p>通过best_estimator_.get_params()方法，获取最佳参数。</p><h2 id="1-10-多分类、多标签分类"><a href="#1-10-多分类、多标签分类" class="headerlink" title="1.10 多分类、多标签分类"></a>1.10 多分类、多标签分类</h2><p>包：<strong>sklearn.multiclass</strong></p><ul><li><strong>OneVsRestClassifier</strong>：1-rest多分类（多标签）策略</li><li><strong>OneVsOneClassifier</strong>：1-1多分类策略</li><li><strong>OutputCodeClassifier</strong>：1个类用一个二进制码表示</li></ul><p><strong>示例代码</strong></p><pre><code class="python">    #coding=utf-8    from sklearn import metrics    from sklearn import cross_validation    from sklearn.svm import SVC    from sklearn.multiclass import OneVsRestClassifier    from sklearn.preprocessing import MultiLabelBinarizer    import numpy as np    from numpy import random    X=np.arange(15).reshape(5,3)    y=np.arange(5)    Y_1 = np.arange(5)    random.shuffle(Y_1)    Y_2 = np.arange(5)    random.shuffle(Y_2)    Y = np.c_[Y_1,Y_2]    def multiclassSVM():        X_train, X_test, y_train, y_test = cross_validation.train_test_split(X, y, test_size=0.2,random_state=0)        model = OneVsRestClassifier(SVC())        model.fit(X_train, y_train)        predicted = model.predict(X_test)        print predicted    def multilabelSVM():        Y_enc = MultiLabelBinarizer().fit_transform(Y)        X_train, X_test, Y_train, Y_test = cross_validation.train_test_split(X, Y_enc, test_size=0.2, random_state=0)        model = OneVsRestClassifier(SVC())        model.fit(X_train, Y_train)        predicted = model.predict(X_test)        print predicted    if __name__ == &#39;__main__&#39;:        multiclassSVM()        # multilabelSVM()</code></pre><p>上面的代码测试了svm在OneVsRestClassifier的包装下，分别处理多分类和多标签的情况。特别注意，在多标签的情况下，输入必须是二值化的。所以需要MultiLabelBinarizer()先处理。</p><h1 id="2-具体模型"><a href="#2-具体模型" class="headerlink" title="2 具体模型"></a>2 具体模型</h1><h2 id="2-1-朴素贝叶斯（Naive-Bayes）"><a href="#2-1-朴素贝叶斯（Naive-Bayes）" class="headerlink" title="2.1 朴素贝叶斯（Naive Bayes）"></a>2.1 朴素贝叶斯（Naive Bayes）</h2><p>包：<strong>sklearn.cross_validation</strong></p><p>朴素贝叶斯.png</p><p>朴素贝叶斯的特点是分类速度快，分类效果不一定是最好的。</p><ul><li><strong>GasussianNB</strong>：高斯分布的朴素贝叶斯</li><li><strong>MultinomialNB</strong>：多项式分布的朴素贝叶斯</li><li><strong>BernoulliNB</strong>：伯努利分布的朴素贝叶斯</li></ul><p>所谓使用什么分布的朴素贝叶斯，就是假设P(x_i|y)是符合哪一种分布，比如可以假设其服从高斯分布，然后用最大似然法估计高斯分布的参数。</p><p>高斯分布.png</p><p>多项式分布.png</p><p>伯努利分布.png</p><h1 id="3-scikit-learn扩展"><a href="#3-scikit-learn扩展" class="headerlink" title="3 scikit-learn扩展"></a>3 scikit-learn扩展</h1><h2 id="3-1-概览"><a href="#3-1-概览" class="headerlink" title="3.1 概览"></a>3.1 概览</h2><p>具体的扩展，通常要继承<strong>sklearn.base</strong>包下的类。</p><ul><li><strong>BaseEstimator</strong>： 估计器的基类</li><li><strong>ClassifierMixin</strong> ：分类器的混合类</li><li><strong>ClusterMixin</strong>：聚类器的混合类</li><li><strong>RegressorMixin</strong> ：回归器的混合类</li><li><strong>TransformerMixin</strong> ：转换器的混合类</li></ul><p>关于什么是Mixin（混合类），具体可以看这个<a href="https://link.jianshu.com?t=https://www.zhihu.com/question/20778853" target="_blank" rel="noopener">知乎链接</a>。简单地理解，就是带有实现方法的接口，可以将其看做是组合模式的一种实现。举个例子，比如说常用的TfidfTransformer，继承了BaseEstimator， TransformerMixin，因此它的基本功能就是单一职责的估计器和转换器的组合。</p><h2 id="3-2-创建自己的转换器"><a href="#3-2-创建自己的转换器" class="headerlink" title="3.2 创建自己的转换器"></a>3.2 创建自己的转换器</h2><p>在特征抽取的时候，经常会发现自己的一些数据预处理的方法，sklearn里可能没有实现，但若直接在数据上改，又容易将代码弄得混乱，难以重现实验。这个时候最好自己创建一个转换器，在后面将这个转换器放到pipeline里，统一管理。</p><p>例如《Python数据挖掘入门与实战》书中的例子，我们想接收一个numpy数组，根据其均值将其离散化，任何高于均值的特征值替换为1，小于或等于均值的替换为0。</p><p>代码实现：</p><pre><code class="python">    from sklearn.base import TransformerMixin    from sklearn.utils import as_float_array    class MeanDiscrete(TransformerMixin):      #计算出数据集的均值，用内部变量保存该值。        def fit(self, X, y=None):            X = as_float_array(X)            self.mean = np.mean(X, axis=0)            #返回self，确保在转换器中能够进行链式调用（例如调用transformer.fit(X).transform(X)）            return self        def transform(self, X):            X = as_float_array(X)            assert X.shape[1] == self.mean.shape[0]            return X &gt; self.mean</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在机器学习和数据挖掘的应用中，scikit-learn是一个功能强大的python包。在数据量不是过大的情况下，可以解决大部分问题。学习使用scikit-learn的过程中，我自己也在补充着机器学习和数据挖掘的知识。这里根据自己学习sklearn的经验，我做一个总结的笔记。
      
    
    </summary>
    
      <category term="Python Packages" scheme="https://yyb1995.github.io/categories/Python-Packages/"/>
    
    
      <category term="scikit-learn" scheme="https://yyb1995.github.io/tags/scikit-learn/"/>
    
  </entry>
  
  <entry>
    <title>Pip换源</title>
    <link href="https://yyb1995.github.io/2019/07/09/PythonPackages/pip%E6%8D%A2%E6%BA%90/"/>
    <id>https://yyb1995.github.io/2019/07/09/PythonPackages/pip换源/</id>
    <published>2019-07-09T03:07:19.618Z</published>
    <updated>2019-07-09T03:07:19.618Z</updated>
    
    <content type="html"><![CDATA[<h2 id="临时"><a href="#临时" class="headerlink" title="临时"></a>临时</h2><p><code>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple packagename</code><br><a href="https://mirrors.tuna.tsinghua.edu.cn/help/pypi/" target="_blank" rel="noopener">清华大学镜像站</a></p><h2 id="永久"><a href="#永久" class="headerlink" title="永久"></a>永久</h2><p>在<code>./user/pip/</code>下新建<code>pip.ini</code>，内容为：</p><pre><code class="[global]">index-url = https://pypi.tuna.tsinghua.edu.cn/simpletrusted-host = pypi.tuna.tsinghua.edu.cn```du.cn</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;临时&quot;&gt;&lt;a href=&quot;#临时&quot; class=&quot;headerlink&quot; title=&quot;临时&quot;&gt;&lt;/a&gt;临时&lt;/h2&gt;&lt;p&gt;&lt;code&gt;pip install -i https://pypi.tuna.tsinghua.edu.cn/simple packagen
      
    
    </summary>
    
      <category term="Python Packages" scheme="https://yyb1995.github.io/categories/Python-Packages/"/>
    
    
      <category term="Pip" scheme="https://yyb1995.github.io/tags/Pip/"/>
    
  </entry>
  
  <entry>
    <title>pandas</title>
    <link href="https://yyb1995.github.io/2019/07/09/PythonPackages/pandas/"/>
    <id>https://yyb1995.github.io/2019/07/09/PythonPackages/pandas/</id>
    <published>2019-07-09T03:07:19.618Z</published>
    <updated>2019-07-09T03:07:19.618Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-对于时间的处理"><a href="#1-对于时间的处理" class="headerlink" title="1 对于时间的处理"></a>1 对于时间的处理</h2><p>python中datetime模块非常好用，提供了日期格式和字符串格式相互转化的函数strftime/strptime</p><p>1、由日期格式转化为字符串格式的函数为: <code>datetime.datetime.strftime()</code></p><p><img src="http://img.blog.csdn.net/20170205194641724" alt></p><p>2、由字符串格式转化为日期格式的函数为: <code>datetime.datetime.strptime()</code></p><p><img src="http://img.blog.csdn.net/20170205194637147" alt></p><p>3、两个函数都涉及日期时间的格式化字符串，列举如下：</p><pre><code>%a 星期几的简写;如 星期三为Web %A 星期几的全称;如 星期三为Wednesday %b 月份的简写; 如4月份为Apr %B 月份的全称; 如4月份为April %c 标准的日期的时间串;（如： 04/07/10 10:43:39） %C 年份的后两位数字 %d 十进制表示的每月的第几天 %D 月/天/年 %e 在两字符域中，十进制表示的每月的第几天 %F 年-月-日 %g 年份的后两位数字，使用基于周的年 %G 年分，使用基于周的年 %h 简写的月份名 %H 24小时制的小时 %I 12小时制的小时 %j 十进制表示的每年的第几天 %m 十进制表示的月份 %M 十时制表示的分钟数 %n 新行符 %p 本地的AM或PM的等价显示 %r 12小时的时间 %R 显示小时和分钟：hh:mm %S 十进制的秒数 %t 水平制表符 %T 显示时分秒：hh:mm:ss %u 每周的第几天，星期一为第一天 （值从0到6，星期一为0） %U 第年的第几周，把星期日做为第一天（值从0到53） %V 每年的第几周，使用基于周的年 %w 十进制表示的星期几（值从0到6，星期天为0） %W 每年的第几周，把星期一做为第一天（值从0到53） %x 标准的日期串 %X 标准的时间串 %y 不带世纪的十进制年份（值从0到99） %Y 带世纪部分的十制年份 %z，%Z 时区名称，如果不能得到时区名称则返回空字符。 %% 百分号</code></pre><h2 id="2-入门及基本操作"><a href="#2-入门及基本操作" class="headerlink" title="2 入门及基本操作"></a>2 入门及基本操作</h2><ol><li><p>查看数据的头5行/后5行</p><pre><code>df.head()`df.tail()</code></pre></li><li><p>查看数据索引，数据的列名，数据的值</p><pre><code>df.indexdf.columnsdf.values</code></pre></li><li><p>对坐标轴进行排序<br><code>df.sort_index(axis=1, ascending=False)</code><br>注意：axis=1是以列名作为索引，也就是columns；axis=0是以行名作为索引，也就是index</p></li><li><p>对值进行排序<br><code>df.sort_values(by=&#39;B&#39;)</code></p></li><li><p>数据切片操作<br>df.loc  按照行、列名选取<br>df.iloc 按照行、列号选取<br>df.ix iloc和loc的结合</p></li></ol><pre><code>df.loc[&#39;20010101&#39;]  #选取行df.loc[:, [&#39;A&#39;]]  #选取列df.iloc[0]df.iloc[:, [0]]</code></pre><p><strong>注意</strong>:使用loc进行切片时，括号左右两边的值都包含，如<code>df.loc[&#39;A&#39;:&#39;B&#39;]</code>取出的行包括index为A和B的行。使用iloc进行切片时，括号右边的值不包含，如<code>df.iloc[:2]</code>取出的行为序号为0和1的行</p><ol start="6"><li><p>对残缺数据处理</p><pre><code>df.dropna()df.fillna()</code></pre><p>inplace参数：在原dataframe中进行修改</p></li><li><p>数据的读取：<br>读取txt文件：<br><code>df = pd.read_table(&#39;./data/bili.txt&#39;, sep=&#39;,&#39;)</code><br>查看各列类型：df.info()<br>调整列顺序：<br><code>df = df[[&#39;a&#39;, &#39;c&#39;, &#39;b&#39;]]</code><br>删除一列：<br><code>df.drop(axis=1, inplace=True)</code><br>查找某行某列的值</p><pre><code># df.loc[conditions, column name] = newvaluedf_full.loc[(df_full[&#39;date&#39;] == date_temp) &amp; (df_full[&#39;time&#39;] == time_temp), &#39;reqnum&#39;] = reqnum_temp`</code></pre></li></ol><pre><code></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-对于时间的处理&quot;&gt;&lt;a href=&quot;#1-对于时间的处理&quot; class=&quot;headerlink&quot; title=&quot;1 对于时间的处理&quot;&gt;&lt;/a&gt;1 对于时间的处理&lt;/h2&gt;&lt;p&gt;python中datetime模块非常好用，提供了日期格式和字符串格式相互转化的函数
      
    
    </summary>
    
      <category term="Python Packages" scheme="https://yyb1995.github.io/categories/Python-Packages/"/>
    
    
      <category term="pandas" scheme="https://yyb1995.github.io/tags/pandas/"/>
    
  </entry>
  
</feed>
