<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Eric_fish&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yyb1995.github.io/"/>
  <updated>2020-02-29T13:41:41.587Z</updated>
  <id>https://yyb1995.github.io/</id>
  
  <author>
    <name>Eric_fish</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计划任务crontab的使用</title>
    <link href="https://yyb1995.github.io/2020/02/29/Linux/%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1crontab%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://yyb1995.github.io/2020/02/29/Linux/计划任务crontab的使用/</id>
    <published>2020-02-29T13:24:27.810Z</published>
    <updated>2020-02-29T13:41:41.587Z</updated>
    
    <content type="html"><![CDATA[<p>在linux系统中可以使用crontab指令定时运行脚本。基本使用方法如下。</p><h2 id="创建-编辑定时文件"><a href="#创建-编辑定时文件" class="headerlink" title="创建/编辑定时文件"></a>创建/编辑定时文件</h2><p><code>crontab -e</code></p><p>前五个分别表示分钟，小时，日，月，周几。如果为<code>*</code>表示每个间隔执行一次。其他具体格式可参考<a href="https://www.runoob.com/linux/linux-comm-crontab.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-comm-crontab.html</a></p><h2 id="查看定时文件列表"><a href="#查看定时文件列表" class="headerlink" title="查看定时文件列表"></a>查看定时文件列表</h2><p><code>crontab -l</code></p><h2 id="删除定时文件"><a href="#删除定时文件" class="headerlink" title="删除定时文件"></a>删除定时文件</h2><p><code>crontab -r</code></p><h2 id="不能运行的解决方法"><a href="#不能运行的解决方法" class="headerlink" title="不能运行的解决方法"></a>不能运行的解决方法</h2><ol><li>判断系统指令是否能定时执行</li></ol><p>可以把<code>* * * * * /bin/date &gt;&gt;  /Users/yourname/Desktop/cron.txt</code>加入crontab，观察是否每分钟输出一次。如果可以，说明crontab能正常运行</p><ol start="2"><li>在crontab中加入系统变量</li></ol><p>cron中的环境变量和系统的不一致。可以在crontab第一行加入由<code>env</code>命令得到的<code>PATH=/opt/someApp/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</code>即可</p><ol start="3"><li>Macos10.15访问权限不够</li></ol><p>在安全性与隐私-&gt;完全磁盘访问权限中加入cron</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在linux系统中可以使用crontab指令定时运行脚本。基本使用方法如下。&lt;/p&gt;
&lt;h2 id=&quot;创建-编辑定时文件&quot;&gt;&lt;a href=&quot;#创建-编辑定时文件&quot; class=&quot;headerlink&quot; title=&quot;创建/编辑定时文件&quot;&gt;&lt;/a&gt;创建/编辑定时文件&lt;/h2
      
    
    </summary>
    
      <category term="Linux" scheme="https://yyb1995.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Mac折腾</title>
    <link href="https://yyb1995.github.io/2019/10/18/Mac/Mac%E6%8A%98%E8%85%BE/"/>
    <id>https://yyb1995.github.io/2019/10/18/Mac/Mac折腾/</id>
    <published>2019-10-18T13:52:09.000Z</published>
    <updated>2019-12-01T08:44:53.264Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一些好用的功能"><a href="#一些好用的功能" class="headerlink" title="一些好用的功能"></a>一些好用的功能</h2><p><a href="https://www.macdaxue.com/force-touch/" target="_blank" rel="noopener">触控板用力点按 Froce torch</a></p><h2 id="系统相关"><a href="#系统相关" class="headerlink" title="系统相关"></a>系统相关</h2><h3 id="修改账户名称"><a href="#修改账户名称" class="headerlink" title="修改账户名称"></a>修改账户名称</h3><p>在账户相关设置中，有账户名称和全名两个设置。如果想要修改账户名称，需要新建一个管理员账户，然后退出当前账户，在另一个管理员账户中修改账户名称。如果想修改账户全名，需要重置用户文件夹。</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p><a href="https://www.jianshu.com/p/020f3d02f538" target="_blank" rel="noopener">Mac在bash和zsh配置环境变量的几种方法</a></p><p>这里需要注意的是在配置用户环境变量时，<code>~/.bashrc</code>对应bash的用户环境变量。如果已经把bash改成了zsh，需要在<code>~/.zshrc</code>中设置。</p><h3 id="bash-gt-iterms2"><a href="#bash-gt-iterms2" class="headerlink" title="bash-&gt;iterms2"></a>bash-&gt;iterms2</h3><p><a href="https://www.jianshu.com/p/9c3439cc3bdb" target="_blank" rel="noopener">iTerm2 + Oh My Zsh 打造舒适终端体验</a></p><p>我的一些配置：</p><pre><code class="text">iterms Theme：Draculafont: 18pt Roboto Mono for PowerlineHotkey: Double click Command</code></pre><h3 id="替换Command和Ctrl"><a href="#替换Command和Ctrl" class="headerlink" title="替换Command和Ctrl"></a>替换<code>Command</code>和<code>Ctrl</code></h3><p>系统偏好设置-&gt;键盘-&gt;修饰键</p><h3 id="Finder标题显示文件夹全称"><a href="#Finder标题显示文件夹全称" class="headerlink" title="Finder标题显示文件夹全称"></a>Finder标题显示文件夹全称</h3><p><code>defaults write com.apple.finder _FXShowPosixPathInTitle -bool YES</code></p><h2 id="常用软件"><a href="#常用软件" class="headerlink" title="常用软件"></a>常用软件</h2><h3 id="MAC软件网站"><a href="#MAC软件网站" class="headerlink" title="MAC软件网站"></a>MAC软件网站</h3><p><a href="https://www.xxmac.com/" target="_blank" rel="noopener">xxmac</a></p><p><a href="https://xclient.info/" target="_blank" rel="noopener">xclient</a></p><p><a href="https://www.macbl.com/" target="_blank" rel="noopener">MacBL</a></p><h3 id="软件卸载工具"><a href="#软件卸载工具" class="headerlink" title="软件卸载工具"></a>软件卸载工具</h3><p><a href="https://segmentfault.com/a/1190000005035742" target="_blank" rel="noopener">好用的软件卸载工具</a></p><h3 id="Pycharm"><a href="#Pycharm" class="headerlink" title="Pycharm"></a>Pycharm</h3><p><a href="https://zhile.io/2018/08/17/jetbrains-license-server-crack.html" target="_blank" rel="noopener">安装Pycharm及破解</a></p><h3 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h3><p><a href="https://www.anaconda.com/distribution/" target="_blank" rel="noopener">Anaconda官网</a></p><p>将Anaconda加入环境变量：在<code>~/.bashrc</code>或<code>~./zshrc</code>中加入<code>export PATH=&quot;/Users/binbin/anaconda3/bin:$PATH&quot;</code></p><h3 id="多电脑共享键鼠Synergy"><a href="#多电脑共享键鼠Synergy" class="headerlink" title="多电脑共享键鼠Synergy"></a>多电脑共享键鼠Synergy</h3><blockquote><p><a href="https://pan.baidu.com/s/1PV_aY2BdgqmeFI5vLsEBXA" target="_blank" rel="noopener">度娘网盘</a></p><p>提取码：sk6h</p></blockquote><p>需要注意的：</p><ol><li><p>在第一次使用时需要去掉<code>编辑-&gt;设置-&gt;Use SSL Encryption</code>的勾，然后删除<code>~/Library/Synergy/SSL</code>文件夹</p></li><li><p>要写清楚主机和从机在局域网中的名称</p></li><li><p>如果从机是Mac，可以把Super和Ctrl键进行替换</p></li><li><p>如果出现不能复制粘贴的情况，可以重启Synergy</p></li><li><p>如果出现已连接但不能移动鼠标的情况，可以在主机端把从机清除再添加一次</p></li></ol><h3 id="Mactex"><a href="#Mactex" class="headerlink" title="Mactex"></a>Mactex</h3><p><a href="http://www.tug.org/mactex/" target="_blank" rel="noopener">MacTex</a></p><h3 id="Dash"><a href="#Dash" class="headerlink" title="Dash"></a>Dash</h3><p><a href="https://kapeli.com/dash" target="_blank" rel="noopener">安装</a><br><a href="https://kakarot.net/cgi-bin/dash-macos-license" target="_blank" rel="noopener">破解</a><br><a href="https://github.com/Kapeli/feeds" target="_blank" rel="noopener">DocSet下载</a>。下载后存放到<code>/Users/name/Library/Application Support/Dash/</code>中对应位置</p><h3 id="网速显示"><a href="#网速显示" class="headerlink" title="网速显示"></a>网速显示</h3><p><a href="https://github.com/yujitach/MenuMeters" target="_blank" rel="noopener">MenuMesters</a></p><h3 id="在目录下打开shell"><a href="#在目录下打开shell" class="headerlink" title="在目录下打开shell"></a>在目录下打开shell</h3><p><a href="https://zipzapmac.com/Go2Shell" target="_blank" rel="noopener">go2Shell</a></p><h3 id="视频播放器"><a href="#视频播放器" class="headerlink" title="视频播放器"></a>视频播放器</h3><p><a href="https://iina.io/" target="_blank" rel="noopener">IINA</a></p><h3 id="brew-amp-git"><a href="#brew-amp-git" class="headerlink" title="brew &amp; git"></a>brew &amp; git</h3><ul><li>安装Homebrew</li></ul><p><a href="https://brew.sh/" target="_blank" rel="noopener">https://brew.sh/</a></p><ul><li>安装git</li></ul><pre><code>brew install gitbrew link git --overwrite</code></pre><h3 id="Alfred"><a href="#Alfred" class="headerlink" title="Alfred"></a>Alfred</h3><p>一个很好用的搜索工具。</p><h3 id="ForkLift"><a href="#ForkLift" class="headerlink" title="ForkLift"></a>ForkLift</h3><p>一个很好用的文件管理工具，支持FTP、SMB等多种协议。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一些好用的功能&quot;&gt;&lt;a href=&quot;#一些好用的功能&quot; class=&quot;headerlink&quot; title=&quot;一些好用的功能&quot;&gt;&lt;/a&gt;一些好用的功能&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.macdaxue.com/force-touch/&quot; ta
      
    
    </summary>
    
      <category term="MacOS" scheme="https://yyb1995.github.io/categories/MacOS/"/>
    
    
  </entry>
  
  <entry>
    <title>Git常用命令</title>
    <link href="https://yyb1995.github.io/2019/10/18/Git/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://yyb1995.github.io/2019/10/18/Git/Git常用命令/</id>
    <published>2019-10-18T07:14:38.000Z</published>
    <updated>2019-10-18T07:14:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="提交一个工程到github"><a href="#提交一个工程到github" class="headerlink" title="提交一个工程到github"></a><a href="https://blog.csdn.net/codingEMIPark/article/details/78016588" target="_blank" rel="noopener">提交一个工程到github</a></h2><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><ul><li>git config –global user.name xxx</li><li>git config –global user.email <a href="mailto:xxx@xxx.com" target="_blank" rel="noopener">xxx@xxx.com</a></li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li><code>git init</code></li><li><code>git pull origin master</code></li><li><code>git push origin master</code></li><li><code>git add .</code></li><li><code>git add -A</code> 提交所有改变（包括删除）</li><li><code>git commit -m &#39;commit_content&#39;</code></li><li><code>git checkout filename</code></li><li><code>git clone xx</code></li><li><code>git clone xx --depth=1</code> 只拷贝最近一次的提交</li></ul><h2 id="在coding-net中添加项目的流程"><a href="#在coding-net中添加项目的流程" class="headerlink" title="在coding.net中添加项目的流程"></a>在coding.net中添加项目的流程</h2><pre><code>1. 将～/.ssh中的public key加入coding.net的设置中2. `git init`3. `git add .`4. `git commit -m &#39;content&#39;`5. `git remote add origin gitaddress`6. `git push origin master`</code></pre><h2 id="创建分支和转换的流程"><a href="#创建分支和转换的流程" class="headerlink" title="创建分支和转换的流程"></a>创建分支和转换的流程</h2><pre><code>1. 创建分支：`git branch &lt;name&gt;`2. 切换分支：`git checkout &lt;name&gt;`3. 创建加切换分支：`git checkout -b &lt;name&gt;`4. 删除本地分支：`git branch -d &lt;branch_name&gt;`</code></pre><h2 id="创建多个远程仓库并上传不同分支"><a href="#创建多个远程仓库并上传不同分支" class="headerlink" title="创建多个远程仓库并上传不同分支"></a>创建多个远程仓库并上传不同分支</h2><pre><code>1. 创建多个远程仓库：`git remote add &lt;name&gt; &lt;address&gt;`. 注意：远程仓库名不能于origin相同2. 上传不同分支到远程仓库： `git push &lt;remote_name&gt; &lt;local name&gt;`3. 删除远程仓库中的分支：`git push &lt;remote_name&gt; --delete &lt;branch_name&gt;`.注意，在github上删除master分支前要先到设置更改默认分支.</code></pre><h2 id="查看git的状态"><a href="#查看git的状态" class="headerlink" title="查看git的状态"></a>查看git的状态</h2><p><code>git status</code></p><h2 id="查看文件修改状态"><a href="#查看文件修改状态" class="headerlink" title="查看文件修改状态"></a>查看文件修改状态</h2><p><code>git diff (filename)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;提交一个工程到github&quot;&gt;&lt;a href=&quot;#提交一个工程到github&quot; class=&quot;headerlink&quot; title=&quot;提交一个工程到github&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://blog.csdn.net/codingEMIPark/ar
      
    
    </summary>
    
      <category term="Git" scheme="https://yyb1995.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://yyb1995.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>numpy</title>
    <link href="https://yyb1995.github.io/2019/10/18/PythonPackages/numpy/"/>
    <id>https://yyb1995.github.io/2019/10/18/PythonPackages/numpy/</id>
    <published>2019-10-18T07:14:38.000Z</published>
    <updated>2019-11-25T09:11:14.284Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导入numpy"><a href="#导入numpy" class="headerlink" title="导入numpy"></a>导入numpy</h2><p>常用代码：<code>import numpy as np</code>或<code>from numpy import *</code>。建议使用第一种。使用第一种时要在numpy函数前加上<code>np.xxx</code>，如·<code>np.array</code></p><h2 id="矩阵的创建"><a href="#矩阵的创建" class="headerlink" title="矩阵的创建"></a>矩阵的创建</h2><p>常用代码:</p><ol><li>创建数组<br><code>np.array([[1,2,3]])</code>创建一个1*3的numpy数组</li><li>创建全1矩阵<br><code>np.ones([a,b])</code>创建一个a*b的矩阵，元素全为1</li></ol><p><strong><em>注意：np.ones和np.zeros的参数是一维向量，需要使用[]，而np.random.rand不需要使用[]</em></strong></p><ol start="3"><li>创建全0矩阵<br><code>np.zeros([a,b])</code>创建一个a*b的矩阵，元素全为0</li><li>创建对角矩阵<br><code>np.diag([a,b,c])</code>创建一个对角线元素为a,b,c的矩阵<br><code>np.diag([[a,b,c],[d,e,f],[g,h,i]])</code>创建一个1*3向量，元素为矩阵对角线元素</li></ol><h2 id="矩阵的运算"><a href="#矩阵的运算" class="headerlink" title="矩阵的运算"></a>矩阵的运算</h2><ol><li><p>计算向量间的欧氏距离</p><pre><code class="python">a1 = np.array([[1,2],[2,3]])a2 = np.array([[2,0],[2,1]])dist = np.linalg.norm(a1 - a2)print(dist)</code></pre></li><li><p>一维数组的转置<br><code>np.transpose([a])</code></p></li><li><p>矩阵的排序<br><code>np.sort(a, axis=-1, kind=&#39;quicksort&#39;, order=None)</code><br>返回排序好的矩阵，a为原矩阵，axis为排序方向，axis = 0为纵轴排序，axis = 1位横轴排序</p></li><li><p>垂直合并矩阵<br><code>np.vstack((a,b))</code><br>将a,b矩阵垂直合并</p></li><li><p>水平合并矩阵<br><code>np.hstack((a,b))</code><br>将a,b矩阵水平合并</p></li><li><p>按矩阵某行排序<br><code>data = data[:,data[2].argsort()]</code><br>按第3行从小到大排序</p></li><li><p>按矩阵某列排序<br><code>data = data[data[:,2].argsort()]</code><br>按第3列从小到大排序</p></li><li><p>矩阵的乘法<br><code>np.dot(a,b)</code></p></li><li><p>多矩阵乘法<br><code>np.linalg.multi_dot([a,b,c])</code></p></li><li><p>矩阵的加法<br><code>np.sum(a)</code><br><code>np.sum(a,axis = 0)  #每列相加</code><br><code>np.sum(a,axis = 1)  #每行相加</code><br>axis代表相加后消失的维数</p></li><li><p>矩阵的删除<br><code>np.delete(X,0,axis=0)</code><br>删除矩阵第一行</p></li><li><p>行向量转列向量<br><code>a.shape = (3,1)</code></p></li><li><p>矩阵的随机化<br><code>np.random.shuffle(matrix)</code><br>沿着第一维进行重新排列。如果是二维数据，那么就按行进行重新排列</p></li><li><p>去除nan值<br><code>x = x[~np.isnan(x)]</code><br><code>np.nanmean(np.array([1, 2, 3, np.nan])</code></p></li><li><p>统计矩阵不重复的行或列<br><code>unq, cnt = np.unique(a, return_counts=True, axis=0)</code><br><code>return counts</code>表示返回不重复行/列的数目，<code>axis=0</code>表示从行的方向统计。</p></li><li><p>矩阵的重叠<br>在numpy中，矩阵的重叠有两种： np.tile()和np.repeat()。np.tile()是将整个矩阵进行重叠，np.repeat()是将矩阵中的每个元素进行重叠。</p><pre><code class="python">a = np.array([[1, 2, 3], [4, 5, 6]])b = np.tile(a, (2, 1))c = np.repeat(a, 2, axis=0)&gt;&gt;&gt; barray([[1, 2, 3],   [2, 3, 4],   [1, 2, 3],   [2, 3, 4]])&gt;&gt;&gt; carray([[1, 2, 3],   [1, 2, 3],   [2, 3, 4],   [2, 3, 4]])</code></pre></li><li><p>使用元组索引数组<br>可以使用元组对数组进行索引，即<code>a[(2, 3)]</code>。如果是其他类型的，可以使用<code>tuple()</code>进行转换。</p></li></ol><h2 id="矩阵元素操作"><a href="#矩阵元素操作" class="headerlink" title="矩阵元素操作"></a>矩阵元素操作</h2><ol><li>找出所有等于某个值的所有元素的下标<pre><code class="python">a = np.random.randint(1, 10, 100)np.where(a == 2)np.argwhere(a == 2)</code></pre></li></ol><h2 id="数据的产生"><a href="#数据的产生" class="headerlink" title="数据的产生"></a>数据的产生</h2><ol><li>正态分布数据<br><code>numpy.random.normal(loc, scale, size)</code><br>loc：float<br> 此概率分布的均值（对应着整个分布的中心centre）<br>scale：float<br> 此概率分布的标准差（对应于分布的宽度，scale越大越矮胖，scale越小，越瘦高）<br>size：int or tuple of ints<br> 输出的shape，默认为None，只输出一个值</li><li>随机分布数据<br><code>numpy.random.rand(a,b)</code>创建一个维数为a*b，数值在[0,1)的随机矩阵</li><li>标准正态分布数据中随机抽取<br><code>numpy.random.randn(a,b)</code>创建一个维数为a*b，数值取值为标准正态分布中随机取样本点</li><li>产生不重复随机数组<br><code>random.sample(a,b)</code>在a数组的范围内随机产生b个不重复的随机数</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;导入numpy&quot;&gt;&lt;a href=&quot;#导入numpy&quot; class=&quot;headerlink&quot; title=&quot;导入numpy&quot;&gt;&lt;/a&gt;导入numpy&lt;/h2&gt;&lt;p&gt;常用代码：&lt;code&gt;import numpy as np&lt;/code&gt;或&lt;code&gt;from nu
      
    
    </summary>
    
      <category term="Python Packages" scheme="https://yyb1995.github.io/categories/Python-Packages/"/>
    
    
      <category term="numpy" scheme="https://yyb1995.github.io/tags/numpy/"/>
    
  </entry>
  
  <entry>
    <title>Python常见问题和技巧</title>
    <link href="https://yyb1995.github.io/2019/10/18/Python/Python%E6%8A%80%E5%B7%A7/"/>
    <id>https://yyb1995.github.io/2019/10/18/Python/Python技巧/</id>
    <published>2019-10-18T07:14:38.000Z</published>
    <updated>2020-03-01T03:47:43.766Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模块修改后再次载入无变化"><a href="#模块修改后再次载入无变化" class="headerlink" title="模块修改后再次载入无变化"></a>模块修改后再次载入无变化</h2><pre><code class="python">import importlibimportlib.reload(PackageName)%load_ext autoreload%autoreload 2</code></pre><h2 id="python数据类型set"><a href="#python数据类型set" class="headerlink" title="python数据类型set"></a>python数据类型set</h2><p>set是一种无序集合。常见的方法有：</p><ol><li>创建集合<br><code>a = set(&#39;python&#39;)</code></li><li>向集合中传入一个元素并拆分<br><code>a.update(&#39;java&#39;)</code></li><li>删除集合中元素<br><code>a.remove(&#39;p&#39;)</code></li></ol><h2 id="利用列表生成字典"><a href="#利用列表生成字典" class="headerlink" title="利用列表生成字典"></a>利用列表生成字典</h2><pre><code class="python">a = [1, 2, 3]b = [4, 5, 6]dict1 = dict(zip(a, b))</code></pre><h2 id="初始化值类型的字典——defaultdict"><a href="#初始化值类型的字典——defaultdict" class="headerlink" title="初始化值类型的字典——defaultdict"></a>初始化值类型的字典——defaultdict</h2><p>在python中可以使用<code>collections</code>中的<code>defaultdict</code>对字典中的值类型进行初始化。在初始化<code>defaultdict</code>时，可以加上<code>int</code>，<code>list</code>等参数，表示值的默认类型。</p><h2 id="列表删除元素"><a href="#列表删除元素" class="headerlink" title="列表删除元素"></a>列表删除元素</h2><ol><li><code>a.remove(item)</code></li><li><code>del(a[index])</code></li><li><code>a.pop()</code></li></ol><h2 id="python-排序"><a href="#python-排序" class="headerlink" title="python 排序"></a>python 排序</h2><p><code>sorted([1, 2, 3, 5, 3])</code><br><code>[1, 2, 3, 6, 5].sort()</code></p><h2 id="python中的队列"><a href="#python中的队列" class="headerlink" title="python中的队列"></a>python中的队列</h2><pre><code>from collections import dequequeue = deque([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])queue.append(&#39;e&#39;)queue.popleft()</code></pre><h2 id="python数组按某列排序"><a href="#python数组按某列排序" class="headerlink" title="python数组按某列排序"></a>python数组按某列排序</h2><p><code>data[data[:,2].argsort()]</code><br>数组按第三列排序</p><h2 id="python-字典转变量"><a href="#python-字典转变量" class="headerlink" title="python 字典转变量"></a>python 字典转变量</h2><p><code>globals().update(dict)</code><br>例如： {foo: bar} -&gt; foo = bar</p><h2 id="Google注释规范"><a href="#Google注释规范" class="headerlink" title="Google注释规范"></a>Google注释规范</h2><pre><code class="python">def fetch_bigtable_rows(big_table, keys, other_silly_variable=None):    &quot;&quot;&quot;Fetches rows from a Bigtable.    Retrieves rows pertaining to the given keys from the Table instance    represented by big_table.  Silly things may happen if    other_silly_variable is not None.    Args:        big_table: An open Bigtable Table instance.        keys: A sequence of strings representing the key of each table row            to fetch.        other_silly_variable: Another optional variable, that has a much            longer name than the other args, and which does nothing.    Returns:        A dict mapping keys to the corresponding table row data        fetched. Each row is represented as a tuple of strings. For        example:        {&#39;Serak&#39;: (&#39;Rigel VII&#39;, &#39;Preparer&#39;),         &#39;Zim&#39;: (&#39;Irk&#39;, &#39;Invader&#39;),         &#39;Lrrr&#39;: (&#39;Omicron Persei 8&#39;, &#39;Emperor&#39;)}        If a key from the keys argument is missing from the dictionary,        then that row was not found in the table.    Raises:        IOError: An error occurred accessing the bigtable.Table object.    &quot;&quot;&quot;    pass</code></pre><p><strong>注意：</strong> 函数功能注释与参数说明之间应该空一行</p><h2 id="map、reduce和filter"><a href="#map、reduce和filter" class="headerlink" title="map、reduce和filter"></a>map、reduce和filter</h2><p>map用于将一个函数映射到后面给出的变量列表中，reduce用于将一个函数依次映射到后面的相邻变量中，filter用于筛选列表中符合某个函数条件的值</p><pre><code class="python">map(lambda x: x ** 2, range(1, 10))from functools import reducereduce(lambda x, y: x + y, range(1, 11))filter(lambda x: x % 2, range(1, 11))</code></pre><h2 id="号的使用"><a href="#号的使用" class="headerlink" title="*号的使用"></a>*号的使用</h2><ol><li>乘法符号</li><li>当*号用在函数定义时，作用是收集传入的参数，也就是把除<code>a=b</code>形式外的传入参数打包成一个元组，在函数中使用。**号作用相同，是把所有<code>a=b</code>形式的传入参数打包成字典，在函数中使用。</li><li>当*号用于函数调用时，作用是把以元组形式的参数集合展开并对应到各个参数位置上。</li></ol><pre><code class="python">def print(*param):    for item in param:        print(item)# Example 1def print_(a, b, c):    print(a)    print(b)    print(c)a = [&#39;ap&#39;, &#39;ba&#39;, &#39;or&#39;]print(*a)# Example 2def a():    return 1, 2, 3print(&#39;{} {} {}&#39;.format(*a()))# Example 3a = [1, 2, 3]b = [*a]print(b)</code></pre><h2 id="Python数组拷贝"><a href="#Python数组拷贝" class="headerlink" title="Python数组拷贝"></a>Python数组拷贝</h2><p>在进行Python的数组拷贝时，有时会用到切片操作。下面是一个例子：</p><pre><code class="python">dec_seq = torch.rand(3, 4, 5)dec_input = dec_seq[:, :-1]dec_output = dec_seq[:, 1:]</code></pre><p>实际上dec_input和dec_output只是对dec_seq的一个引用，并不是对对象的一个完整复制。当dec_seq的值改变时，dec_input和dec_output的值也会随之改变。因此，dec_input和dec_output更像是指向dec_seq一部分的指针。如果想对原数组进行完整的拷贝，应该使用copy模块中的copy和deepcopy。</p><ol><li>copy.copy 浅拷贝 只拷贝父对象，不会拷贝对象的内部的子对象。</li><li>copy.deepcopy 深拷贝 拷贝对象及其子对象<br>例子：<pre><code class="python">&gt;&gt;&gt; import copy&gt;&gt;&gt; a = [1,2,3,4,[&#39;a&#39;,&#39;b&#39;]]  #原始对象</code></pre></li></ol><blockquote><blockquote><blockquote><p>b = a  #赋值，传对象的引用</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>c = copy.copy(a)</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>d = copy.deepcopy(a)</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>a.append(5)<br>a[4].append(‘c’)</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>print ‘a=’,a<br>a= [1, 2, 3, 4, [‘a’, ‘b’, ‘c’], 5]<br>print ‘b=’,b<br>b= [1, 2, 3, 4, [‘a’, ‘b’, ‘c’], 5]<br>print ‘c=’,c<br>c= [1, 2, 3, 4, [‘a’, ‘b’, ‘c’]]<br>print ‘d=’,d<br>d= [1, 2, 3, 4, [‘a’, ‘b’]]</p><pre><code></code></pre></blockquote></blockquote></blockquote><h2 id="Python的异常处理机制"><a href="#Python的异常处理机制" class="headerlink" title="Python的异常处理机制"></a>Python的异常处理机制</h2><p>python有两种机制可以触发异常：</p><ol><li><p>try-except-else-finally<br>程序尝试执行try下的语句，如果触发异常就跳到相应的except语句，如果没有错误就跳到else语句。finally语句是无论是否发生错误都会执行。</p><pre><code class="python">try:&lt;语句&gt;        #尝试执行except &lt;异常类型1&gt;：&lt;语句&gt;        #如果在try部份引发了&#39;name&#39;异常except &lt;异常类型2&gt;，&lt;数据&gt;:&lt;语句&gt;        #如果引发了&#39;name&#39;异常，获得附加的数据else:&lt;语句&gt;        #正常执行finally:&lt;语句&gt;        #无论是否触发异常都执行的语句</code></pre></li><li><p>if-raise<br>程序尝试判断if语句下是否成立，如果成立，抛出raise下的error。</p><pre><code class="python">if expression: raise Exception</code></pre></li><li><p>自定义Error类型<br>需要自定义异常类型时，需要继承<code>Exception</code>类</p><pre><code class="python">class SomeCustomException(Exception): pass</code></pre></li><li><p>warnings模块<br>warnings.warn()函数用于生成警告信息。格式为：</p><pre><code class="python">if expression: warnings.warn(&#39;Warning message&#39;, WarningType)</code></pre><p>其中WarningType可以是Python模块中的warning，<a href="https://docs.python.org/3/library/warnings.html" target="_blank" rel="noopener">具体目录</a></p></li></ol><h2 id="Python-filter-函数"><a href="#Python-filter-函数" class="headerlink" title="Python filter()函数"></a>Python filter()函数</h2><p><code>filter(function, iterable)</code></p><p>filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。</p><p>该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。</p><p>使用方法：</p><pre><code class="python">filter1 = filter(lambda x: x &gt; 0, [-1, 0, 1, 5])filter1.next()</code></pre><h2 id="对于None的判断"><a href="#对于None的判断" class="headerlink" title="对于None的判断"></a>对于None的判断</h2><p>在 if判断中，None，False，空字符串，0，空列表，空字典，空元组都会被判断成False。因此在使用if not x判断是否为None时，需要排除其余可能的影响。因此，建议的判断方式为：if x is not None</p><h2 id="字符串join-方法"><a href="#字符串join-方法" class="headerlink" title="字符串join()方法"></a>字符串join()方法</h2><p>Python join()方法用于将序列中的元素以指定的字符连接生成一个新的字符串。str.join(sequence)即用str来连接sequence<br><code>a = &#39;&#39;.join(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;)</code></p><h2 id="响应键盘终止"><a href="#响应键盘终止" class="headerlink" title="响应键盘终止"></a>响应键盘终止</h2><pre><code class="python">except KeyboardInterrupt:    print(&#39;Interrupt&#39;)</code></pre><h2 id="字符串不转义"><a href="#字符串不转义" class="headerlink" title="字符串不转义"></a>字符串不转义</h2><p>在使用正则表达式时，通常不希望表示转义字符，方法是在字符串前加上<code>r</code>，如<code>r&#39;[]\&#39;</code>。</p><h2 id="heapq模块及其应用"><a href="#heapq模块及其应用" class="headerlink" title="heapq模块及其应用"></a>heapq模块及其应用</h2><p>Python中的heapq模块提供了基于堆的优先排序算法。堆可以看成完全二叉树，父节点的值永远比子节点小。一般在把列表转化成堆后直接调用<code>heappush</code>和<code>heappop</code>方法即可。</p><ol><li><code>heappush()</code>把元素放入堆</li><li><code>heappop()</code>返回堆中最小的元素</li><li><code>heappushpop()</code>把元素放入堆的同时返回最小的元素</li><li><code>heapify()</code>在线性时间内把一个列表转化为堆。注意，这个操作是把原列表直接转化为堆而不是创建一个新的堆</li><li><code>nlargest(n, list)</code>返回堆中最大的k个元素</li><li><code>nsmallest(n, list)</code>返回堆中最小的k个元素。<code>nlargest</code>和<code>nsmallest</code>通常用于在一个含有较多元素的列表中找出少数最值，<code>max()</code>和<code>min</code>通常用于找出最大/最小值，如果需要找的最值较多，推荐把列表进行排序后使用切片查找。</li><li><code>merge</code>用于将多个<code>iterable</code>对象进行归并排序。返回一个<code>generator</code>用于生成排序结果。<pre><code class="python">import heapqlist1 = [1, 5, 9, 2, 4]dict1 = [{&#39;a&#39;: 2}, {&#39;a&#39;: 3}, {&#39;a&#39;: 8}]heapq.nlargest(2, list1)heapq.nsmallest(4, list1)heapq.nlargest(2, dict1, key=lambda x: x[&#39;a&#39;])</code></pre></li></ol><h2 id="统计列表中各元素出现的次数"><a href="#统计列表中各元素出现的次数" class="headerlink" title="统计列表中各元素出现的次数"></a>统计列表中各元素出现的次数</h2><pre><code class="python">from Collections import Countera = [1, 2, 3, 2, 4, 2]counter = Counter(a)count_list = dict(counter)print(counter.most_common(3))</code></pre><h2 id="isinstance-方法"><a href="#isinstance-方法" class="headerlink" title="isinstance()方法"></a>isinstance()方法</h2><p>Python中<code>isinstance(object, classinfo)</code>方法用于判断一个对象是否是一个已知的类型，与<code>type()</code>类似。它们的区别在于</p><blockquote><p>type() 不会认为子类是一种父类类型，不考虑继承关系。</p><p>isinstance() 会认为子类是一种父类类型，考虑继承关系。</p><p>如果要判断两个类型是否相同推荐使用 isinstance()。</p></blockquote><p>对于classinfo的选择，可以是<br><code>int</code>，<code>float</code>，<code>bool</code>，<code>complex</code>，<code>str</code>，<code>list</code>，<code>dict</code>，<code>set</code>，<code>tuple</code>。</p><h2 id="global-和-nonlocal"><a href="#global-和-nonlocal" class="headerlink" title="global 和 nonlocal"></a>global 和 nonlocal</h2><p>global用于声明全局变量。如果在函数内部修改函数外的变量，需要在函数中声明全局变量。</p><pre><code class="python">foo = 0def bar():    global foo    foo += 1</code></pre><p>nonlocal用于声明在内层函数中使用的变量。</p><pre><code class="python">def foo1():    bar = 0    def foo2():        nonlocal bar        bar += 1        return bar    return foo2()</code></pre><h1 id="测试程序运行时间"><a href="#测试程序运行时间" class="headerlink" title="测试程序运行时间"></a>测试程序运行时间</h1><p>可以使用<code>time</code>或<code>timeit</code>模块测试程序的运行时间</p><pre><code class="python">def foo(param):    passimport timestart = time.time()foo()end = time.time()print(end - start)from timeit import timeitprint(timeit(&#39;foo(x)&#39;, setup=&#39;from __main__ import foo&#39;, globals={&#39;x&#39;: param}), number=1)</code></pre><h2 id="逻辑运算符运算顺序"><a href="#逻辑运算符运算顺序" class="headerlink" title="逻辑运算符运算顺序"></a>逻辑运算符运算顺序</h2><p>python中逻辑运算符包括<code>not</code>，<code>and</code>和<code>or</code>，其运算顺序为<code>not&gt;and&gt;or</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;模块修改后再次载入无变化&quot;&gt;&lt;a href=&quot;#模块修改后再次载入无变化&quot; class=&quot;headerlink&quot; title=&quot;模块修改后再次载入无变化&quot;&gt;&lt;/a&gt;模块修改后再次载入无变化&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import 
      
    
    </summary>
    
      <category term="Python" scheme="https://yyb1995.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://yyb1995.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch常用tensor操作</title>
    <link href="https://yyb1995.github.io/2019/10/18/Pytorch/Pytorch%E4%B8%AD%E5%B8%B8%E7%94%A8tensor%E6%93%8D%E4%BD%9C/"/>
    <id>https://yyb1995.github.io/2019/10/18/Pytorch/Pytorch中常用tensor操作/</id>
    <published>2019-10-18T07:14:38.000Z</published>
    <updated>2019-10-18T07:14:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-torch-cat"><a href="#1-torch-cat" class="headerlink" title="1 torch.cat"></a>1 torch.cat</h2><p>cat指的是对多个Tensor在<strong>原有某一维度</strong>进行拼接，拼接的结果是Tensor的总维数不变，其中用于拼接的那一维等于各分量维数之和。示例：</p><pre><code class="python">x = torch.rand(2, 3)y = torch.rand(4, 3)z = torch.cat((x, y), 0)</code></pre><p>即x和y沿着axis=0的维度进行拼接，得到的结果是一个(6*3)的Tensor<br>此外，还有如下用法：</p><ol><li><code>torch.cat((x, x), 0)</code></li><li><code>torch.cat([torch.rand(3, 4), torch.rand(5, 4)], dim=0)</code> </li></ol><h2 id="2-torch-chunk"><a href="#2-torch-chunk" class="headerlink" title="2 torch.chunk"></a>2 torch.chunk</h2><p><code>torch.chunk(tensor, chunks, dim=0)</code><br>chunk可以看成cat的逆操作，即将一个矩阵沿着某一维分割开。chunks为分割的份数， dim为分割的维度。例子：</p><pre><code class="python">x = torch.zeros(2, 3, 4)y = torch.chunk(x, 3, 1)</code></pre><p>得到的y是一个tuple，每一个的维度为(2, 1, 4)<br>还可使用Tensor.chunks(chunks, dim=0)效果与上相同。</p><h2 id="3-torch-stack"><a href="#3-torch-stack" class="headerlink" title="3 torch.stack"></a>3 torch.stack</h2><p>stack指的是在<strong>新的维度上</strong>进行拼接，这个操作会增加维度。示例：</p><pre><code class="python">x = torch.ones(1, 3)y = torch.ones(1, 3)z1 = torch.stack((x, y), 0)z2 = torch.stack((x, y), 1)z3 = torch.stack((x, y), 2)</code></pre><p>输出维数规律：除拼接的维数外别的维数保持不变，拼接的维数等于输入个数之和。则上述三个输出的维数分别为：<br>z1:(2, 1, 3), z2:(1, 2, 3), z3:(1, 3, 2)。<br><strong>注意：</strong> torch.stack的输入tensor的维数必须一致，这样才能保证在能够在新的维度进行拼接操作。</p><h2 id="4-torch-transpose"><a href="#4-torch-transpose" class="headerlink" title="4 torch.transpose"></a>4 torch.transpose</h2><p>transpose指的是将Tensor的某两个维度进行交换。示例：</p><pre><code class="python">x = torch.zeros(2, 3)y = torch.transpose(x, 0, 1)</code></pre><h2 id="5-permute-amp-reshape"><a href="#5-permute-amp-reshape" class="headerlink" title="5 permute &amp; reshape"></a>5 permute &amp; reshape</h2><p>permute是适合于多维度的维数交换。使用方法：输入希望产生的维度即可。例子：</p><pre><code class="python">x = torch.zeros(2, 3, 4)y = x.permute(2, 1, 0)</code></pre><p>输出y的维度为:(4, 3, 2)</p><p>reshape和permute功能类似，不过reshape一般用于连续维度的改变，如</p><pre><code class="python">x = torch.zeros(2, 3, 4)y = x.reshape(2, 6, 2)</code></pre><p>如果用于reshape的维度不是连续的，会出现数据改变的情况。</p><h2 id="6-squeeze"><a href="#6-squeeze" class="headerlink" title="6 squeeze"></a>6 squeeze</h2><p>squeeze是将某一个维度为1的维去除。使用方法：x.squeeze()。<br>例子：</p><pre><code class="python">x = torch.zeros(3, 1, 2)y = x.squeeze(1)</code></pre><p>得到的y的维度为(3, 2)。如果选择的维数不为1，那么得到的结果的维数与原Tensor的维数一致</p><h2 id="7-unsqueeze"><a href="#7-unsqueeze" class="headerlink" title="7 unsqueeze"></a>7 unsqueeze</h2><p>unsqueeze是增加一个维度，维度位置为dim。使用方法：a.unsqueeze(dim)。<br>例子：</p><pre><code class="python">x = torch.zeros(3, 2)y = x.unsqueeze(2)</code></pre><p>得到的y的维数为：(3, 2, 1)<br>use repeat – this will copy each vector 28 times.</p><p>X = torch.randn(100, 700)<br>X = X.unsqueeze(2).repeat(1, 1, 28)</p><h2 id="8-torch-masked-fill"><a href="#8-torch-masked-fill" class="headerlink" title="8 torch.masked_fill"></a>8 torch.masked_fill</h2><p>masked_fill将一个tensor中为1的元素用指定的值填充。例如：</p><pre><code class="python">a = torch.ones(3, 3)</code></pre><h2 id="9-torch-view"><a href="#9-torch-view" class="headerlink" title="9 torch.view"></a>9 torch.view</h2><p>view将一个tensor变换维度，但其中的数值保持不变</p><h2 id="10-torch-bmm"><a href="#10-torch-bmm" class="headerlink" title="10 torch.bmm"></a>10 torch.bmm</h2><p>bmm即batch_matmul，作用是不考虑batch维度将两个矩阵相乘。</p><pre><code class="python">a = torch.ones(128, 4, 3)b = torch.ones(128, 3, 10)result = torch.bmm(a, b)print(result.shape)&gt;&gt;&gt; (128, 4, 10)</code></pre><h2 id="11-expand-amp-repeat"><a href="#11-expand-amp-repeat" class="headerlink" title="11 expand&amp;repeat"></a>11 expand&amp;repeat</h2><p>expand和repeat都用于扩展Tensor的维度。<strong>使用前提：原矩阵的维度和扩展后矩阵的维度一致。因此通常先进行squeeze(dim)或unsqueeze(dim)操作</strong>。expand的输入参数是扩展后Tensor的维度，repeat的输入参数是扩展后Tensor相对于原Tensor扩展的倍数。<strong>此外，注意expand仅限于对张量中维数为1的维度的扩展，否则会报类型不匹配错误。</strong> 例如：</p><pre><code class="python">a = torch.Tensor([1, 2, 3])# 最终维数为(3, 5)，相当于第一维不变，第二维扩展5次b = a.unsqueeze(1).expand(3, 5)# 在第一维扩展1次，在第二维扩展5次c = a.unsqueeze(1).repeat(1, 5)# output:tensor([[1., 1., 1., 1., 1.],        [2., 2., 2., 2., 2.],        [3., 3., 3., 3., 3.]])# RuntimeError: The expanded size of the tensor (6) must match the existing size (3) at non-singleton dimension 2.  Target sizes: [1, 4, 6].  Tensor sizes: [1, 2, 3]a.expand(1, 4, 6)</code></pre><p>expand不会复制数组内存，节省空间。repeat会复制所有数据</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-torch-cat&quot;&gt;&lt;a href=&quot;#1-torch-cat&quot; class=&quot;headerlink&quot; title=&quot;1 torch.cat&quot;&gt;&lt;/a&gt;1 torch.cat&lt;/h2&gt;&lt;p&gt;cat指的是对多个Tensor在&lt;strong&gt;原有某一维度&lt;/st
      
    
    </summary>
    
      <category term="Pytorch" scheme="https://yyb1995.github.io/categories/Pytorch/"/>
    
    
      <category term="Pytorch" scheme="https://yyb1995.github.io/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch知识点学习</title>
    <link href="https://yyb1995.github.io/2019/10/18/Pytorch/Pytorch%E5%AD%A6%E4%B9%A0/"/>
    <id>https://yyb1995.github.io/2019/10/18/Pytorch/Pytorch学习/</id>
    <published>2019-10-18T07:11:06.000Z</published>
    <updated>2019-10-18T07:11:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-torch-nn和torch-nn-functional中神经网络层的区别"><a href="#1-torch-nn和torch-nn-functional中神经网络层的区别" class="headerlink" title="1 torch.nn和torch.nn.functional中神经网络层的区别"></a>1 torch.nn和torch.nn.functional中神经网络层的区别</h2><p>torch.nn中的层是类，torch.nn.functional中的层是函数。torch.nn中的forward()方法是调用torch.nn.functional实现。因此两者从原理上等价。torch.nn一般用于较复杂层的实现，torch.nn.functional一般用于简单层的实现</p><h2 id="2-Pytorch的层建立方式"><a href="#2-Pytorch的层建立方式" class="headerlink" title="2 Pytorch的层建立方式"></a>2 Pytorch的层建立方式</h2><ol><li><p>nn.Sequential().add_module(layer)</p><pre><code class="python">net1 = nn.Sequential()net1.add_module(&#39;conv&#39;, nn.Conv2d(3, 3, 3))net1.add_module(&#39;batchnorm&#39;, nn.BatchNorm2d(3))net1.add_module(&#39;activation_layer&#39;, nn.ReLU())</code></pre></li><li><p>nn.Sequential(layer)</p><pre><code class="python">net2 = nn.Sequential( nn.Conv2d(3, 3, 3), nn.BatchNorm2d(3), nn.ReLU() )</code></pre></li><li><p>nn.Sequential(OrderedDict([(multi layername, layer)]))</p><pre><code class="python">from collections import OrderedDictnet3 = nn.Sequential(OrderedDict([ (&#39;conv&#39;, nn.Conv2d(3, 3, 3)), (&#39;batchnorm&#39;, nn.BatchNorm2d(3)), (&#39;activation_layer&#39;, nn.ReLU())]))</code></pre></li></ol><pre><code>4. nn.ModuleList([layers])```pythonmodel1 = nn.ModuleList(    nn.Linear(10, 1) for _ in range(3))</code></pre><h2 id="3-Pytorch自定义层的编写"><a href="#3-Pytorch自定义层的编写" class="headerlink" title="3 Pytorch自定义层的编写"></a>3 Pytorch自定义层的编写</h2><p>下面是一个典型的Pytorch自定义层的实现方法</p><pre><code class="python">class ScaledDotProductAttention(nn.Module):    &quot;&quot;&quot; Scaled Dot-Product Attention &quot;&quot;&quot;    def __init__(self, temperature, attn_dropout=0.1):        &quot;&quot;&quot;        :param temperature: scale parameter in the equation            out = Q * K.T / temperature * V. Default is \sqrt d_k        :param attn_dropout: dropout rate in the self-attention            layer        &quot;&quot;&quot;        super(ScaledDotProductAttention, self).__init__()        self.temperature = temperature        self.dropout = nn.Dropout(attn_dropout)        self.softmax = nn.Softmax(dim=2)    def forward(self, q, k, v, mask=None):        &quot;&quot;&quot;        Calculate self-attention output        :param q: size: (batch_size, max_seq_len or input_len, d_k)        :param k: same as q        :param v: size: (batch_size, max_seq_len or input_len, d_k)        :param mask:        :return:        &quot;&quot;&quot;        attn = torch.bmm(q, k.transpose(1, 2))        attn = attn / self.temperature        if mask is not None:            attn = attn.masked_fill(mask, -np.inf)        attn = self.softmax(attn)        attn = self.dropout(attn)        output = torch.bmm(attn, v)        return output, attn</code></pre><p>在<code>self.__init__()</code>函数中，完成对层中要使用的Tensor和调用的层的产生和初始化。初始化可以直接写在<code>__init__()</code>方法中，也可以单独创建一个<code>self.reset_parameters()</code>方法，在<code>__init__()</code>方法中调用。初始化可以自定义，也可以使用<code>torch.nn.init</code>中提供的初始化方法。在该方法中调用的层只是对层的声明，并不是调用。</p><p>在<code>self.forward()</code>方法中，完成对调用该层时完成的功能的编写。层的输出写在return行。</p><h2 id="4-Pytorch中常见的层"><a href="#4-Pytorch中常见的层" class="headerlink" title="4 Pytorch中常见的层"></a>4 Pytorch中常见的层</h2><ol><li><p>LayerNorm<br>LayerNorm层是对数据的最后一维进行归一化。多用在深层RNN中。</p></li><li><p>Conv1d</p><pre><code class="python">Conv1dclass torch.nn.Conv1d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True)</code></pre><p>in_channels是输入数据第二维，out_channels是输出数据第二维，kernel_size是卷积占的列数。<br>输入：shape为(a, b, c)的Tensor。Conv1d在最后一维做卷积，卷积核的维数是(in_channels, out_channels, kernel_size)。输出的第二维是out_channels，说明用out_channels个不同的卷积做运算，输出第三维是c - kernel_size + 1,表示共卷积的次数。</p><pre><code class="python"># 一个Conv1d的例子m = nn.Conv1d(16, 33, 3, stride=2)input = torch.randn(20, 16, 50)output = m(input)print(output.shape)print(m.weight.shape)</code></pre><p>输出为torch.Size([20, 33, 48])和torch.Size([33, 16, 3])。原理为：Conv1d只在最后一维做卷积。第二维由in_channels变为out_channels，说明共有out_channels组卷积核，1组in_channels个，卷积核宽度为3，每个卷积核分别与输入数据第二维中的一行做卷积。</p></li><li><p>Conv2d</p><pre><code class="python">CLASS torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True)# 一个Conv2d的例子：m = nn.Conv2d(16, 33, (3, 4))input = torch.randn(20, 16, 50, 100)output = m(input)print(output.size)print(m.weight.size)</code></pre><p>输出为torch.Size([16, 33, 48, 97])和torch.Size([33, 16, 3, 4])。原理为：Conv2d的in_channels和out_channels与Conv1d保持一致，不同的是kernel_size可以是两维的，也就是同时对input的最后两维进行卷积。其他部分与Conv1d相同。因此由Conv1d不难推出Conv2d的维数变换规律。</p></li></ol><h2 id="5-Pytorch中的数据处理"><a href="#5-Pytorch中的数据处理" class="headerlink" title="5 Pytorch中的数据处理"></a>5 Pytorch中的数据处理</h2><p>reference:<a href="https://zhuanlan.zhihu.com/p/30934236" target="_blank" rel="noopener">Pytorch数据读取(Dataset, DataLoader, DataLoaderIter)</a></p><h3 id="5-1-torch-utils-data-Dataset"><a href="#5-1-torch-utils-data-Dataset" class="headerlink" title="5.1 torch.utils.data.Dataset"></a>5.1 <code>torch.utils.data.Dataset</code></h3><p>reference: <a href="http://pytorch.apachecn.org/cn/docs/0.3.0/data.html?highlight=dataloader#torch.utils.data.Dataset" target="_blank" rel="noopener">Pytorch cn doc</a><br>Dataset是一个抽象类，用于将数据封装成Dataset类。它是一个抽象类。在具体使用时需要继承Dataset类并实现其中的2个方法：</p><ul><li><code>__getitem__(self, index)</code><br> 用于决定每次如何取数据。比如对于形如(batch_size, input_length)的数据，每次读取第index行数据</li><li><code>__len__()</code><br> 用于获取数据的长度</li></ul><pre><code class="python">class DealDataset(Dataset):    &quot;&quot;&quot;        下载数据、初始5. Pytorch中的数据处理数据，都可以在这里完成    &quot;&quot;&quot;    def __init__(self):        xy = np.loadtxt(&#39;../dataSet/diabetes.csv.gz&#39;, delimiter=&#39;,&#39;, dtype=np.float32) # 使用numpy读取数据        self.x_data = torch.from_numpy(xy[:, 0:-1])        self.y_data = torch.from_numpy(xy[:, [-1]])        self.len = xy.shape[0]    def __getitem__(self, index):        return self.x_data[index], self.y_data[index]    def __len__(self):        return self.len</code></pre><h3 id="5-2-torch-utils-data-DataLoader"><a href="#5-2-torch-utils-data-DataLoader" class="headerlink" title="5.2 torch.utils.data.DataLoader"></a>5.2 <code>torch.utils.data.DataLoader</code></h3><p>reference:<a href="http://pytorch.apachecn.org/cn/docs/0.3.0/data.html?highlight=dataloader#torch.utils.data.DataLoader" target="_blank" rel="noopener">Pytorch cn doc</a></p><p>用于定义从Dataset中读取数据的方式，包括batch_size, shuffle等</p><pre><code class="python税务总局发票">class torch.utils.data.DataLoader(dataset, batch_size=1, shuffle=False, sampler=None, batch_sampler=None, num_workers=0, collate_fn=&lt;function default_collate at 0x4316c08&gt;, pin_memory=False, drop_last=False)</code></pre><p>主要参数：</p><ul><li>dataset: dataset对象</li><li>batch_size: 每个 batch 加载多少个样本 (默认值: 1)</li><li>shuffle: 设置为 True 时, 会在每个 epoch 重新打乱数据 (默认值: False).</li></ul><pre><code class="python">train_loader = DataLoader(dataset=dealDataset, batch_size=32, shuffle=True)</code></pre><h3 id="5-3-训练过程"><a href="#5-3-训练过程" class="headerlink" title="5.3 训练过程"></a>5.3 训练过程</h3><pre><code class="python">for epoch in epochs:    for i, batch in enumerate(train_loader):    print(&#39;the {}th batch: {}&#39;.format(i, batch))</code></pre><p><strong>注意:</strong>如果在dataloader中定义了多个返回值，那么在训练过程中每个batch都是一个list，使用batch[i]或者(train, test)来调用每个batch中的参数</p><h2 id="6-Pytorch中的数据类型及相互转换"><a href="#6-Pytorch中的数据类型及相互转换" class="headerlink" title="6 Pytorch中的数据类型及相互转换"></a>6 Pytorch中的数据类型及相互转换</h2><p>Pytorch中dtype是tensor的一个属性，使用<code>tensor.dtype</code>获取一个张量的数据类型。主要包括以下几类：</p><table><thead><tr><th>Data type</th><th>dtype</th><th>Tensor types</th></tr></thead><tbody><tr><td>32-bit floating point</td><td><code>torch.float32</code> or <code>torch.float</code></td><td><code>torch.*.FloatTensor</code></td></tr><tr><td>64-bit floating point</td><td><code>torch.float64</code> or <code>torch.double</code></td><td><code>torch.*.DoubleTensor</code></td></tr><tr><td>16-bit floating point</td><td><code>torch.float16</code> or <code>torch.half</code></td><td><code>torch.*.HalfTensor</code></td></tr><tr><td>8-bit integer (unsigned)</td><td><code>torch.uint8</code></td><td><code>torch.*.ByteTensor</code></td></tr><tr><td>8-bit integer (signed)</td><td><code>torch.int8</code></td><td><code>torch.*.CharTensor</code></td></tr><tr><td>16-bit integer (signed)</td><td><code>torch.int16</code> or <code>torch.short</code></td><td><code>torch.*.ShortTensor</code></td></tr><tr><td>32-bit integer (signed)</td><td><code>torch.int32</code> or <code>torch.int</code></td><td><code>torch.*.IntTensor</code></td></tr><tr><td>64-bit integer (signed)</td><td><code>torch.int64</code> or <code>torch.long</code></td><td><code>torch.*.LongTensor</code></td></tr></tbody></table><p>数据类型的查看：数据类型之间的转换使用<code>Tensor.long()</code>或<code>dtype=torch.long</code>实现。转换函数有：<code>long(), int(), double(), float(), byte()</code></p><p><strong>注意：</strong> </p><ol><li>Pytorch中的一些层对输入的tensor类型有要求。如Embedding层要求输入的tensor为<code>torch.long</code>类型。</li><li>如果Pytorch的数据来源是numpy，要十分注意numpy和pytorch的数据类型匹配。在numpy中，默认数据类型是<code>float</code>，但<code>float</code>与<code>np.float64</code>等价；在pytorch中，整数默认数据类型是<code>torch.long</code>，小数默认数据类型是<code>torch.float</code>，但<code>float</code>与<code>torch.float32</code>等价。也就是说，如果不加转换地使用<code>torch.from_numpy</code>，numpy中的数组将会被转换成pytorch中的<code>torch.double</code>类型。数据类型的不匹配将造成网络无法正确搭建。解决方法：在numpy端将数据转换为<code>np.float32</code>类型，即<code>.astype(np.float32)</code><pre><code class="python">a = np.sin([i for i in range(10)]).astype(np.float)print(a.dtype)</code></pre></li></ol><h2 id="7-Pytorch中的数据运算位置及相互转换"><a href="#7-Pytorch中的数据运算位置及相互转换" class="headerlink" title="7 Pytorch中的数据运算位置及相互转换"></a>7 Pytorch中的数据运算位置及相互转换</h2><p>Pytorch中device是tensor的一个属性，使用<code>tensor.device</code>获取一个张量的运算位置。</p><ul><li>从cpu转换到gpu：<code>tensor.to(&#39;cuda&#39;)</code>或<code>tensor.cuda()</code></li><li>从gpu转换到cpu：<code>tensor.to(&#39;cpu&#39;)</code>或<code>tensor.cpu()</code></li></ul><p>此外，还要注意tensor和numpy数组之间的转换只能在cpu上完成。即要先使用<code>tensor.to(&#39;cpu&#39;)</code>后才能使用<code>tensor.numpy()</code></p><h2 id="8-Pytorch展示模型结构"><a href="#8-Pytorch展示模型结构" class="headerlink" title="8 Pytorch展示模型结构"></a>8 Pytorch展示模型结构</h2><ol><li>展示模型所有层：<code>print(modelname)</code></li><li>展示模型所有参数：<code>print(list(model.named_parameters()))</code></li></ol><h2 id="9-Pytorch学习率调整"><a href="#9-Pytorch学习率调整" class="headerlink" title="9 Pytorch学习率调整"></a>9 Pytorch学习率调整</h2><p>使用的类：torch.optim.lr_scheduler。这个类的optimizer为常用的优化方法。如果使用scheduler，则在训练过程中只需写scheduler.step()而不需写optimizer.step()。</p><p>常用的学习率调整方法：</p><ol><li><p><code>torch.optim.lr_scheduler.StepLR(optimizer, step_size, gamma=0.1, last_epoch=-1)</code> </p><p>每过step_size将learning_rate调整为gamma * learning_rate.</p></li><li><p><code>torch.optim.lr_scheduler.MultiStepLR(optimizer, milestones, gamma=0.1, last_epoch=-1)</code></p><p>每到milestones中包含的训练次数时把learning_rate调整为gamma * learning_rate.</p><p>milestones:包含迭代次数的列表，必须递增。</p></li><li><p><code>torch.optim.lr_scheduler.ReduceLROnPlateau(optimizer, mode=&#39;min&#39;, factor=0.1, patience=10, verbose=False, threshold=0.0001, threshold_mode=&#39;rel&#39;, cooldown=0, min_lr=0, eps=1e-08)</code></p><p>学习率递减函数。当模型性能不再提升时将学习率减少。</p><p>mode: ‘min’或’max’。在’min’模式下，衡量标准不再下降时学习率减小。</p><p>factor: 学习率更新系数</p><p>patience: 学习率更新前指标不再下降/上升的迭代次数</p><p>verbose: 每次更新学习率时是否打印信息</p></li></ol><h2 id="10-Pytorch设置随机数种子"><a href="#10-Pytorch设置随机数种子" class="headerlink" title="10 Pytorch设置随机数种子"></a>10 Pytorch设置随机数种子</h2><pre><code class="python">torch.manual_seed(args.seed)torch.cuda.manual_seed(args.seed)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-torch-nn和torch-nn-functional中神经网络层的区别&quot;&gt;&lt;a href=&quot;#1-torch-nn和torch-nn-functional中神经网络层的区别&quot; class=&quot;headerlink&quot; title=&quot;1 torch.nn和tor
      
    
    </summary>
    
      <category term="Pytorch" scheme="https://yyb1995.github.io/categories/Pytorch/"/>
    
    
      <category term="Pytorch" scheme="https://yyb1995.github.io/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>Git学习</title>
    <link href="https://yyb1995.github.io/2019/10/17/Git/Git%E5%AD%A6%E4%B9%A0/"/>
    <id>https://yyb1995.github.io/2019/10/17/Git/Git学习/</id>
    <published>2019-10-17T13:49:43.000Z</published>
    <updated>2020-02-29T09:50:31.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>Git是由Linux之父使用C语言开发的一个分布式版本控制系统。分布式版本控制系统的特点是没有中央服务器，每一个人的电脑上都有一个完整的版本库。</p><h2 id="Git安装与全局配置"><a href="#Git安装与全局配置" class="headerlink" title="Git安装与全局配置"></a>Git安装与全局配置</h2><p>在Windows系统下可以从官网下载Git安装包。在Mac系统下已经自带Git，如果需要安装更新版本，可以使用homebrew。</p><p>在安装完成后，可以进行全局用户名和电子邮件设置</p><pre><code class="git">git config --global user.name &#39;name&#39;git config --global user.email &#39;123@example.com&#39;</code></pre><p>如果忘记已经设置的用户名和电子邮件，可以使用以下命令查看</p><pre><code class="git">git config --global user.namegit config --global user.email</code></pre><p>如果文件夹名称中有中文，会出现乱码情况。可以使用<br><code>git config --global core.quotepath false</code></p><p>在Mac下git默认语言为中文，如果想改为中文，可以在<code>~/.zshrc</code>中加入<br><code>export LC_ALL=en_US.UTF-8</code></p><h2 id="创建一个仓库"><a href="#创建一个仓库" class="headerlink" title="创建一个仓库"></a>创建一个仓库</h2><p><code>git init</code></p><h2 id="把文件添加到仓库"><a href="#把文件添加到仓库" class="headerlink" title="把文件添加到仓库"></a>把文件添加到仓库</h2><p><code>git add filename</code></p><h2 id="对本次操作进行说明"><a href="#对本次操作进行说明" class="headerlink" title="对本次操作进行说明"></a>对本次操作进行说明</h2><p><code>git commit -m &#39;add a file&#39;</code></p><ul><li>对上次的提交信息进行修改和更新<br><code>git commit --amend -m</code></li></ul><h2 id="查看仓库当前状态"><a href="#查看仓库当前状态" class="headerlink" title="查看仓库当前状态"></a>查看仓库当前状态</h2><p><code>git status</code></p><h2 id="查看具体文件修改的内容"><a href="#查看具体文件修改的内容" class="headerlink" title="查看具体文件修改的内容"></a>查看具体文件修改的内容</h2><p><code>git diff filename</code></p><h2 id="查看版本历史记录"><a href="#查看版本历史记录" class="headerlink" title="查看版本历史记录"></a>查看版本历史记录</h2><ul><li><p>完整显示<br><code>git log</code></p></li><li><p>单行显示<br><code>git log --pretty=oneline</code></p></li></ul><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><ul><li><p>回退一个版本<br><code>git reset --hard HEAD^</code></p></li><li><p>回退n个版本<br><code>git reset --hard HEAD~n</code></p></li><li><p>根据版本号回退版本(不需写完整版本号)<br><code>git reset --hard 1234a</code></p></li><li><p>误操作时查看命令历史和版本号<br><code>git reflog</code></p></li></ul><h2 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h2><p>在Git中，平时工作的文件夹称为工作区，<code>.git</code>目录中存放的称为版本库。在版本库中存在一个暂存区。<code>git add</code>可以把文件放入暂存区。<code>git commit</code>可以把暂存区的改动提交到新的分支。如果对文件进行了多次修改，只有经过了<code>git add</code>的改动才会被暂存区记录，否则不会被记录。</p><h2 id="丢弃某个文件的修改-还原文件"><a href="#丢弃某个文件的修改-还原文件" class="headerlink" title="丢弃某个文件的修改(还原文件)"></a>丢弃某个文件的修改(还原文件)</h2><ul><li>这个修改没有经过<code>git add</code>加入暂存区</li></ul><p><code>git checkout -- file</code></p><ul><li>这个修改已经经过<code>git add</code>加入暂存区<pre><code class="git">git rm --cached [filename]</code></pre></li></ul><h2 id="撤销提交"><a href="#撤销提交" class="headerlink" title="撤销提交"></a>撤销提交</h2><ul><li><p>新增一次提交以抵消上一次提交的变化，不会改变过去的所有历史<br><code>git revert head</code></p></li><li><p>新增多次提交以抵消某几次提交的变化<br><code>git revert [倒数第一次] [倒数第二次]</code></p></li></ul><h2 id="丢弃提交"><a href="#丢弃提交" class="headerlink" title="丢弃提交"></a>丢弃提交</h2><p>丢弃提交的含义是使某次提交之后的所有提交在历史中彻底删除，仍可以使用<code>git reflog</code>查看记录</p><p><code>git reset [某次提交]</code></p><p>还可以加上<code>--hard</code>参数，表示让工作区的文件也回到过去的状态</p><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><ul><li>删除没有经过<code>git add</code>的文件</li></ul><p><code>rm file</code></p><ul><li>删除已经经过<code>git add</code>的文件</li></ul><pre><code class="git">rm filegit rm file</code></pre><h2 id="本地仓库与远程仓库的结合"><a href="#本地仓库与远程仓库的结合" class="headerlink" title="本地仓库与远程仓库的结合"></a>本地仓库与远程仓库的结合</h2><ul><li>把一个本地仓库与远程仓库关联</li></ul><p><code>git remote add origin git@github.com:xxx.git</code></p><p>其中<code>origin</code>表示远程仓库名。</p><ul><li>把本地仓库的内容推送到远程仓库</li></ul><p><code>git push -u origin master</code></p><ul><li>把远程仓库的内容拷贝到本地仓库<br><code>git clone git@github.com:xxx.git</code></li></ul><h2 id="git分支"><a href="#git分支" class="headerlink" title="git分支"></a>git分支</h2><ul><li>创建一个分支并切换到该分支</li></ul><p><code>git checkout -b dev</code></p><p><code>git switch -c dev</code></p><ul><li>创建一个分支</li></ul><p><code>git branch dev</code></p><ul><li>删除一个分支</li></ul><p><code>git branch -d dev</code></p><ul><li>切换到dev分支</li></ul><p><code>git checkout dev</code></p><p><code>git switch dev</code></p><ul><li>查看所有分支</li></ul><p><code>git branch</code></p><ul><li>把a分支合并到b分支</li></ul><pre><code class="git">git checkout bgit merge a</code></pre><ul><li>非快速合并模式<br><code>git merge --no-ff -m &#39;merge with no-diff&#39; dev</code></li></ul><h2 id="保存和恢复当前没提交的工作"><a href="#保存和恢复当前没提交的工作" class="headerlink" title="保存和恢复当前没提交的工作"></a>保存和恢复当前没提交的工作</h2><ul><li><p>保存暂存区的工作<br><code>git stash</code></p></li><li><p>恢复暂存区的工作并删除临时存储内容<br><code>git stash pop</code></p></li></ul><h2 id="把特定修改复制到当前分支"><a href="#把特定修改复制到当前分支" class="headerlink" title="把特定修改复制到当前分支"></a>把特定修改复制到当前分支</h2><p><code>git cherry-pick 1234ab</code></p><h2 id="查看远程地址"><a href="#查看远程地址" class="headerlink" title="查看远程地址"></a>查看远程地址</h2><ul><li><p>简略查看<br><code>git remote</code></p></li><li><p>详细查看<br><code>git remote -v</code></p></li></ul><h2 id="给特定的提交打标签"><a href="#给特定的提交打标签" class="headerlink" title="给特定的提交打标签"></a>给特定的提交打标签</h2><ul><li>给当前HEAD打标签</li></ul><p><code>git tag tagname</code></p><ul><li><p>给某个特定分支打标签<br><code>git tag tagname commit-id</code></p></li><li><p>给标签加上说明文字<br><code>git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb</code></p></li></ul><h2 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h2><p><code>.gitignore</code>主要用于忽略一些文件，不加入版本库。</p><p>当现有文件已经被git跟踪时，再使用.gitignore并没有用。此时需要使用<br><code>git rm -r --cached .</code>删除本地缓存，再使用.gitignore进行跟踪。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/897271968352576" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/896043488029600</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a&gt;背景介绍&lt;/h2&gt;&lt;p&gt;Git是由Linux之父使用C语言开发的一个分布式版本控制系统。分布式版本控制系统的特点是没有中央服务器，每一个人的电脑上都
      
    
    </summary>
    
      <category term="Git" scheme="https://yyb1995.github.io/categories/Git/"/>
    
    
  </entry>
  
  <entry>
    <title>json</title>
    <link href="https://yyb1995.github.io/2019/10/02/PythonPackages/json/"/>
    <id>https://yyb1995.github.io/2019/10/02/PythonPackages/json/</id>
    <published>2019-10-02T07:27:53.000Z</published>
    <updated>2019-10-02T08:20:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>python中的json模块用于python对象与json对象的转换及json文件的读写。</p><h2 id="json-dump"><a href="#json-dump" class="headerlink" title="json.dump"></a><code>json.dump</code></h2><p>这个函数主要用于把对象转成str类型并写入json文件。</p><pre><code class="python">import jsondict1 = {&#39;a&#39;: 1}with open(&#39;a.json&#39;, &#39;w&#39;) as f:    json.dump(dict1, f)</code></pre><h2 id="json-load"><a href="#json-load" class="headerlink" title="json.load"></a><code>json.load</code></h2><p>这个函数主要用于从json文件中读取数据并转成python中对应的对象。</p><pre><code class="python">import jsonwith open(&quot;a.json&quot;, &quot;r&quot;) as f:    dict1 = json.load(f)    print(dict1)</code></pre><h2 id="json-dumps"><a href="#json-dumps" class="headerlink" title="json.dumps"></a><code>json.dumps</code></h2><p>这个函数主要用于把python中的对象转成json格式的str，因为如果直接将dict类型的数据写入json文件中会发生报错，因此在将数据写入时需要用到该函数。可以传入indent=2参数，结构更清晰。如果对象中有中文，可以传入ensure_ascii=False参数确保显示正确。</p><pre><code class="python">import jsondict1 = {&quot;name&quot;: &quot;tom&quot;}str1 = json.dumps(dict1)print(type(str1))with open(&#39;a.json&#39;, &#39;w&#39;) as f:    f.write(str1)</code></pre><h2 id="json-loads"><a href="#json-loads" class="headerlink" title="json.loads"></a><code>json.loads</code></h2><p>这个函数主要用于把json形式的str转化为python对象。</p><pre><code class="python">with open(&#39;a.json&#39;, &#39;r&#39;) as f:    str1 = f.read()dict1 = json.loads(str1)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;python中的json模块用于python对象与json对象的转换及json文件的读写。&lt;/p&gt;
&lt;h2 id=&quot;json-dump&quot;&gt;&lt;a href=&quot;#json-dump&quot; class=&quot;headerlink&quot; title=&quot;json.dump&quot;&gt;&lt;/a&gt;&lt;code&gt;
      
    
    </summary>
    
      <category term="Python Packages" scheme="https://yyb1995.github.io/categories/Python-Packages/"/>
    
    
  </entry>
  
  <entry>
    <title>python中的正则表达式——re模块</title>
    <link href="https://yyb1995.github.io/2019/09/30/PythonPackages/re/"/>
    <id>https://yyb1995.github.io/2019/09/30/PythonPackages/re/</id>
    <published>2019-09-30T03:30:51.000Z</published>
    <updated>2019-10-02T02:11:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考教程：<a href="https://www.runoob.com/python/python-reg-expressions.html" target="_blank" rel="noopener">https://www.runoob.com/python/python-reg-expressions.html</a></p><p>一些有用的技巧：</p><ol><li><code>(?P&lt;tag\d&gt;)</code>。这种表示方式可以为搜索结果分组。在获取结果时可以使用<code>result.group(&#39;tag&#39;)</code>。通常用于<code>re.search()</code>和`re.match(</li><li><code>re.S</code>表示把<code>.</code>认为是<code>(.|\n)</code>，也就是<code>.</code>包含换行符。<code>re.I</code>表示忽略大小写。</li><li><code>re.findall()</code>返回一个列表，列表中每个元素表示一个匹配。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考教程：&lt;a href=&quot;https://www.runoob.com/python/python-reg-expressions.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.runoob.com/python/pyt
      
    
    </summary>
    
      <category term="Python" scheme="https://yyb1995.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Pytorch入门</title>
    <link href="https://yyb1995.github.io/2019/07/09/Pytorch/Pytorch%E5%85%A5%E9%97%A8/"/>
    <id>https://yyb1995.github.io/2019/07/09/Pytorch/Pytorch入门/</id>
    <published>2019-07-09T03:07:19.000Z</published>
    <updated>2019-07-09T03:07:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Pytorch教程"><a href="#1-Pytorch教程" class="headerlink" title="1 Pytorch教程"></a>1 Pytorch教程</h2><ol><li><a href="http://pytorch.apachecn.org/cn/docs/0.3.0/" target="_blank" rel="noopener">Pytorch中文文档</a></li><li><a href="https://pytorch.org/docs/stable/index.html" target="_blank" rel="noopener">Pytorch英文文档</a></li><li><a href="http://pytorch.org/tutorials/beginner/deep_learning_60min_blitz.html" target="_blank" rel="noopener">英文版：http://pytorch.org/tutorials/beginner/deep_learning_60min_blitz.html</a></li><li><a href="https://www.jianshu.com/p/889dbc684622" target="_blank" rel="noopener">中文版：https://www.jianshu.com/p/889dbc684622</a></li><li><a href="https://zhuanlan.zhihu.com/p/28475866" target="_blank" rel="noopener">Pytorch github项目整理</a></li></ol><h2 id="2-Pytorch安装"><a href="#2-Pytorch安装" class="headerlink" title="2 Pytorch安装"></a>2 Pytorch安装</h2><ol><li>建议使用Anaconda安装。清华大学anaconda pytorch地址： <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Pytorch教程&quot;&gt;&lt;a href=&quot;#1-Pytorch教程&quot; class=&quot;headerlink&quot; title=&quot;1 Pytorch教程&quot;&gt;&lt;/a&gt;1 Pytorch教程&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://pytorch.apac
      
    
    </summary>
    
      <category term="Pytorch" scheme="https://yyb1995.github.io/categories/Pytorch/"/>
    
    
      <category term="Pytorch" scheme="https://yyb1995.github.io/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>Latex常用代码段</title>
    <link href="https://yyb1995.github.io/2019/07/09/LaTeX/Latex%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E6%AE%B5/"/>
    <id>https://yyb1995.github.io/2019/07/09/LaTeX/Latex常用代码段/</id>
    <published>2019-07-09T03:07:19.000Z</published>
    <updated>2020-02-29T09:59:55.094Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-公式"><a href="#1-公式" class="headerlink" title="1 公式"></a>1 公式</h2><p><strong>一些小技巧：</strong></p><blockquote><ul><li>公式环境加<code>*</code>号会参与自动编号</li><li>公式环境可以嵌套。内层嵌套不能使用<code>*</code>号，且要&gt;加上<code>ed</code>。</li><li>最好不要留多余空行，否则可能报错。</li></ul></blockquote><ol><li><p>行内公式<br><code>$\a+b=c$</code></p></li><li><p>单行行间公式</p><pre><code class="latex">\begin{equation}X(i, j) = \begin{cases}0, \quad X(i, j)\text{缺失}\\1, \quad \text{其它}\end{cases}\end{equation}</code></pre></li><li><p>多行推导公式</p><pre><code class="latex">\begin{align*}f(x) &amp;= (x+a)(x+b) \\&amp;= x^2 + (a+b)x + ab\end{align*}</code></pre></li><li><p>多行对齐公式</p><pre><code class="latex"> \begin{gather*}     E(Y_t) = \mu \\     E\left(Y_{t}-\mu\right)^{2}=E\left(\epsilon_{t}+\theta \epsilon_{t-1}\right)^{2}=\left(1+\theta^{2}\right) \sigma^{2} \\     E\left(Y_{t}-\mu\right)\left(Y_{t-1}-\mu\right)=\theta \sigma^{2} \\    \end{gather*}</code></pre></li><li><p>多行条件公式</p><pre><code class="latex"></code></pre></li></ol><p>\begin{equation}<br>\begin{cases}<br>    123&amp;a=5\<br>    433434&amp;a=64554\<br>\end{cases}<br>\end{equation}</p><pre><code>6. gather内嵌套align```latexgather*内嵌套aligned：\begin{gather*}c=53223\begin{aligned}a&amp;=1\\&amp;=332\end{aligned}\end{gather*}</code></pre><ol start="7"><li>分段函数<br>```latex<br>smooth_{L_{1}}(x)=\begin{cases}</li><li>5x^{2}, &amp;\left |x \right |\leq 1 \cr \left |x \right|-0.5, &amp; otherwise<br>\end{cases}</li></ol><pre><code>## 2 图1. 一行一图```latex\begin{figure}  %图\centering  %插入的图片居中表示\includegraphics[width=\textwidth]{./figures/estimate.jpg}\renewcommand{\figurename}{Fig.}\renewcommand{\figurename}{图}\caption{不同数据缺失率下的数据补全结果}  %图片的名称\label{fig1}   %标签，用作引用\end{figure}</code></pre><ol start="2"><li><p>一行多图</p><pre><code class="latex">\usepackage{subcaption} \begin{figure}[H]     \begin{subfigure}{0.5\textwidth}     \includegraphics[width=\textwidth]{./figures/ar_1_acf.png}     \label{fig:3_classes}     \caption{}     \end{subfigure}     \begin{subfigure}{0.5\textwidth}     \includegraphics[width=\textwidth]{./figures/ar_1_pacf.png}     \label{fig:5_classes}     \caption{}     \end{subfigure}     \caption{ACF和PACF}   \end{figure}</code></pre></li></ol><h2 id="3-列表"><a href="#3-列表" class="headerlink" title="3 列表"></a>3 列表</h2><pre><code class="latex">% 有序列表\begin{enumerate}[(1)]% \begin{enumerate}[{[1]}]% \begin{enumerate}[(i)]\item 有编号的列表\item ...\end{enumerate}% 无序列表\begin{itemize}\item 无编号的列表\item ...\end{itemize}</code></pre><h2 id="4-表格"><a href="#4-表格" class="headerlink" title="4 表格"></a>4 表格</h2><ol><li><p>简单表格</p><pre><code class="latex"> \begin{table}[H] \centering \caption{预测误差分布}       \begin{tabular}{|c|c|c|c|c|} % 竖线表示是否在该列加竖线     \hline        &amp; 均值  &amp; 均值理论值 &amp;方差&amp;方差理论值\\       \hline       1步  &amp; 0.0103 &amp; 0 &amp; 0.9927 &amp; 1 \\       2步 &amp; 0.0141 &amp; 0 &amp; 1.2549 &amp; 1.25 \\     \hline \end{tabular}   \end{table}</code></pre></li><li><p>三行线表格</p><pre><code class="latex">\begin{table}[htp]     \centering     \caption{MA($\infty$)和GRU的最大可预测步数比较}     \label{Tab03}     % shorten cline length     \begin{tabular}{@{\extracolsep{12pt}}cccccccccc@{}}     \hline     \multirow{2}{*}{参数} &amp; \multicolumn{3}{c}{AR(1)} &amp; \multicolumn{3}{c}{AR(2)} &amp; \multicolumn{3}{c}{MA(2)} \\     \cline{2-4}  \cline{5-7} \cline{8-10}     &amp; 0.1 &amp; 0.5 &amp; 0.9 &amp; -0.1 &amp; -0.5 &amp; -0.7 &amp; -0.1 &amp; -0.2 &amp; -0.3 \\     \hline     MA($\infty$)&amp; 1 &amp; 3&amp; 19 &amp; 3 &amp; 6 &amp; 11 &amp; 2 &amp; 2 &amp; 2\\     GRU&amp; 1 &amp; 3 &amp; 20 &amp; 3 &amp; 5 &amp; 11 &amp; 2 &amp; 2 &amp; 2\\     \hline     \end{tabular}     \end{table}</code></pre></li><li><p>去掉表格标题</p><pre><code class="latex">% Delete : of image caption\usepackage{caption}\DeclareCaptionLabelSeparator{twospace}{\ ~}\captionsetup{labelsep=twospace}</code></pre></li><li><p>多行表格</p><pre><code class="latex">\begin{table}[htp] \centering \caption{不同条件下一些中间结果的动态范围} \label{cha_nonlinear} \begin{tabular}{@{\extracolsep{12pt}}cccccc@{}}     \hline     \multirow{2}{*}{序列编号} &amp; \multirow{2}{*}{条件}    &amp; \multicolumn{4}{c}{动态范围}\\     \cline{3-6}&amp; &amp; $\mathbf{A}_{enc}$  &amp; $X_{attn}$ &amp; $\mathbf{A}_{enc\_dec}$ &amp; $\hat{\mathbf{x}}_{pre}$\\     \hline     \multirow{4}{*}{1} &amp; 无线性投影，无位置编码 &amp; 1  &amp; 2 &amp; 3 &amp; 4\\     &amp; 有线性投影，无位置编码 &amp; 1  &amp; 2 &amp; 3 &amp; 4\\     &amp; 无线性投影，有位置编码 &amp; 1  &amp; 2 &amp; 3 &amp; 4 \\     &amp; 有线性投影，有位置编码 &amp; 1  &amp; 2 &amp; 3 &amp; 4\\     \hline \end{tabular}\end{table}</code></pre></li></ol><h2 id="5-调整页边距"><a href="#5-调整页边距" class="headerlink" title="5 调整页边距"></a>5 调整页边距</h2><pre><code class="latex">\usepackage{geometry}\geometry{a4paper,scale=0.8}\geometry{a4paper,left=2cm,right=2cm,top=1cm,bottom=1cm}</code></pre><h2 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6 参考文献"></a>6 参考文献</h2><ol><li>一般参考文献<pre><code class="latex">\usepackage{cite}\usepackage{natbib}\usepackage{hyperref}</code></pre></li></ol><p>% Place to the location of reference<br>\bibliographystyle{plain}<br>\bibliography{reference}</p><p>% Refer in the text<br>\cite{Wille1982}<br>% \citep{Wille1982}</p><pre><code>2. URL参考文献（无超链接）```latex\usepackage{url}@Misc{timmurphy.org,howpublished = {\url{http://timmurphy.org/2009/07/22/line-spacing-in-latex-documents/}},note = {Accessed April 4, 2010},title = {Line Spacing in LaTeX documents},author = {Murphy, Timothy I}}</code></pre><ol start="3"><li>超链接参考文献（可点击）<pre><code class="latex">\usepackage{hyperref}% 设置各种颜色\hypersetup{ colorlinks=true, % 使用颜色代替框 linkcolor=black, % 目录之类的颜色 filecolor=blue,   urlcolor=blue, % 引用url颜色 citecolor=blue, % 引用的颜色}@unpublished{Survey2014,title={Survey on the access tofinance of enterprises},author={Sophie Doove and Petra Gibcus andTon Kwaak and Lia Smit and Tommy Span},year=2014,note ={Accessed 16 June 2017.  \href{http://wwwe.ansa.it/documents/1415814222451\_Rapporto.pdf/}{http://wwwe.ansa.it/documents/1415814222451/_Rapporto.pdf/}},}</code></pre></li></ol><h2 id="7-页码"><a href="#7-页码" class="headerlink" title="7 页码"></a>7 页码</h2><pre><code class="latex">\thispagestyle{empty} % 在不需要设置页码的下面加\setcounter{page}{1} % 强制设置页码值</code></pre><h2 id="8-python代码"><a href="#8-python代码" class="headerlink" title="8 python代码"></a>8 python代码</h2><pre><code class="latex">\usepackage{listings}\usepackage{color}\definecolor{dkgreen}{rgb}{0,0.6,0}\definecolor{gray}{rgb}{0.5,0.5,0.5}\definecolor{mauve}{rgb}{0.58,0,0.82}\lstset{frame=tb,    language=Python,    aboveskip=3mm,    belowskip=3mm,    showstringspaces=false,    columns=flexible,    basicstyle={\small\ttfamily},    numbers=none,    numberstyle=\tiny\color{gray},    keywordstyle=\color{blue},    commentstyle=\color{dkgreen},    stringstyle=\color{mauve},    breaklines=true,    breakatwhitespace=true,    tabsize=3}\begin{lstlisting}print (&#39;Starting Iterations&#39;)for iter in range(n_iterations):for i in range(n):Users[i] = np.dot(np.dot(np.dot(np.linalg.inv(np.dot(np.dot(Items,np.diag(R[i])),Items.T) +lambda_ * np.eye(n_factors)),Items),np.diag(R[i])),A[i]).Tfor j in range(m):Items[:,j] = np.dot(np.dot(np.dot(np.linalg.inv(np.dot(np.dot(Users.T,np.diag(R[:,j])),Users) +lambda_ *np.eye(n_factors)),Users.T),np.diag(R[:,j])),A[:,j])#print (&#39;Error after solving for Item Matrix:%f&#39; % get_error(A, Users, Items, R))NMAE_List.append(get_error(A, Users, Items, R))print (&#39;%sth iteration is complete...&#39; % iter)print(&#39;Iteration finish&#39;)\end{lstlisting}```)\end{lstlisting}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-公式&quot;&gt;&lt;a href=&quot;#1-公式&quot; class=&quot;headerlink&quot; title=&quot;1 公式&quot;&gt;&lt;/a&gt;1 公式&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;一些小技巧：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;公式环境加&lt;code&gt;*
      
    
    </summary>
    
      <category term="Latex" scheme="https://yyb1995.github.io/categories/Latex/"/>
    
    
      <category term="Latex" scheme="https://yyb1995.github.io/tags/Latex/"/>
    
  </entry>
  
  <entry>
    <title>Latex安装</title>
    <link href="https://yyb1995.github.io/2019/07/09/LaTeX/Latex%E5%AE%89%E8%A3%85/"/>
    <id>https://yyb1995.github.io/2019/07/09/LaTeX/Latex安装/</id>
    <published>2019-07-09T03:07:19.000Z</published>
    <updated>2019-11-23T01:12:44.329Z</updated>
    
    <content type="html"><![CDATA[<ol><li><a href="https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/" target="_blank" rel="noopener">texlive离线安装</a></li><li><a href="http://texstudio.sourceforge.net/" target="_blank" rel="noopener">texstudio在线安装</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;texlive离线安装&lt;/a&gt;&lt;/li&gt;
&lt;li
      
    
    </summary>
    
      <category term="Latex" scheme="https://yyb1995.github.io/categories/Latex/"/>
    
    
      <category term="Latex" scheme="https://yyb1995.github.io/tags/Latex/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统使用过程中遇到的一些问题</title>
    <link href="https://yyb1995.github.io/2019/07/09/Linux/Linux%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://yyb1995.github.io/2019/07/09/Linux/Linux使用过程中的问题/</id>
    <published>2019-07-09T03:07:19.000Z</published>
    <updated>2019-07-09T03:07:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-无法进入GUI界面，可以使用Ctrl-Alt-F4进入命令行界面"><a href="#1-无法进入GUI界面，可以使用Ctrl-Alt-F4进入命令行界面" class="headerlink" title="1 无法进入GUI界面，可以使用Ctrl+Alt+F4进入命令行界面"></a>1 无法进入GUI界面，可以使用Ctrl+Alt+F4进入命令行界面</h2><p>这种情况可能是Nvidia显卡驱动安装出现了问题。解决方法：</p><ol><li><p>卸载原驱动：<code>sudo apt-get purge nvidia*</code></p></li><li><p>把显卡驱动加入PPA：<br><code>sudo add-apt-repository ppa:graphics-drivers</code> </p><p><code>sudo apt-get update</code></p></li><li><p>查找显卡驱动最新的版本号<br><code>sudo apt-cache search nvidia</code></p></li><li><p>采用apt-get命令在终端安装<br><code>sudo apt-get install nvidia-390 nvidia-settings nvidia-prime</code></p></li><li><p>使用<code>lsmod | grep nvidia</code>或<code>watch -n 1 nvidia-smi</code>查看是否安装成功-smi`查看是否安装成功</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-无法进入GUI界面，可以使用Ctrl-Alt-F4进入命令行界面&quot;&gt;&lt;a href=&quot;#1-无法进入GUI界面，可以使用Ctrl-Alt-F4进入命令行界面&quot; class=&quot;headerlink&quot; title=&quot;1 无法进入GUI界面，可以使用Ctrl+Alt
      
    
    </summary>
    
      <category term="Linux" scheme="https://yyb1995.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://yyb1995.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>联合体（Union）</title>
    <link href="https://yyb1995.github.io/2019/07/09/CProgrammingLanguage/%E8%81%94%E5%90%88%E4%BD%93%EF%BC%88Union%EF%BC%89/"/>
    <id>https://yyb1995.github.io/2019/07/09/CProgrammingLanguage/联合体（Union）/</id>
    <published>2019-07-09T03:07:19.000Z</published>
    <updated>2019-07-09T03:07:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="http://c.biancheng.net/cpp/html/2932.html" target="_blank" rel="noopener">http://c.biancheng.net/cpp/html/2932.html</a></p><h2 id="1-共用体的简介"><a href="#1-共用体的简介" class="headerlink" title="1. 共用体的简介"></a>1. 共用体的简介</h2><p>在C语言中，还有另外一种和结构体非常类似的语法，叫做共用体（Union），它的定义格式为：</p><pre><code class="c">union 共用体名{    成员列表};</code></pre><p>结构体和共用体的区别在于：结构体的各个成员会占用不同的内存，互相之间没有影响；<strong><em>而共用体的所有成员占用同一段内存，所有成员的存储首地址相同。</em></strong>因此更改一个成员的值可能影响所有成员的值。结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙），<strong><em>共用体占用的内存等于最长的成员占用的内存。</em></strong>共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。<br>共用体也是一种自定义类型，可以通过它来创建变量，例如：</p><pre><code class="c">union data{    int n;    char ch;    double f;};union data a, b, c;</code></pre><p>上面是先定义共用体，再创建变量，也可以在定义共用体的同时创建变量：</p><pre><code class="c">union data{    int n;    char ch;    double f;} a, b, c;</code></pre><p>如果不再定义新的变量，也可以将共用体的名字省略：</p><pre><code class="c">union{    int n;    char ch;    double f;} a, b, c;</code></pre><p>共用体 data 中，成员 f 占用的内存最多，为 8 个字节，所以 data 类型的变量（也就是 a、b、c）也占用 8 个字节的内存，请看下面的演示：</p><pre><code class="c">#include &lt;stdio.h&gt;union data{    int n;  //int类型占用4个字节    char ch;  //char类型占用1个字节    short m;  //short类型占用2个字节};int main(){    union data a;    printf(&quot;%d, %d\n&quot;, sizeof(a), sizeof(union data) );    a.n = 0x40;    printf(&quot;%X, %c, %hX\n&quot;, a.n, a.ch, a.m);    a.ch = &#39;9&#39;;    printf(&quot;%X, %c, %hX\n&quot;, a.n, a.ch, a.m);    a.m = 0x2059;    printf(&quot;%X, %c, %hX\n&quot;, a.n, a.ch, a.m);    a.n = 0x3E25AD54;    printf(&quot;%X, %c, %hX\n&quot;, a.n, a.ch, a.m);    return 0;}</code></pre><p>运行结果：</p><blockquote><p>4, 4<br>40, @, 40  //‘@’是ASCII码等于0x40的字符<br>39, 9, 39  //0x39是’9’的ASCII码<br>2059, Y, 2059  //‘Y’是ASCII码等于0x59的字符<br>3E25AD54, T, AD54</p></blockquote><p>这段代码不但验证了共用体的长度，还说明共用体成员之间会相互影响，修改一个成员的值会影响其他成员。<br>要想理解上面的输出结果，弄清成员之间究竟是如何相互影响的，就得了解各个成员在内存中的分布。以上面的 data 为例，各个成员在内存中的分布如下：</p><p><img src="http://c.biancheng.net/cpp/uploads/allimg/160811/1-160Q1152HRM.jpg" alt></p><p>成员 n、ch、m 在内存中“对齐”到一头，对 ch 赋值修改的是前一个字节，对 m 赋值修改的是前两个字节，对 n 赋值修改的是全部字节。也就是说，ch、m 会影响到 n 的一部分数据，而 n 会影响到 ch、m 的全部数据。<br>上图是在绝大多数 PC机上的内存分布情况，如果是51单片机，情况就会有所不同：</p><p><img src="http://c.biancheng.net/cpp/uploads/allimg/160811/1-160Q116311LV.jpg" alt></p><p>为什么不同的机器会有不同的分布情况呢？这跟机器的存储模式有关。</p><h2 id="2-共用体的应用"><a href="#2-共用体的应用" class="headerlink" title="2. 共用体的应用"></a>2. 共用体的应用</h2><p>共用体在一般的编程中应用较少，在单片机中应用较多。对于PC机，经常使用到的一个实例是：现有一张关于学生信息和教师信息的表格。学生信息包括姓名、编号、性别、职业、分数，教师的信息包括姓名、编号、性别、职业、教学科目。请看下面的表格：</p><table><thead><tr><th align="center">Name</th><th align="center">Num</th><th align="center">Sex</th><th align="center">Profession</th><th align="center">Score / Course</th></tr></thead><tbody><tr><td align="center">HanXiaoXiao</td><td align="center">501</td><td align="center">f</td><td align="center">s</td><td align="center">89.5</td></tr><tr><td align="center">YanWeiMin</td><td align="center">1011</td><td align="center">m</td><td align="center">t</td><td align="center">math</td></tr><tr><td align="center">LiuZhenTao</td><td align="center">109</td><td align="center">f</td><td align="center">t</td><td align="center">English</td></tr><tr><td align="center">ZhaoFeiYan</td><td align="center">982</td><td align="center">m</td><td align="center">s</td><td align="center">95.0</td></tr></tbody></table><p>f 和 m 分别表示女性和男性，s表示学生，t表示教师。可以看出，学生和教师所包含的数据是不同的。现在要求把这些信息放在同一个表格中，并设计程序输入人员信息然后输出。<br>如果把每个人的信息都看作一个结构体变量的话，那么教师和学生的前4个成员变量是一样的，第 5个成员变量可能是score或者course。当第4个成员变量的值是 s 的时候，第 5 个成员变量就是score；当第4个成员变量的值是t的时候，第 5 个成员变量就是 course。<br>经过上面的分析，我们可以设计一个包含共用体的结构体，请看下面的代码：</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define TOTAL 4  //人员总数struct{    char name[20];    int num;    char sex;    char profession;    union{        float score;        char course[20];    } sc;} bodys[TOTAL];int main(){    int i;    //输入人员信息    for(i=0; i&lt;TOTAL; i++){        printf(&quot;Input info: &quot;);        scanf(&quot;%s %d %c %c&quot;, bodys[i].name, &amp;(bodys[i].num), &amp;(bodys[i].sex), &amp;(bodys[i].profession));        if(bodys[i].profession == &#39;s&#39;){  //如果是学生            scanf(&quot;%f&quot;, &amp;bodys[i].sc.score);        }else{  //如果是老师            scanf(&quot;%s&quot;, bodys[i].sc.course);        }        fflush(stdin);    }    //输出人员信息    printf(&quot;\nName\t\tNum\tSex\tProfession\tScore / Course\n&quot;);    for(i=0; i&lt;TOTAL; i++){        if(bodys[i].profession == &#39;s&#39;){  //如果是学生            printf(&quot;%s\t%d\t%c\t%c\t\t%f\n&quot;, bodys[i].name, bodys[i].num, bodys[i].sex, bodys[i].profession, bodys[i].sc.score);        }else{  //如果是老师            printf(&quot;%s\t%d\t%c\t%c\t\t%s\n&quot;, bodys[i].name, bodys[i].num, bodys[i].sex, bodys[i].profession, bodys[i].sc.course);        }    }    return 0;}</code></pre><p>运行结果：</p><blockquote><p>Input info: HanXiaoXiao 501 f s 89.5<br>Input info: YanWeiMin 1011 m t math<br>Input info: LiuZhenTao 109 f t English<br>Input info: ZhaoFeiYan 982 m s 95.0</p></blockquote><blockquote><p>Name            Num     Sex     Profession      Score / Course<br>HanXiaoXiao     501     f       s               89.500000<br>YanWeiMin       1011    m       t               math<br>LiuZhenTao      109     f       t               English<br>ZhaoFeiYan      982     m       s               95.000000</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文地址：&lt;a href=&quot;http://c.biancheng.net/cpp/html/2932.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://c.biancheng.net/cpp/html/2932.html&lt;/a&gt;&lt;/p&gt;
      
    
    </summary>
    
      <category term="C语言" scheme="https://yyb1995.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="编程语言" scheme="https://yyb1995.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Matlab GUI编程入门</title>
    <link href="https://yyb1995.github.io/2019/07/09/Matlab/MATLAB%20GUI%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
    <id>https://yyb1995.github.io/2019/07/09/Matlab/MATLAB GUI编程入门/</id>
    <published>2019-07-09T03:07:19.000Z</published>
    <updated>2020-02-29T10:01:07.884Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题外话"><a href="#1-题外话" class="headerlink" title="1 题外话"></a>1 题外话</h2><p>这学期刚好在学信息论，里面各种熵函数信道容量的计算十分繁杂，于是乎想编写一个有GUI界面的信息论计算器。由于MATLAB对于矩阵的运算十分方便，所以选择以MATLAB为基础进行程序编写和界面设计。</p><hr><h2 id="2-回调函数callback中常用函数"><a href="#2-回调函数callback中常用函数" class="headerlink" title="2 回调函数callback中常用函数"></a>2 回调函数callback中常用函数</h2><ol><li>get(hObject,’String’)</li></ol><ul><li>获得一个控件的字符串属性，常配合str2double函数使用，用于获得输入的数字以及判断输入的是否为数字</li><li>hObject相当于当前操作的控件的句柄，如果是在同一个GUI界面，可以使用<code>handles.Tags</code>，也就是 当前GUI的句柄名.要获得数据的控件标签名 来从其他控件获得数据。</li></ul><ol start="2"><li>set(hObject,’String’,’content’)<br>设置一个控件的字符串属性，常用于设置输入数字的设置</li><li>guidata(hObject,handles)保存前面对hObject和handles的设置，一般回传函数callback的最后一行都是这段代码，用来更新数据</li><li></li></ol><h1 id="常用对话框"><a href="#常用对话框" class="headerlink" title="常用对话框"></a>常用对话框</h1><p>tips:</p><ul><li>每个GUI窗口都有一个初始化函数，类似于<code>function simple_gui_OpeningFcn(hObject, eventdata, handles, varargin)</code>,这个初始化函数用于在创建这个GUI时创建一些参数以及在退出时返回一些参数。在这个函数中创建的参数可以被这个GUI里面的所有Object控件的回调函数调用。 </li><li><h1 id="fdsf"><a href="#fdsf" class="headerlink" title="fdsf "></a>fdsf </h1>常用控件</li></ul><ol><li>弹出菜单（Pop-up Menu）<br>在属性设置菜单（Inspector）中的’String’项可以对弹出菜单的项目进行设置，在’String’项第一行的内容将默认显示在弹出菜单中。在回调函数中，需要对弹出菜单中的每一项设置相应的代码，常用的语句是switch…case…end语句。常用的代码段：<pre><code class="matlab">string = get(hObject,&#39;String&#39;);value = get(hObject,&#39;Value&#39;);switch string{value}case &#39;A&#39; %列表第一项end</code></pre></li></ol><p>value = get(hObject,’Value’);<br>switch value<br>case 1  %1即为列表中的第一项<br>end</p><pre><code>=======================================创建新窗口的方法：1. 使用guide创建一个新窗口并对其中的控件进行设置，将其命名（假设为child.fig）2. 在触发显示新窗口的回调函数中加上如下语句：``` matlabrun(&#39;child&#39;);  %or open(&#39;child.fig&#39;);h = guihandles;  %h为新窗口的句柄变量，相当于原窗口的handles，可以使用如h.text1来操作新窗口的控件set(h.text1,&#39;String&#39;,&#39;Hello child&#39;);  %这是一个将新窗口中的text1控件显示的字符串设置成&#39;Hello child&#39;的例子</code></pre><p>======================================<br>在回调函数之间和UI之间传递数据的方法<br>1.setappdata(obj,name,val)</p><ul><li>obj为想要存储的数据所在的窗口的句柄变量，类似于handles，称为图形对象</li><li>name为存储该数据的变量名</li><li>val为数据的值<br>例如：<code>setappdata(f,&#39;todaysdate&#39;,val); %将句柄名为f的UI窗口中的数据val存放在名为todaysdate的变量中</code></li></ul><ol start="2"><li>val = getappdata(obj,name)<br>vals = getappdata(obj)</li></ol><ul><li>obj为想要取出的数据所在的窗口的句柄变量，类似于handles，它的值应该和对应的getappdata函数中的obj相同</li><li>name为存储该数据的变量名</li><li>注意左边需要设置一个val变量用于存放取出该数据的变量</li><li>vals为取出同一个图形对象中存放的所有共享数据</li></ul><p>=========================================<br>在同一个窗口中根据不同选择显示不同控件的方法<br>初始化时将要显示的控件的Visible属性选择为On，其他控件选择为Off，在每个按钮的回调函数中利用<code>set(handles.edit4,&#39;Visible&#39;,&#39;on&#39;)</code>等代码进行调整即可</p><p>=======================================<br>设置按下按钮或右上角弹出是否关闭的对话框的方法：<br>在按钮的回调函数或当前窗口的CloseRequestFcn函数中加上<br>selection = questdlg(‘Close the figure window?’,…<br>    ‘Confirmation’,…<br>    ‘Yes’,’No’,’Yes’);<br>switch selection,<br>    case ‘Yes’,<br>        delete(gcf);  %gcf为当前图像句柄<br>    case ‘No’<br>        return<br>end</p><p>============================================<br>matlab GUI中插入图片的方法<br>axes(handles.axes2);<br>imshow(‘jin.jpg’);</p><p>清除图片的方法<br>cla reset;</p><p>不显示坐标轴的方法：<br>set(handles.axes1,’visible’,’off’)<br>需要使用时改成on即可</p><p>=================================<br>控件大小通过更改position中的height和weight选项即可</p><p>换行可以使用sprintf(‘\n’)或 [char(10,13)’]实现</p><p>matlab两个浮点数或整数和浮点数比较应该用abs(a - b) &lt; eps，而不是a - b</p><p>==================================<br>调整当前窗口到屏幕中央<br><code>movegui( gcf, &#39;center&#39;)</code>。其他位置查阅movegui函数即可</p><p>===================================<br>matlab 显示矩阵<br>set(handles.uitable1, ‘Data’, comparison);</p><p>=================================<br>判断一个矩阵中所有元素是否等于0<br><code>any(abs(input2_2_temp(:) - 0 ) &gt; eps)</code></p><p>MATLAB解线性方程组<br>Ax = b<br>x = A\b</p><p>====================================<br>matlab中取出一个数组中某些特定元素<br><strong><em>a(a == 0) %取出a中所有等于0的元素，可接赋值语句，如a(a == 0) = 1;</em></strong></p><p>=================<br>MATLAB 函数句柄<br>格式：H = @(x)cos(x)<br>相当于H(x) = cos(x)</p><p>==================================<br>标记图像中的最大值</p><pre><code class="matlab">%first solutionclc;clear allx=0:0.01:2*pi;y=sin(x);p=find(y == max(y));plot(x,y,&#39;r&#39;,&#39;linewidth&#39;,2)grid ontext(x(p),y(p),&#39;o&#39;,&#39;color&#39;,&#39;g&#39;)axis([0 2*pi -1.4 1.4]);%second solutionclc;clear allx=0:0.01:2*pi;y=sin(x);p=find(y==max(y));plot(x,y,&#39;r&#39;,&#39;linewidth&#39;,2)grid onaxis([0 2*pi -1.4 1.4])text(x(p),y(p),[&#39;(&#39;,num2str(x(p)),&#39;,&#39;,num2str(y(p)),&#39;)&#39;],&#39;color&#39;,&#39;b&#39;);</code></pre><p>====================================<br>MATLAB GUI 设置每个控件的显示顺序<br>右键单击控件，有两个选项：Bring to front 和send<br> to back，可以设置控件图层顺序</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-题外话&quot;&gt;&lt;a href=&quot;#1-题外话&quot; class=&quot;headerlink&quot; title=&quot;1 题外话&quot;&gt;&lt;/a&gt;1 题外话&lt;/h2&gt;&lt;p&gt;这学期刚好在学信息论，里面各种熵函数信道容量的计算十分繁杂，于是乎想编写一个有GUI界面的信息论计算器。由于MATL
      
    
    </summary>
    
      <category term="Matlab" scheme="https://yyb1995.github.io/categories/Matlab/"/>
    
    
  </entry>
  
  <entry>
    <title>最小二乘解与最小二乘估计</title>
    <link href="https://yyb1995.github.io/2019/07/09/MachineLearning/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E8%A7%A3(Least-squares%20Minimization)/"/>
    <id>https://yyb1995.github.io/2019/07/09/MachineLearning/最小二乘解(Least-squares Minimization)/</id>
    <published>2019-07-09T03:07:19.000Z</published>
    <updated>2019-07-09T03:07:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最小二乘解与最小二乘估计资料"><a href="#最小二乘解与最小二乘估计资料" class="headerlink" title="最小二乘解与最小二乘估计资料"></a>最小二乘解与最小二乘估计资料</h2><ol><li><a href="https://blog.csdn.net/kokerf/article/details/72437294" target="_blank" rel="noopener">最小二乘解</a></li><li><a href="https://www.qiujiawei.com/linear-algebra-15/" target="_blank" rel="noopener">最小二乘估计</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;最小二乘解与最小二乘估计资料&quot;&gt;&lt;a href=&quot;#最小二乘解与最小二乘估计资料&quot; class=&quot;headerlink&quot; title=&quot;最小二乘解与最小二乘估计资料&quot;&gt;&lt;/a&gt;最小二乘解与最小二乘估计资料&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https:/
      
    
    </summary>
    
      <category term="Machine Learning" scheme="https://yyb1995.github.io/categories/Machine-Learning/"/>
    
    
      <category term="机器学习" scheme="https://yyb1995.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>用Keras搭建第一个神经网络</title>
    <link href="https://yyb1995.github.io/2019/07/09/Keras/Build%20the%20First%20Neural%20Network/"/>
    <id>https://yyb1995.github.io/2019/07/09/Keras/Build the First Neural Network/</id>
    <published>2019-07-09T03:07:19.000Z</published>
    <updated>2019-07-09T03:07:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Steps"><a href="#1-Steps" class="headerlink" title="1 Steps"></a>1 Steps</h2><ol><li>Load Data</li><li>Define Model</li><li>Compile Model</li><li>Fit Model</li><li>Evaluate Model</li><li>Tie It All Together</li></ol><h2 id="2-Load-Data"><a href="#2-Load-Data" class="headerlink" title="2 Load Data"></a>2 Load Data</h2><ol><li>Define a certain random number seed. By doing so, you can get the same result to compare it with other model.<br>Method:<pre><code class="python">import numpy as npnp.random.seed(7)</code></pre>We use <a href="https://yun.baidu.com/s/1c24tweW#list/path=%2F" target="_blank" rel="noopener">pima-indians-diabetes.csv</a> as our dataset. To load the .csv data, we use <code>np.loadtxt</code> and split it into input and output section. <h2 id="3-Define-Model"><a href="#3-Define-Model" class="headerlink" title="3 Define Model"></a>3 Define Model</h2>Models in Keras are defined as a sequence of layers.While defining the first layer, we can define the input number with the <strong>input_dim</strong> argument.<br>In this example, we will use a fully-connected network structure with three layers.<br>Fully connected layers are defined using the <strong>Dense class</strong>. We can specify:</li><li><strong>the number of neurons</strong> in the layer as the first argument</li><li>the initialization method as the second argument as <strong>init</strong> </li><li>specify the activation function using the <strong>activation</strong> argument.<h2 id="4-Build-the-Model"><a href="#4-Build-the-Model" class="headerlink" title="4 Build the Model"></a>4 Build the Model</h2>define a model class. In this problem, we use a sequential model. So we use a <code>model = keras.sequential()</code> to instantiate the class. And then use the <code>.add</code> method to add layers in the model.<br>We want to add a layer into our model, so we use <code>keras.layers.Dense()</code> to be the parameter of <code>add</code>. The activation function must be in the string form like <code>activation=&#39;relu&#39;</code>.</li></ol><h2 id="5-Compile-the-Model"><a href="#5-Compile-the-Model" class="headerlink" title="5 Compile the Model"></a>5 Compile the Model</h2><p>When compiling, we must specify some additional properties required when training the network.We must specify the <strong>loss function</strong> to use to evaluate a set of weights, <strong>the optimizer</strong> used to search through different weights for the network and <strong>any optional metrics we would like to collect and report</strong> during training.</p><h2 id="6-Fit-the-model"><a href="#6-Fit-the-model" class="headerlink" title="6 Fit the model"></a>6 Fit the model</h2><p>use <code>model.fit()</code> method to define fit parameters like epochs and batch_size.</p><h2 id="7-Evaluate-the-model"><a href="#7-Evaluate-the-model" class="headerlink" title="7 Evaluate the model"></a>7 Evaluate the model</h2><p>use <code>model.evaluate</code> and a set of X and Y to calculate the model performance.</p><h2 id="8-Prediction"><a href="#8-Prediction" class="headerlink" title="8 Prediction"></a>8 Prediction</h2><p>use <code>model.fit</code> and a set of X to predict the predicted Y value.</p><h2 id="9-Related-material"><a href="#9-Related-material" class="headerlink" title="9 Related material"></a>9 Related material</h2><ol><li><a href="https://machinelearningmastery.com/" target="_blank" rel="noopener">https://machinelearningmastery.com/</a></li><li><a href="https://keras-cn.readthedocs.io/en/latest/" target="_blank" rel="noopener">Keras中文文档</a></li><li><a href="https://github.com/keras-team/keras/tree/master/examples" target="_blank" rel="noopener">Keras Example</a><br>s-team/keras/tree/master/examples)</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Steps&quot;&gt;&lt;a href=&quot;#1-Steps&quot; class=&quot;headerlink&quot; title=&quot;1 Steps&quot;&gt;&lt;/a&gt;1 Steps&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Load Data&lt;/li&gt;
&lt;li&gt;Define Model&lt;/li&gt;
&lt;li&gt;Com
      
    
    </summary>
    
      <category term="Keras" scheme="https://yyb1995.github.io/categories/Keras/"/>
    
    
      <category term="深度学习" scheme="https://yyb1995.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>颜色收集</title>
    <link href="https://yyb1995.github.io/2019/07/09/Others/%E5%B8%B8%E7%94%A8%E9%A2%9C%E8%89%B2%E6%94%B6%E9%9B%86/"/>
    <id>https://yyb1995.github.io/2019/07/09/Others/常用颜色收集/</id>
    <published>2019-07-09T03:07:19.000Z</published>
    <updated>2020-02-29T09:57:18.920Z</updated>
    
    <content type="html"><![CDATA[<pre><code>#929292 grey#FFBBFF pink#BBFFBB green#BBFFFF blue#FFFFBB yellow#FF9999 red</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;#929292 grey
#FFBBFF pink
#BBFFBB green
#BBFFFF blue
#FFFFBB yellow
#FF9999 red&lt;/code&gt;&lt;/pre&gt;
      
    
    </summary>
    
      <category term="Others" scheme="https://yyb1995.github.io/categories/Others/"/>
    
    
      <category term="Color" scheme="https://yyb1995.github.io/tags/Color/"/>
    
  </entry>
  
  <entry>
    <title>Python 迭代器(iterator) 生成器(generator)</title>
    <link href="https://yyb1995.github.io/2019/07/09/Python/Python%20%E8%BF%AD%E4%BB%A3%E5%99%A8(iterator)%20%E7%94%9F%E6%88%90%E5%99%A8(generator)/"/>
    <id>https://yyb1995.github.io/2019/07/09/Python/Python 迭代器(iterator) 生成器(generator)/</id>
    <published>2019-07-09T03:07:19.000Z</published>
    <updated>2019-07-09T03:07:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="可迭代对象-iterable"><a href="#可迭代对象-iterable" class="headerlink" title="可迭代对象(iterable)"></a>可迭代对象(iterable)</h2><ul><li><p>定义</p><p> iterable又称为可迭代对象。在Python中，如果一个对象（又称为container object）实现了<code>__iter__()</code>方法或者可以支持下标索引的<code>__getitem__()</code>方法，就称为一个可迭代对象。</p></li><li><p><code>__iter__()</code>方法</p><p> 调用一个可迭代对象的<code>__iter__()</code>方法会返回一个当前可迭代对象的一个迭代器(iterator)。这个在下一章会提到。</p></li><li><p><code>iter()</code>方法</p><p> 调用一个可迭代对象的<code>iter()</code>方法会返回一个当前可迭代对象的一个迭代器(iterator)。</p></li><li><p>判断方法<br>在Python中，我们常用到的集合数据类型都是iterable的。如列表(list)，元组(tuple)，字典(dict)，集合(set)，字符串(str)等。在程序中判断一个对象是否是iterable的方法为</p><pre><code class="python"># Method1: use isinstancefrom collections import Iterableisinstance([1, 2, 3], Iterable)# Method2: use for loopfor i in [1, 2, 3]:    print(i)</code></pre></li></ul><h2 id="迭代器-iterator"><a href="#迭代器-iterator" class="headerlink" title="迭代器(iterator)"></a>迭代器(iterator)</h2><ul><li><p>定义</p><p> 借用<a href="https://docs.python.org/dev/howto/functional.html#iterators" target="_blank" rel="noopener">Python文档</a>中对迭代器的定义，一个迭代器指的是一个包含着数据流的对象，它每次返回数据中的一个元素。一个可迭代对象本身也可以是迭代器，但是这样在迭代一次之后数据本身将无法使用，除非将迭代器重置。在Python中大部分迭代器和可迭代对象是分离的，这样就保证了能够重复产生迭代器。</p></li><li><p><code>__next__()</code>方法</p><p> 一个迭代器必须实现<code>__next__()</code>方法。在每次调用<strong>迭代器</strong>（注意，不是可迭代对象）的<code>__next__()</code>方法时顺序返回数据的一个元素。当遍历完数据后抛出<code>StopIteration</code>异常，表示迭代完成。这时迭代器也就完成了它的使命。</p></li><li><p><code>__iter__()</code>方法</p><p> 调用一个迭代器的<code>__iter__()</code>方法会返回迭代器对象本身，注意每次调用产生一个新的迭代器对象。</p></li><li><p><code>next()</code>方法</p><p> 在<code>next()</code>内传入一个迭代器，可以得到迭代器的下一个值。</p></li></ul><h2 id="生成器-generator"><a href="#生成器-generator" class="headerlink" title="生成器(generator)"></a>生成器(generator)</h2><ul><li><p>定义</p><p> 生成器可以看成是迭代器的简化版。生成器只需要定义一个函数，并将普通函数的<code>return</code>改为<code>yield</code>即可。</p></li></ul><ul><li><p>使用<br> 在使用生成器时，可以像一个普通的迭代器一样，使用<code>for in</code>或者<code>next()</code>方法获取其中的值。</p><pre><code class="python"> # Define a generator def range_like(n):     i = 0     while i &lt; n:         yield i         i += 1 # Create a generator object a = range_like(5) a.__next__() for i in range_like(n):     print(i)</code></pre></li></ul><h2 id="迭代器、生成器的关系"><a href="#迭代器、生成器的关系" class="headerlink" title="迭代器、生成器的关系"></a>迭代器、生成器的关系</h2><p>迭代器、生成器、可迭代对象的关系可用下图表示<br><img src="https://i.loli.net/2017/05/06/590d99e937114.png" alt></p><h2 id="for语句的执行顺序"><a href="#for语句的执行顺序" class="headerlink" title="for语句的执行顺序"></a>for语句的执行顺序</h2><p>在对一个iterable对象使用<code>for</code>语句时，实际上先调用了<code>iter()</code>方法返回一个iterator，然后再依次调用<code>__next__()</code>方法获得每一个值。当抛出<code>StopIteration</code>异常时意味着<code>for</code>语句的结束。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><p><a href="https://stackoverflow.com/questions/9884132/what-exactly-are-iterator-iterable-and-iteration" target="_blank" rel="noopener">What exactly are iterator, iterable and iteration</a></p></li><li><p><a href="https://docs.python.org/3/tutorial/classes.html#iterators" target="_blank" rel="noopener">9.8. Iterators</a></p></li><li><p><a href="https://www.jianshu.com/p/24876cf14a5c" target="_blank" rel="noopener">彻底理解Iterable, Iterator, generator</a></p></li><li><p><a href="https://blog.csdn.net/dawningblue/article/details/72629362" target="_blank" rel="noopener">Python中iteration(迭代)、iterator(迭代器)、generator(生成器)等相关概念的理解</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;可迭代对象-iterable&quot;&gt;&lt;a href=&quot;#可迭代对象-iterable&quot; class=&quot;headerlink&quot; title=&quot;可迭代对象(iterable)&quot;&gt;&lt;/a&gt;可迭代对象(iterable)&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;定义&lt;/p&gt;
&lt;p&gt; 
      
    
    </summary>
    
      <category term="Python" scheme="https://yyb1995.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://yyb1995.github.io/tags/Python/"/>
    
  </entry>
  
</feed>
